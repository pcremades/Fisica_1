# Created by Octave 3.8.2, Wed Nov 18 09:23:55 2015 ART <pablo@phyLab>
# name: cache
# type: cell
# rows: 3
# columns: 712
# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
!


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
 -- Operator: !
     Logical 'not' operator.

     See also: ~, not.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Logical 'not' operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
!=


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
 -- Operator: !=
     Logical 'not equals' operator.

     See also: ~=, ne.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Logical 'not equals' operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
"


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
 -- Operator: "
     String delimiter.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
String delimiter.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
#


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
 -- Operator: #
     Begin comment character.

     See also: %, #{.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Begin comment character.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
#{


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 214
 -- Operator: # {
     Begin block comment.  There must be nothing else, other than
     whitespace, in the line both before and after '#{'.  It is possible
     to nest block comments.

     See also: %{, #}, #.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
Begin block comment.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
#}


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 214
 -- Operator: # }
     Close block comment.  There must be nothing else, other than
     whitespace, in the line both before and after '#}'.  It is possible
     to nest block comments.

     See also: %}, #{, #.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
Close block comment.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
%


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
 -- Operator: %
     Begin comment character.

     See also: #, %{.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Begin comment character.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
%{


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 214
 -- Operator: % {
     Begin block comment.  There must be nothing else, other than
     whitespace, in the line both before and after '%{'.  It is possible
     to nest block comments.

     See also: #{, %}, %.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
Begin block comment.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
%}


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 214
 -- Operator: % }
     Close block comment.  There must be nothing else, other than
     whitespace, in the line both before and after '%}'.  It is possible
     to nest block comments.

     See also: #}, %{, %.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
Close block comment.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
&


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 90
 -- Operator: &
     Element by element logical 'and' operator.

     See also: &&, and.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Element by element logical 'and' operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
&&


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
 -- Operator: &&
     Logical 'and' operator (with short-circuit evaluation).

     See also: &, and.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Logical 'and' operator (with short-circuit evaluation).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
'


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 325
 -- Operator: '
     Matrix transpose operator.  For complex matrices, computes the
     complex conjugate (Hermitian) transpose.

     The single quote character may also be used to delimit strings, but
     it is better to use the double quote character, since that is never
     ambiguous.

     See also: .', transpose.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Matrix transpose operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
(


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
 -- Operator: (
     Array index or function argument delimiter.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Array index or function argument delimiter.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
)


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
 -- Operator: )
     Array index or function argument delimiter.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Array index or function argument delimiter.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
*


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
 -- Operator: *
     Multiplication operator.

     See also: .*, times.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Multiplication operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
**


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 255
 -- Operator: **
     Power operator.  This may return complex results for real inputs.
     Use 'realsqrt', 'cbrt', 'nthroot', or 'realroot' to obtain real
     results when possible.

     See also: power, ^, .**, .^, realpow, realsqrt, cbrt, nthroot.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
Power operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
+


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
 -- Operator: +
     Addition operator.

     See also: plus.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
Addition operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
++


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 125
 -- Operator: ++
     Increment operator.  As in C, may be applied as a prefix or postfix
     operator.

     See also: -.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
Increment operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
,


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
 -- Operator: ,
     Array index, function argument, or command separator.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Array index, function argument, or command separator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
-


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 85
 -- Operator: -
     Subtraction or unary negation operator.

     See also: minus.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Subtraction or unary negation operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
--


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 126
 -- Operator: --
     Decrement operator.  As in C, may be applied as a prefix or postfix
     operator.

     See also: ++.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
Decrement operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
.'


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 171
 -- Operator: .'
     Matrix transpose operator.  For complex matrices, computes the
     transpose, _not_ the complex conjugate transpose.

     See also: ', transpose.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Matrix transpose operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
.*


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
 -- Operator: .*
     Element by element multiplication operator.

     See also: *, times.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Element by element multiplication operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
.**


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 324
 -- Operator: .*
     Element by element power operator.  If several complex results are
     possible, returns the one with smallest non-negative argument
     (angle).  Use 'realpow', 'realsqrt', 'cbrt', or 'nthroot' if a real
     result is preferred.

     See also: **, ^, .^, power, realpow, realsqrt, cbrt, nthroot.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Element by element power operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
...


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 86
 -- Operator: ...
     Continuation marker.  Joins current line with following line.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
Continuation marker.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
./


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 108
 -- Operator: ./
     Element by element right division operator.

     See also: /, ., rdivide, mrdivide.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Element by element right division operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
.\


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 107
 -- Operator: .\
     Element by element left division operator.

     See also: , ./, rdivide, mrdivide.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Element by element left division operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
.^


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 325
 -- Operator: .^
     Element by element power operator.  If several complex results are
     possible, returns the one with smallest non-negative argument
     (angle).  Use 'realpow', 'realsqrt', 'cbrt', or 'nthroot' if a real
     result is preferred.

     See also: .**, ^, **, power, realpow, realsqrt, cbrt, nthroot.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Element by element power operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
/


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 88
 -- Operator: /
     Right division operator.

     See also: ./, , rdivide, mrdivide.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Right division operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
:


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
 -- Operator: :
     Select entire rows or columns of matrices.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Select entire rows or columns of matrices.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
;


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
 -- Operator: ;
     Array row or command separator.

     See also: ,.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Array row or command separator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
<


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
 -- Operator: <
     'Less than' operator.

     See also: lt.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
'Less than' operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
<=


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
 -- Operator: <=
     'Less than' or 'equals' operator.

     See also: le.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
'Less than' or 'equals' operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
=


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
 -- Operator: =
     Assignment operator.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
Assignment operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
==


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
 -- Operator: ==
     Equality test operator.

     See also: eq.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Equality test operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
>


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
 -- Operator: >
     'Greater than' operator.

     See also: gt.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
'Greater than' operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
>=


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 -- Operator: >=
     'Greater than' or 'equals' operator.

     See also: ge.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
'Greater than' or 'equals' operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
[


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
 -- Operator: [
     Return list delimiter.

     See also: ].




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Return list delimiter.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
\


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 87
 -- Operator: \
     Left division operator.

     See also: ., /, ldivide, mldivide.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Left division operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
]


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
 -- Operator: ]
     Return list delimiter.

     See also: [.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Return list delimiter.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
^


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 255
 -- Operator: ^
     Power operator.  This may return complex results for real inputs.
     Use 'realsqrt', 'cbrt', 'nthroot', or 'realroot' to obtain real
     results when possible.

     See also: power, **, .^, .**, realpow, realsqrt, cbrt, nthroot.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
Power operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
|


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 88
 -- Operator: |
     Element by element logical 'or' operator.

     See also: ||, or.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Element by element logical 'or' operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
||


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 101
 -- Operator: ||
     Logical 'or' (with short-circuit evaluation) operator.

     See also: |, or.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Logical 'or' (with short-circuit evaluation) operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
~


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
 -- Operator: ~
     Logical 'not' operator.

     See also: !, not.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Logical 'not' operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
~=


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
 -- Operator: ~=
     Logical 'not equals' operator.

     See also: !=, ne.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Logical 'not equals' operator.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
break


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 127
 -- Keyword: break
     Exit the innermost enclosing do, while or for loop.

     See also: do, while, for, parfor, continue.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Exit the innermost enclosing do, while or for loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
case


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 280
 -- Keyword: case VALUE
 -- Keyword: case {VALUE, ...}
     A case statement in a switch.  Octave cases are exclusive and do
     not fall-through as do C-language cases.  A switch statement must
     have at least one case.  See 'switch' for an example.

     See also: switch.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
A case statement in a switch.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
catch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 116
 -- Keyword: catch
 -- Keyword: catch VALUE
     Begin the cleanup part of a try-catch block.

     See also: try.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Begin the cleanup part of a try-catch block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
continue


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 141
 -- Keyword: continue
     Jump to the end of the innermost enclosing do, while or for loop.

     See also: do, while, for, parfor, break.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Jump to the end of the innermost enclosing do, while or for loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
do


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 249
 -- Keyword: do
     Begin a do-until loop.  This differs from a do-while loop in that
     the body of the loop is executed at least once.

          i = 0;
          do
            i++
          until (i == 10)

     See also: for, until, while.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
Begin a do-until loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
else


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 104
 -- Keyword: else
     Alternate action for an if block.  See 'if' for an example.

     See also: if.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Alternate action for an if block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
elseif


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 133
 -- Keyword: elseif (CONDITION)
     Alternate conditional test for an if block.  See 'if' for an
     example.

     See also: if.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Alternate conditional test for an if block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
end


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 296
 -- Built-in Function: end
     The magic index "end" refers to the last valid entry in an indexing
     operation.

     Example:

          X = [ 1 2 3
                4 5 6 ];
          X(1,end)
              => 3
          X(end,1)
              => 4
          X(end,end)
              => 6




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
The magic index "end" refers to the last valid entry in an indexing
operation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
end_try_catch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 99
 -- Keyword: end_try_catch
     Mark the end of an 'try-catch' block.

     See also: try, catch.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Mark the end of an 'try-catch' block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
end_unwind_protect


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 111
 -- Keyword: end_unwind_protect
     Mark the end of an unwind_protect block.

     See also: unwind_protect.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Mark the end of an unwind_protect block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
endfor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 102
 -- Keyword: endfor
     Mark the end of a for loop.  See 'for' for an example.

     See also: for.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Mark the end of a for loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
endfunction


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 85
 -- Keyword: endfunction
     Mark the end of a function.

     See also: function.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Mark the end of a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
endif


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 100
 -- Keyword: endif
     Mark the end of an if block.  See 'if' for an example.

     See also: if.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Mark the end of an if block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
endparfor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 114
 -- Keyword: endparfor
     Mark the end of a parfor loop.  See 'parfor' for an example.

     See also: parfor.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Mark the end of a parfor loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
endswitch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 115
 -- Keyword: endswitch
     Mark the end of a switch block.  See 'switch' for an example.

     See also: switch.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Mark the end of a switch block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
endwhile


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 114
 -- Keyword: endwhile
     Mark the end of a while loop.  See 'while' for an example.

     See also: do, while.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
Mark the end of a while loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
for


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 141
 -- Keyword: for I = RANGE
     Begin a for loop.

          for i = 1:10
            i
          endfor

     See also: do, parfor, while.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
Begin a for loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
function


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 246
 -- Keyword: function OUTPUTS = function (INPUT, ...)
 -- Keyword: function function (INPUT, ...)
 -- Keyword: function OUTPUTS = function
     Begin a function body with OUTPUTS as results and INPUTS as
     parameters.

     See also: return.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Begin a function body with OUTPUTS as results and INPUTS as parameters.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
global


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 181
 -- Keyword: global VAR
     Declare variables to have global scope.

          global X;
          if (isempty (X))
            x = 1;
          endif

     See also: persistent.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Declare variables to have global scope.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
if


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 421
 -- Keyword: if (COND) ... endif
 -- Keyword: if (COND) ... else ... endif
 -- Keyword: if (COND) ... elseif (COND) ... endif
 -- Keyword: if (COND) ... elseif (COND) ... else ... endif
     Begin an if block.

          x = 1;
          if (x == 1)
            disp ("one");
          elseif (x == 2)
            disp ("two");
          else
            disp ("not one or two");
          endif

     See also: switch.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
Begin an if block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
otherwise


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 132
 -- Keyword: otherwise
     The default statement in a switch block (similar to else in an if
     block).

     See also: switch.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
The default statement in a switch block (similar to else in an if
block).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
parfor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 217
 -- Keyword: parfor I = RANGE
 -- Keyword: parfor (I = RANGE, MAXPROC)
     Begin a for loop that may execute in parallel.

          parfor i = 1:10
            i
          endparfor

     See also: for, do, while.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Begin a for loop that may execute in parallel.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
persistent


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 432
 -- Keyword: persistent VAR
     Declare variables as persistent.  A variable that has been declared
     persistent within a function will retain its contents in memory
     between subsequent calls to the same function.  The difference
     between persistent variables and global variables is that
     persistent variables are local in scope to a particular function
     and are not visible elsewhere.

     See also: global.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Declare variables as persistent.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
return


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
 -- Keyword: return
     Return from a function.

     See also: function.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Return from a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
static


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 115
 -- Keyword: static
     This statement has been deprecated in favor of 'persistent'.

     See also: persistent.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
This statement has been deprecated in favor of 'persistent'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
switch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 362
 -- Keyword: switch STATEMENT
     Begin a switch block.

          yesno = "yes"

          switch yesno
            case {"Yes" "yes" "YES" "y" "Y"}
              value = 1;
            case {"No" "no" "NO" "n" "N"}
              value = 0;
            otherwise
              error ("invalid value");
          endswitch

     See also: if, case, otherwise.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
Begin a switch block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
try


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 339
 -- Keyword: try
     Begin a try-catch block.

     If an error occurs within a try block, then the catch code will be
     run and execution will proceed after the catch block (though it is
     often recommended to use the lasterr function to re-throw the error
     after cleanup is completed).

     See also: catch, unwind_protect.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Begin a try-catch block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
until


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 99
 -- Keyword: until (COND)
     End a do-until loop.  See 'do' for an example.

     See also: do.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
End a do-until loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
unwind_protect


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 498
 -- Keyword: unwind_protect
     Begin an unwind_protect block.

     If an error occurs within the first part of an unwind_protect block
     the commands within the unwind_protect_cleanup block are executed
     before the error is thrown.  If an error is not thrown, then the
     unwind_protect_cleanup block is still executed (in other words, the
     unwind_protect_cleanup will be run with or without an error in the
     unwind_protect block).

     See also: unwind_protect_cleanup, try.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Begin an unwind_protect block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
unwind_protect_cleanup


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 128
 -- Keyword: unwind_protect_cleanup
     Begin the cleanup section of an unwind_protect block.

     See also: unwind_protect.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Begin the cleanup section of an unwind_protect block.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
varargin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 148
 -- Keyword: varargin
     Pass an arbitrary number of arguments into a function.

     See also: varargout, nargin, isargout, nargout, nthargout.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Pass an arbitrary number of arguments into a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
varargout


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 150
 -- Keyword: varargout
     Pass an arbitrary number of arguments out of a function.

     See also: varargin, nargin, isargout, nargout, nthargout.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Pass an arbitrary number of arguments out of a function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
while


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 165
 -- Keyword: while
     Begin a while loop.

          i = 0;
          while (i < 10)
            i++
          endwhile

     See also: do, endwhile, for, until.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
Begin a while loop.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
EDITOR


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 672
 -- Built-in Function: VAL = EDITOR ()
 -- Built-in Function: OLD_VAL = EDITOR (NEW_VAL)
 -- Built-in Function: EDITOR (NEW_VAL, "local")
     Query or set the internal variable that specifies the default text
     editor.

     The default value is taken from the environment variable 'EDITOR'
     when Octave starts.  If the environment variable is not
     initialized, 'EDITOR' will be set to "emacs".

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: edit, edit_history.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Query or set the internal variable that specifies the default text
editor.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
EXEC_PATH


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 755
 -- Built-in Function: VAL = EXEC_PATH ()
 -- Built-in Function: OLD_VAL = EXEC_PATH (NEW_VAL)
 -- Built-in Function: EXEC_PATH (NEW_VAL, "local")
     Query or set the internal variable that specifies a colon separated
     list of directories to append to the shell PATH when executing
     external programs.  The initial value of is taken from the
     environment variable 'OCTAVE_EXEC_PATH', but that value can be
     overridden by the command line argument '--exec-path PATH'.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: IMAGE_PATH, OCTAVE_HOME.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that specifies a colon separated list
of dire



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
F_DUPFD


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 189
 -- Built-in Function: F_DUPFD ()
     Return the numerical value to pass to 'fcntl' to return a duplicate
     file descriptor.

     See also: fcntl, F_GETFD, F_GETFL, F_SETFD, F_SETFL.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the numerical value to pass to 'fcntl' to return a duplicate file
descrip



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
F_GETFD


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 187
 -- Built-in Function: F_GETFD ()
     Return the numerical value to pass to 'fcntl' to return the file
     descriptor flags.

     See also: fcntl, F_DUPFD, F_GETFL, F_SETFD, F_SETFL.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the numerical value to pass to 'fcntl' to return the file
descriptor flag



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
F_GETFL


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 183
 -- Built-in Function: F_GETFL ()
     Return the numerical value to pass to 'fcntl' to return the file
     status flags.

     See also: fcntl, F_DUPFD, F_GETFD, F_SETFD, F_SETFL.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
Return the numerical value to pass to 'fcntl' to return the file status
flags.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
F_SETFD


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 184
 -- Built-in Function: F_SETFD ()
     Return the numerical value to pass to 'fcntl' to set the file
     descriptor flags.

     See also: fcntl, F_DUPFD, F_GETFD, F_GETFL, F_SETFL.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
Return the numerical value to pass to 'fcntl' to set the file descriptor
flags.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
F_SETFL


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 180
 -- Built-in Function: F_SETFL ()
     Return the numerical value to pass to 'fcntl' to set the file
     status flags.

     See also: fcntl, F_DUPFD, F_GETFD, F_GETFL, F_SETFD.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Return the numerical value to pass to 'fcntl' to set the file status
flags.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
I


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 957
 -- Built-in Function: I
 -- Built-in Function: I (N)
 -- Built-in Function: I (N, M)
 -- Built-in Function: I (N, M, K, ...)
 -- Built-in Function: I (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are
     all equal to the pure imaginary unit, defined as 'sqrt (-1)'.

     I, and its equivalents i, j, and J, are functions so any of the
     names may be reused for other purposes (such as i for a counter
     variable).

     When called with no arguments, return a scalar with the value i.
     When called with a single argument, return a square matrix with the
     dimension specified.  When called with more than one scalar
     argument the first two arguments are taken as the number of rows
     and columns and any further arguments specify additional matrix
     dimensions.  The optional argument CLASS specifies the return type
     and may be either "double" or "single".

     See also: e, pi, log, exp.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a scalar, matrix, or N-dimensional array whose elements are all
equal to 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
IMAGE_PATH


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 553
 -- Built-in Function: VAL = IMAGE_PATH ()
 -- Built-in Function: OLD_VAL = IMAGE_PATH (NEW_VAL)
 -- Built-in Function: IMAGE_PATH (NEW_VAL, "local")
     Query or set the internal variable that specifies a colon separated
     list of directories in which to search for image files.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: EXEC_PATH, OCTAVE_HOME.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that specifies a colon separated list
of dire



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
Inf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1072
 -- Built-in Function: Inf
 -- Built-in Function: Inf (N)
 -- Built-in Function: Inf (N, M)
 -- Built-in Function: Inf (N, M, K, ...)
 -- Built-in Function: Inf (..., CLASS)
     Return a scalar, matrix or N-dimensional array whose elements are
     all equal to the IEEE representation for positive infinity.

     Infinity is produced when results are too large to be represented
     using the the IEEE floating point format for numbers.  Two common
     examples which produce infinity are division by zero and overflow.

          [ 1/0 e^800 ]
          => Inf   Inf

     When called with no arguments, return a scalar with the value
     'Inf'.  When called with a single argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The optional argument CLASS specifies the
     return type and may be either "double" or "single".

     See also: isinf, NaN.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a scalar, matrix or N-dimensional array whose elements are all
equal to t



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
J


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 957
 -- Built-in Function: I
 -- Built-in Function: I (N)
 -- Built-in Function: I (N, M)
 -- Built-in Function: I (N, M, K, ...)
 -- Built-in Function: I (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are
     all equal to the pure imaginary unit, defined as 'sqrt (-1)'.

     I, and its equivalents i, j, and J, are functions so any of the
     names may be reused for other purposes (such as i for a counter
     variable).

     When called with no arguments, return a scalar with the value i.
     When called with a single argument, return a square matrix with the
     dimension specified.  When called with more than one scalar
     argument the first two arguments are taken as the number of rows
     and columns and any further arguments specify additional matrix
     dimensions.  The optional argument CLASS specifies the return type
     and may be either "double" or "single".

     See also: e, pi, log, exp.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a scalar, matrix, or N-dimensional array whose elements are all
equal to 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
NA


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 917
 -- Built-in Function: NA
 -- Built-in Function: NA (N)
 -- Built-in Function: NA (N, M)
 -- Built-in Function: NA (N, M, K, ...)
 -- Built-in Function: NA (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are
     all equal to the special constant used to designate missing values.

     Note that NA always compares not equal to NA (NA != NA). To find NA
     values, use the 'isna' function.

     When called with no arguments, return a scalar with the value 'NA'.
     When called with a single argument, return a square matrix with the
     dimension specified.  When called with more than one scalar
     argument the first two arguments are taken as the number of rows
     and columns and any further arguments specify additional matrix
     dimensions.  The optional argument CLASS specifies the return type
     and may be either "double" or "single".

     See also: isna.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a scalar, matrix, or N-dimensional array whose elements are all
equal to 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
NaN


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1274
 -- Built-in Function: NaN
 -- Built-in Function: NaN (N)
 -- Built-in Function: NaN (N, M)
 -- Built-in Function: NaN (N, M, K, ...)
 -- Built-in Function: NaN (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are
     all equal to the IEEE symbol NaN (Not a Number).  NaN is the result
     of operations which do not produce a well defined numerical result.
     Common operations which produce a NaN are arithmetic with infinity
     (Inf - Inf), zero divided by zero (0/0), and any operation
     involving another NaN value (5 + NaN).

     Note that NaN always compares not equal to NaN (NaN != NaN). This
     behavior is specified by the IEEE standard for floating point
     arithmetic.  To find NaN values, use the 'isnan' function.

     When called with no arguments, return a scalar with the value
     'NaN'.  When called with a single argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The optional argument CLASS specifies the
     return type and may be either "double" or "single".

     See also: isnan, Inf.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a scalar, matrix, or N-dimensional array whose elements are all
equal to 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
OCTAVE_HOME


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 147
 -- Built-in Function: OCTAVE_HOME ()
     Return the name of the top-level Octave installation directory.

     See also: EXEC_PATH, IMAGE_PATH.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return the name of the top-level Octave installation directory.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
OCTAVE_VERSION


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 97
 -- Built-in Function: OCTAVE_VERSION ()
     Return the version number of Octave, as a string.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Return the version number of Octave, as a string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
O_APPEND


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 353
 -- Built-in Function: O_APPEND ()
     Return the numerical value of the file status flag that may be
     returned by 'fcntl' to indicate each write operation appends, or
     that may be passed to 'fcntl' to set the write mode to append.

     See also: fcntl, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY,
     O_RDWR, O_SYNC, O_TRUNC, O_WRONLY.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the numerical value of the file status flag that may be returned
by 'fcnt



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
O_ASYNC


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 270
 -- Built-in Function: O_ASYNC ()
     Return the numerical value of the file status flag that may be
     returned by 'fcntl' to indicate asynchronous I/O.

     See also: fcntl, O_APPEND, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY,
     O_RDWR, O_SYNC, O_TRUNC, O_WRONLY.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the numerical value of the file status flag that may be returned
by 'fcnt



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
O_CREAT


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 309
 -- Built-in Function: O_CREAT ()
     Return the numerical value of the file status flag that may be
     returned by 'fcntl' to indicate that a file should be created if it
     does not exist.

     See also: fcntl, O_APPEND, O_ASYNC, O_EXCL, O_NONBLOCK, O_RDONLY,
     O_RDWR, O_SYNC, O_TRUNC, O_WRONLY.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the numerical value of the file status flag that may be returned
by 'fcnt



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
O_EXCL


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 279
 -- Built-in Function: O_EXCL ()
     Return the numerical value of the file status flag that may be
     returned by 'fcntl' to indicate that file locking is used.

     See also: fcntl, O_APPEND, O_ASYNC, O_CREAT, O_NONBLOCK, O_RDONLY,
     O_RDWR, O_SYNC, O_TRUNC, O_WRONLY.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the numerical value of the file status flag that may be returned
by 'fcnt



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
O_NONBLOCK


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 349
 -- Built-in Function: O_NONBLOCK ()
     Return the numerical value of the file status flag that may be
     returned by 'fcntl' to indicate that non-blocking I/O is in use, or
     that may be passsed to 'fcntl' to set non-blocking I/O.

     See also: fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_RDONLY,
     O_RDWR, O_SYNC, O_TRUNC, O_WRONLY.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the numerical value of the file status flag that may be returned
by 'fcnt



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
O_RDONLY


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 295
 -- Built-in Function: O_RDONLY ()
     Return the numerical value of the file status flag that may be
     returned by 'fcntl' to indicate that a file is open for reading
     only.

     See also: fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK,
     O_RDWR, O_SYNC, O_TRUNC, O_WRONLY.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the numerical value of the file status flag that may be returned
by 'fcnt



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
O_RDWR


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 307
 -- Built-in Function: O_RDWR ()
     Return the numerical value of the file status flag that may be
     returned by 'fcntl' to indicate that a file is open for both
     reading and writing.

     See also: fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK,
     O_RDONLY, O_SYNC, O_TRUNC, O_WRONLY.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the numerical value of the file status flag that may be returned
by 'fcnt



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
O_SYNC


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 298
 -- Built-in Function: O_SYNC ()
     Return the numerical value of the file status flag that may be
     returned by 'fcntl' to indicate that a file is open for synchronous
     I/O.

     See also: fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK,
     O_RDONLY, O_RDWR, O_TRUNC, O_WRONLY.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the numerical value of the file status flag that may be returned
by 'fcnt



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
O_TRUNC


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 315
 -- Built-in Function: O_TRUNC ()
     Return the numerical value of the file status flag that may be
     returned by 'fcntl' to indicate that if file exists, it should be
     truncated when writing.

     See also: fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK,
     O_RDONLY, O_RDWR, O_SYNC, O_WRONLY.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the numerical value of the file status flag that may be returned
by 'fcnt



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
O_WRONLY


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 295
 -- Built-in Function: O_WRONLY ()
     Return the numerical value of the file status flag that may be
     returned by 'fcntl' to indicate that a file is open for writing
     only.

     See also: fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK,
     O_RDONLY, O_RDWR, O_SYNC, O_TRUNC.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the numerical value of the file status flag that may be returned
by 'fcnt



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
PAGER


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 717
 -- Built-in Function: VAL = PAGER ()
 -- Built-in Function: OLD_VAL = PAGER (NEW_VAL)
 -- Built-in Function: PAGER (NEW_VAL, "local")
     Query or set the internal variable that specifies the program to
     use to display terminal output on your system.  The default value
     is normally "less", "more", or "pg", depending on what programs are
     installed on your system.  *Note Installation::.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: PAGER_FLAGS, page_output_immediately, more,
     page_screen_output.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that specifies the program to use to
display 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
PAGER_FLAGS


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 550
 -- Built-in Function: VAL = PAGER_FLAGS ()
 -- Built-in Function: OLD_VAL = PAGER_FLAGS (NEW_VAL)
 -- Built-in Function: PAGER_FLAGS (NEW_VAL, "local")
     Query or set the internal variable that specifies the options to
     pass to the pager.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: PAGER, more, page_screen_output, page_output_immediately.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that specifies the options to pass to
the pag



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
PS1


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1189
 -- Built-in Function: VAL = PS1 ()
 -- Built-in Function: OLD_VAL = PS1 (NEW_VAL)
 -- Built-in Function: PS1 (NEW_VAL, "local")
     Query or set the primary prompt string.  When executing
     interactively, Octave displays the primary prompt when it is ready
     to read a command.

     The default value of the primary prompt string is "octave:\#> ".
     To change it, use a command like

          PS1 ("\\u@\\H> ")

     which will result in the prompt 'boris@kremvax> ' for the user
     'boris' logged in on the host 'kremvax.kgb.su'.  Note that two
     backslashes are required to enter a backslash into a double-quoted
     character string.  *Note Strings::.

     You can also use ANSI escape sequences if your terminal supports
     them.  This can be useful for coloring the prompt.  For example,

          PS1 ("\\[\\033[01;31m\\]\\s:\\#> \\[\\033[0m\\]")

     will give the default Octave prompt a red coloring.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: PS2, PS4.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Query or set the primary prompt string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
PS2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 770
 -- Built-in Function: VAL = PS2 ()
 -- Built-in Function: OLD_VAL = PS2 (NEW_VAL)
 -- Built-in Function: PS2 (NEW_VAL, "local")
     Query or set the secondary prompt string.  The secondary prompt is
     printed when Octave is expecting additional input to complete a
     command.  For example, if you are typing a 'for' loop that spans
     several lines, Octave will print the secondary prompt at the
     beginning of each line after the first.  The default value of the
     secondary prompt string is "> ".

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: PS1, PS4.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Query or set the secondary prompt string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
PS4


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 634
 -- Built-in Function: VAL = PS4 ()
 -- Built-in Function: OLD_VAL = PS4 (NEW_VAL)
 -- Built-in Function: PS4 (NEW_VAL, "local")
     Query or set the character string used to prefix output produced
     when echoing commands is enabled.  The default value is "+ ".
     *Note Diary and Echo Commands::, for a description of echoing
     commands.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: echo, echo_executing_commands, PS1, PS2.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the character string used to prefix output produced when
echoing co



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
P_tmpdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 172
 -- Built-in Function: P_tmpdir ()
     Return the default name of the directory for temporary files on
     this system.  The name of this directory is system dependent.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Return the default name of the directory for temporary files on this
system.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
SEEK_CUR


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 191
 -- Built-in Function: SEEK_CUR ()
     Return the numerical value to pass to 'fseek' to position the file
     pointer relative to the current position.

     See also: SEEK_SET, SEEK_END.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the numerical value to pass to 'fseek' to position the file
pointer relat



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
SEEK_END


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 190
 -- Built-in Function: SEEK_END ()
     Return the numerical value to pass to 'fseek' to position the file
     pointer relative to the end of the file.

     See also: SEEK_SET, SEEK_CUR.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the numerical value to pass to 'fseek' to position the file
pointer relat



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
SEEK_SET


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 431
 -- Built-in Function: SEEK_SET ()
 -- Built-in Function: SEEK_CUR ()
 -- Built-in Function: SEEK_END ()
     Return the numerical value to pass to 'fseek' to perform one of the
     following actions:

     'SEEK_SET'
          Position file relative to the beginning.

     'SEEK_CUR'
          Position file relative to the current position.

     'SEEK_END'
          Position file relative to the end.

     See also: fseek.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the numerical value to pass to 'fseek' to perform one of the
following ac



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
SIG


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 115
 -- Built-in Function: SIG ()
     Return a structure containing Unix signal names and their defined
     values.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Return a structure containing Unix signal names and their defined
values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
S_ISBLK


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 197
 -- Built-in Function: S_ISBLK (MODE)
     Return true if MODE corresponds to a block device.

     The value of MODE is assumed to be returned from a call to 'stat'.

     See also: stat, lstat.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Return true if MODE corresponds to a block device.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
S_ISCHR


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 201
 -- Built-in Function: S_ISCHR (MODE)
     Return true if MODE corresponds to a character device.

     The value of MODE is assumed to be returned from a call to 'stat'.

     See also: stat, lstat.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Return true if MODE corresponds to a character device.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
S_ISDIR


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 194
 -- Built-in Function: S_ISDIR (MODE)
     Return true if MODE corresponds to a directory.

     The value of MODE is assumed to be returned from a call to 'stat'.

     See also: stat, lstat.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Return true if MODE corresponds to a directory.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
S_ISFIFO


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 190
 -- Built-in Function: S_ISFIFO (MODE)
     Return true if MODE corresponds to a fifo.

     The value of MODE is assumed to be returned from a call to 'stat'.

     See also: stat, lstat.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Return true if MODE corresponds to a fifo.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
S_ISLNK


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 198
 -- Built-in Function: S_ISLNK (MODE)
     Return true if MODE corresponds to a symbolic link.

     The value of MODE is assumed to be returned from a call to 'stat'.

     See also: stat, lstat.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Return true if MODE corresponds to a symbolic link.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
S_ISREG


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 197
 -- Built-in Function: S_ISREG (MODE)
     Return true if MODE corresponds to a regular file.

     The value of MODE is assumed to be returned from a call to 'stat'.

     See also: stat, lstat.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Return true if MODE corresponds to a regular file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
S_ISSOCK


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 192
 -- Built-in Function: S_ISSOCK (MODE)
     Return true if MODE corresponds to a socket.

     The value of MODE is assumed to be returned from a call to 'stat'.

     See also: stat, lstat.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return true if MODE corresponds to a socket.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
WCONTINUE


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 289
 -- Built-in Function: WCONTINUE ()
     Return the numerical value of the option argument that may be
     passed to 'waitpid' to indicate that it should also return if a
     stopped child has been resumed by delivery of a 'SIGCONT' signal.

     See also: waitpid, WNOHANG, WUNTRACED.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the numerical value of the option argument that may be passed to
'waitpid



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
WCOREDUMP


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 484
 -- Built-in Function: WCOREDUMP (STATUS)
     Given STATUS from a call to 'waitpid', return true if the child
     produced a core dump.  This function should only be employed if
     'WIFSIGNALED' returned true.  The macro used to implement this
     function is not specified in POSIX.1-2001 and is not available on
     some Unix implementations (e.g., AIX, SunOS).

     See also: waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG,
     WIFSTOPPED, WSTOPSIG, WIFCONTINUED.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Given STATUS from a call to 'waitpid', return true if the child produced
a core 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
WEXITSTATUS


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 316
 -- Built-in Function: WEXITSTATUS (STATUS)
     Given STATUS from a call to 'waitpid', return the exit status of
     the child.  This function should only be employed if 'WIFEXITED'
     returned true.

     See also: waitpid, WIFEXITED, WIFSIGNALED, WTERMSIG, WCOREDUMP,
     WIFSTOPPED, WSTOPSIG, WIFCONTINUED.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Given STATUS from a call to 'waitpid', return the exit status of the
child.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
WIFCONTINUED


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 276
 -- Built-in Function: WIFCONTINUED (STATUS)
     Given STATUS from a call to 'waitpid', return true if the child
     process was resumed by delivery of 'SIGCONT'.

     See also: waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG,
     WCOREDUMP, WIFSTOPPED, WSTOPSIG.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Given STATUS from a call to 'waitpid', return true if the child process
was resu



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
WIFEXITED


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 251
 -- Built-in Function: WIFEXITED (STATUS)
     Given STATUS from a call to 'waitpid', return true if the child
     terminated normally.

     See also: waitpid, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WCOREDUMP,
     WIFSTOPPED, WSTOPSIG, WIFCONTINUED.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Given STATUS from a call to 'waitpid', return true if the child
terminated norma



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
WIFSIGNALED


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 266
 -- Built-in Function: WIFSIGNALED (STATUS)
     Given STATUS from a call to 'waitpid', return true if the child
     process was terminated by a signal.

     See also: waitpid, WIFEXITED, WEXITSTATUS, WTERMSIG, WCOREDUMP,
     WIFSTOPPED, WSTOPSIG, WIFCONTINUED.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Given STATUS from a call to 'waitpid', return true if the child process
was term



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
WIFSTOPPED


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 397
 -- Built-in Function: WIFSTOPPED (STATUS)
     Given STATUS from a call to 'waitpid', return true if the child
     process was stopped by delivery of a signal; this is only possible
     if the call was done using 'WUNTRACED' or when the child is being
     traced (see ptrace(2)).

     See also: waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG,
     WCOREDUMP, WSTOPSIG, WIFCONTINUED.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Given STATUS from a call to 'waitpid', return true if the child process
was stop



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
WNOHANG


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 278
 -- Built-in Function: WNOHANG ()
     Return the numerical value of the option argument that may be
     passed to 'waitpid' to indicate that it should return its status
     immediately instead of waiting for a process to exit.

     See also: waitpid, WUNTRACED, WCONTINUE.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the numerical value of the option argument that may be passed to
'waitpid



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
WSTOPSIG


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 344
 -- Built-in Function: WSTOPSIG (STATUS)
     Given STATUS from a call to 'waitpid', return the number of the
     signal which caused the child to stop.  This function should only
     be employed if 'WIFSTOPPED' returned true.

     See also: waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG,
     WCOREDUMP, WIFSTOPPED, WIFCONTINUED.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Given STATUS from a call to 'waitpid', return the number of the signal
which cau



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
WTERMSIG


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 357
 -- Built-in Function: WTERMSIG (STATUS)
     Given STATUS from a call to 'waitpid', return the number of the
     signal that caused the child process to terminate.  This function
     should only be employed if 'WIFSIGNALED' returned true.

     See also: waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WCOREDUMP,
     WIFSTOPPED, WSTOPSIG, WIFCONTINUED.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Given STATUS from a call to 'waitpid', return the number of the signal
that caus



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
WUNTRACED


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 303
 -- Built-in Function: WUNTRACED ()
     Return the numerical value of the option argument that may be
     passed to 'waitpid' to indicate that it should also return if the
     child process has stopped but is not traced via the 'ptrace' system
     call

     See also: waitpid, WNOHANG, WCONTINUE.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the numerical value of the option argument that may be passed to
'waitpid



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
abs


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 164
 -- Mapping Function: abs (Z)
     Compute the magnitude of Z, defined as |Z| = 'sqrt (x^2 + y^2)'.

     For example:

          abs (3 + 4i)
               => 5




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Compute the magnitude of Z, defined as |Z| = 'sqrt (x^2 + y^2)'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
acos


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 126
 -- Mapping Function: acos (X)
     Compute the inverse cosine in radians for each element of X.

     See also: cos, acosd.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Compute the inverse cosine in radians for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
acosh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 121
 -- Mapping Function: acosh (X)
     Compute the inverse hyperbolic cosine for each element of X.

     See also: cosh.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Compute the inverse hyperbolic cosine for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
add_input_event_hook


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 551
 -- Built-in Function: ID = add_input_event_hook (FCN)
 -- Built-in Function: ID = add_input_event_hook (FCN, DATA)
     Add the named function or function handle FCN to the list of
     functions to call periodically when Octave is waiting for input.
     The function should have the form

          FCN (DATA)

     If DATA is omitted, Octave calls the function without any
     arguments.

     The returned identifier may be used to remove the function handle
     from the list of input hook functions.

     See also: remove_input_event_hook.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Add the named function or function handle FCN to the list of functions
to call p



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
addlistener


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1176
 -- Built-in Function: addlistener (H, PROP, FCN)
     Register FCN as listener for the property PROP of the graphics
     object H.  Property listeners are executed (in order of
     registration) when the property is set.  The new value is already
     available when the listeners are executed.

     PROP must be a string naming a valid property in H.

     FCN can be a function handle, a string or a cell array whose first
     element is a function handle.  If FCN is a function handle, the
     corresponding function should accept at least 2 arguments, that
     will be set to the object handle and the empty matrix respectively.
     If FCN is a string, it must be any valid octave expression.  If FCN
     is a cell array, the first element must be a function handle with
     the same signature as described above.  The next elements of the
     cell array are passed as additional arguments to the function.

     Example:

          function my_listener (h, dummy, p1)
            fprintf ("my_listener called with p1=%s\n", p1);
          endfunction

          addlistener (gcf, "position", {@my_listener, "my string"})

     See also: addproperty, hggroup.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Register FCN as listener for the property PROP of the graphics object H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
addpath


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 636
 -- Built-in Function: addpath (DIR1, ...)
 -- Built-in Function: addpath (DIR1, ..., OPTION)
     Add named directories to the function search path.  If OPTION is
     "-begin" or 0 (the default), prepend the directory name to the
     current path.  If OPTION is "-end" or 1, append the directory name
     to the current path.  Directories added to the path must exist.

     In addition to accepting individual directory arguments, lists of
     directory names separated by 'pathsep' are also accepted.  For
     example:

          addpath ("dir1:/dir2:~/dir3")

     See also: path, rmpath, genpath, pathdef, savepath, pathsep.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Add named directories to the function search path.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
addproperty


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2631
 -- Built-in Function: addproperty (NAME, H, TYPE)
 -- Built-in Function: addproperty (NAME, H, TYPE, ARG, ...)
     Create a new property named NAME in graphics object H.  TYPE
     determines the type of the property to create.  ARGS usually
     contains the default value of the property, but additional
     arguments might be given, depending on the type of the property.

     The supported property types are:

     'string'
          A string property.  ARG contains the default string value.

     'any'
          An un-typed property.  This kind of property can hold any
          octave value.  ARGS contains the default value.

     'radio'
          A string property with a limited set of accepted values.  The
          first argument must be a string with all accepted values
          separated by a vertical bar ('|').  The default value can be
          marked by enclosing it with a '{' '}' pair.  The default value
          may also be given as an optional second string argument.

     'boolean'
          A boolean property.  This property type is equivalent to a
          radio property with "on|off" as accepted values.  ARG contains
          the default property value.

     'double'
          A scalar double property.  ARG contains the default value.

     'handle'
          A handle property.  This kind of property holds the handle of
          a graphics object.  ARG contains the default handle value.
          When no default value is given, the property is initialized to
          the empty matrix.

     'data'
          A data (matrix) property.  ARG contains the default data
          value.  When no default value is given, the data is
          initialized to the empty matrix.

     'color'
          A color property.  ARG contains the default color value.  When
          no default color is given, the property is set to black.  An
          optional second string argument may be given to specify an
          additional set of accepted string values (like a radio
          property).

     TYPE may also be the concatenation of a core object type and a
     valid property name for that object type.  The property created
     then has the same characteristics as the referenced property (type,
     possible values, hidden state...).  This allows to clone an
     existing property into the graphics object H.

     Examples:

          addproperty ("my_property", gcf, "string", "a string value");
          addproperty ("my_radio", gcf, "radio", "val_1|val_2|{val_3}");
          addproperty ("my_style", gcf, "linelinestyle", "--");

     See also: addlistener, hggroup.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Create a new property named NAME in graphics object H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
airy


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1120
 -- Built-in Function: [A, IERR] = airy (K, Z, OPT)
     Compute Airy functions of the first and second kind, and their
     derivatives.

           K   Function   Scale factor (if "opt" is supplied)
          ---  --------   ---------------------------------------
           0   Ai (Z)     exp ((2/3) * Z * sqrt (Z))
           1   dAi(Z)/dZ  exp ((2/3) * Z * sqrt (Z))
           2   Bi (Z)     exp (-abs (real ((2/3) * Z * sqrt (Z))))
           3   dBi(Z)/dZ  exp (-abs (real ((2/3) * Z * sqrt (Z))))

     The function call 'airy (Z)' is equivalent to 'airy (0, Z)'.

     The result is the same size as Z.

     If requested, IERR contains the following status information and is
     the same size as the result.

       0. Normal return.

       1. Input error, return 'NaN'.

       2. Overflow, return 'Inf'.

       3. Loss of significance by argument reduction results in less
          than half of machine accuracy.

       4. Complete loss of significance by argument reduction, return
          'NaN'.

       5. Error--no computation, algorithm termination condition not
          met, return 'NaN'.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Compute Airy functions of the first and second kind, and their
derivatives.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
all


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 533
 -- Built-in Function: all (X)
 -- Built-in Function: all (X, DIM)
     For a vector argument, return true (logical 1) if all elements of
     the vector are non-zero.

     For a matrix argument, return a row vector of logical ones and
     zeros with each element indicating whether all of the elements of
     the corresponding column of the matrix are non-zero.  For example:

          all ([2, 3; 1, 0]))
              => [ 1, 0 ]

     If the optional argument DIM is supplied, work along dimension DIM.

     See also: any.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
For a vector argument, return true (logical 1) if all elements of the
vector are



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
allow_noninteger_range_as_index


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 758
 -- Built-in Function: VAL = allow_noninteger_range_as_index ()
 -- Built-in Function: OLD_VAL = allow_noninteger_range_as_index
          (NEW_VAL)
 -- Built-in Function: allow_noninteger_range_as_index (NEW_VAL,
          "local")
     Query or set the internal variable that controls whether
     non-integer ranges are allowed as indices.  This might be useful
     for MATLAB compatibility; however, it is still not entirely
     compatible because MATLAB treats the range expression differently
     in different contexts.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that controls whether non-integer
ranges are 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
and


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 367
 -- Built-in Function: and (X, Y)
 -- Built-in Function: and (X1, X2, ...)
     Return the logical AND of X and Y.  This function is equivalent to
     'x & y'.  If more arguments are given, the logical and is applied
     cumulatively from left to right:

          (...((x1 & x2) & x3) & ...)

     At least one argument is required.

     See also: or, not, xor.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Return the logical AND of X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
angle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
 -- Mapping Function: angle (Z)
     See arg.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
See arg.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
any


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 603
 -- Built-in Function: any (X)
 -- Built-in Function: any (X, DIM)
     For a vector argument, return true (logical 1) if any element of
     the vector is non-zero.

     For a matrix argument, return a row vector of logical ones and
     zeros with each element indicating whether any of the elements of
     the corresponding column of the matrix are non-zero.  For example:

          any (eye (2, 4))
           => [ 1, 1, 0, 0 ]

     If the optional argument DIM is supplied, work along dimension DIM.
     For example:

          any (eye (2, 4), 2)
           => [ 1; 1 ]

     See also: all.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
For a vector argument, return true (logical 1) if any element of the
vector is n



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
arg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 217
 -- Mapping Function: arg (Z)
 -- Mapping Function: angle (Z)
     Compute the argument of Z, defined as, THETA = 'atan2 (Y, X)', in
     radians.

     For example:

          arg (3 + 4i)
               => 0.92730




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Compute the argument of Z, defined as, THETA = 'atan2 (Y, X)', in
radians.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
argnames


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 200
 -- Built-in Function: argnames (FUN)
     Return a cell array of character strings containing the names of
     the arguments of the inline function FUN.

     See also: inline, formula, vectorize.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a cell array of character strings containing the names of the
arguments o



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
argv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 526
 -- Built-in Function: argv ()
     Return the command line arguments passed to Octave.  For example,
     if you invoked Octave using the command

          octave --no-line-editing --silent

     'argv' would return a cell array of strings with the elements
     '--no-line-editing' and '--silent'.

     If you write an executable Octave script, 'argv' will return the
     list of arguments passed to the script.  *Note Executable Octave
     Programs::, for an example of how to create an executable Octave
     script.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Return the command line arguments passed to Octave.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
arrayfun


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3476
 -- Function File: arrayfun (FUNC, A)
 -- Function File: X = arrayfun (FUNC, A)
 -- Function File: X = arrayfun (FUNC, A, B, ...)
 -- Function File: [X, Y, ...] = arrayfun (FUNC, A, ...)
 -- Function File: arrayfun (..., "UniformOutput", VAL)
 -- Function File: arrayfun (..., "ErrorHandler", ERRFUNC)

     Execute a function on each element of an array.  This is useful for
     functions that do not accept array arguments.  If the function does
     accept array arguments it is better to call the function directly.

     The first input argument FUNC can be a string, a function handle,
     an inline function, or an anonymous function.  The input argument A
     can be a logic array, a numeric array, a string array, a structure
     array, or a cell array.  By a call of the function 'arrayfun' all
     elements of A are passed on to the named function FUNC
     individually.

     The named function can also take more than two input arguments,
     with the input arguments given as third input argument B, fourth
     input argument C, ... If given more than one array input argument
     then all input arguments must have the same sizes, for example:

          arrayfun (@atan2, [1, 0], [0, 1])
               => [ 1.5708   0.0000 ]

     If the parameter VAL after a further string input argument
     "UniformOutput" is set 'true' (the default), then the named
     function FUNC must return a single element which then will be
     concatenated into the return value and is of type matrix.
     Otherwise, if that parameter is set to 'false', then the outputs
     are concatenated in a cell array.  For example:

          arrayfun (@(x,y) x:y, "abc", "def", "UniformOutput", false)
          =>
             {
               [1,1] = abcd
               [1,2] = bcde
               [1,3] = cdef
             }

     If more than one output arguments are given then the named function
     must return the number of return values that also are expected, for
     example:

          [A, B, C] = arrayfun (@find, [10; 0], "UniformOutput", false)
          =>
          A =
          {
             [1,1] =  1
             [2,1] = [](0x0)
          }
          B =
          {
             [1,1] =  1
             [2,1] = [](0x0)
          }
          C =
          {
             [1,1] =  10
             [2,1] = [](0x0)
          }

     If the parameter ERRFUNC after a further string input argument
     "ErrorHandler" is another string, a function handle, an inline
     function, or an anonymous function, then ERRFUNC defines a function
     to call in the case that FUNC generates an error.  The definition
     of the function must be of the form

          function [...] = errfunc (S, ...)

     where there is an additional input argument to ERRFUNC relative to
     FUNC, given by S.  This is a structure with the elements
     "identifier", "message", and "index" giving, respectively, the
     error identifier, the error message, and the index of the array
     elements that caused the error.  The size of the output argument of
     ERRFUNC must have the same size as the output argument of FUNC,
     otherwise a real error is thrown.  For example:

          function y = ferr (s, x), y = "MyString"; endfunction
          arrayfun (@str2num, [1234],
                    "UniformOutput", false, "ErrorHandler", @ferr)
          =>
             {
               [1,1] = MyString
             }

     See also: spfun, cellfun, structfun.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Execute a function on each element of an array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
asin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 124
 -- Mapping Function: asin (X)
     Compute the inverse sine in radians for each element of X.

     See also: sin, asind.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Compute the inverse sine in radians for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
asinh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 119
 -- Mapping Function: asinh (X)
     Compute the inverse hyperbolic sine for each element of X.

     See also: sinh.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Compute the inverse hyperbolic sine for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
assignin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 177
 -- Built-in Function: assignin (CONTEXT, VARNAME, VALUE)
     Assign VALUE to VARNAME in context CONTEXT, which may be either
     "base" or "caller".

     See also: evalin.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Assign VALUE to VARNAME in context CONTEXT, which may be either "base"
or "calle



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
atan


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 127
 -- Mapping Function: atan (X)
     Compute the inverse tangent in radians for each element of X.

     See also: tan, atand.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Compute the inverse tangent in radians for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
atan2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 212
 -- Mapping Function: atan2 (Y, X)
     Compute atan (Y / X) for corresponding elements of Y and X.  Signal
     an error if Y and X do not match in size and orientation.

     See also: tan, tand, tanh, atanh.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Compute atan (Y / X) for corresponding elements of Y and X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
atanh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 122
 -- Mapping Function: atanh (X)
     Compute the inverse hyperbolic tangent for each element of X.

     See also: tanh.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Compute the inverse hyperbolic tangent for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
atexit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 997
 -- Built-in Function: atexit (FCN)
 -- Built-in Function: atexit (FCN, FLAG)
     Register a function to be called when Octave exits.  For example,

          function last_words ()
            disp ("Bye bye");
          endfunction
          atexit ("last_words");

     will print the message "Bye bye" when Octave exits.

     The additional argument FLAG will register or unregister FCN from
     the list of functions to be called when Octave exits.  If FLAG is
     true, the function is registered, and if FLAG is false, it is
     unregistered.  For example, after registering the function
     'last_words' above,

          atexit ("last_words", false);

     will remove the function from the list and Octave will not call
     'last_words' when it exits.

     Note that 'atexit' only removes the first occurrence of a function
     from the list, so if a function was placed in the list multiple
     times with 'atexit', it must also be removed from the list multiple
     times.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Register a function to be called when Octave exits.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
autoload


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1254
 -- Built-in Function: AUTOLOAD_MAP = autoload ()
 -- Built-in Function: autoload (FUNCTION, FILE)
 -- Built-in Function: autoload (..., "remove")
     Define FUNCTION to autoload from FILE.

     The second argument, FILE, should be an absolute file name or a
     file name in the same directory as the function or script from
     which the autoload command was run.  FILE _should not_ depend on
     the Octave load path.

     Normally, calls to 'autoload' appear in PKG_ADD script files that
     are evaluated when a directory is added to Octave's load path.  To
     avoid having to hardcode directory names in FILE, if FILE is in the
     same directory as the PKG_ADD script then

          autoload ("foo", "bar.oct");

     will load the function 'foo' from the file 'bar.oct'.  The above
     usage when 'bar.oct' is not in the same directory, or usages such
     as

          autoload ("foo", file_in_loadpath ("bar.oct"))

     are strongly discouraged, as their behavior may be unpredictable.

     With no arguments, return a structure containing the current
     autoload map.

     If a third argument "remove" is given, the function is cleared and
     not loaded anymore during the current Octave session.

     See also: PKG_ADD.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Define FUNCTION to autoload from FILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
available_graphics_toolkits


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 174
 -- Built-in Function: available_graphics_toolkits ()
     Return a cell array of registered graphics toolkits.

     See also: graphics_toolkit, register_graphics_toolkit.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Return a cell array of registered graphics toolkits.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
balance


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1486
 -- Built-in Function: AA = balance (A)
 -- Built-in Function: AA = balance (A, OPT)
 -- Built-in Function: [DD, AA] = balance (A, OPT)
 -- Built-in Function: [D, P, AA] = balance (A, OPT)
 -- Built-in Function: [CC, DD, AA, BB] = balance (A, B, OPT)

     Compute 'AA = DD \ A * DD' in which AA is a matrix whose row and
     column norms are roughly equal in magnitude, and 'DD = P * D', in
     which P is a permutation matrix and D is a diagonal matrix of
     powers of two.  This allows the equilibration to be computed
     without round-off.  Results of eigenvalue calculation are typically
     improved by balancing first.

     If two output values are requested, 'balance' returns the diagonal
     D and the permutation P separately as vectors.  In this case, 'DD =
     eye(n)(:,P) * diag (D)', where n is the matrix size.

     If four output values are requested, compute 'AA = CC*A*DD' and 'BB
     = CC*B*DD', in which AA and BB have non-zero elements of
     approximately the same magnitude and CC and DD are permuted
     diagonal matrices as in DD for the algebraic eigenvalue problem.

     The eigenvalue balancing option OPT may be one of:

     "noperm", "S"
          Scale only; do not permute.

     "noscal", "P"
          Permute only; do not scale.

     Algebraic eigenvalue balancing uses standard LAPACK routines.

     Generalized eigenvalue problem balancing uses Ward's algorithm
     (SIAM Journal on Scientific and Statistical Computing, 1981).




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute 'AA = DD \ A * DD' in which AA is a matrix whose row and column
norms ar



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
base64_decode


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 315
 -- Built-in Function: X = base64_decode (S)
 -- Built-in Function: X = base64_decode (S, DIMS)
     Decode the double matrix or array X from the base64 encoded string
     S.  The optional input parameter DIMS should be a vector containing
     the dimensions of the decoded array.

     See also: base64_encode.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Decode the double matrix or array X from the base64 encoded string S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
base64_encode


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 149
 -- Built-in Function: S = base64_encode (X)
     Encode a double matrix or array X into the base64 format string S.

     See also: base64_decode.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Encode a double matrix or array X into the base64 format string S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
beep_on_error


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 536
 -- Built-in Function: VAL = beep_on_error ()
 -- Built-in Function: OLD_VAL = beep_on_error (NEW_VAL)
 -- Built-in Function: beep_on_error (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave
     will try to ring the terminal bell before printing an error
     message.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that controls whether Octave will try
to ring



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
besselh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 81
 -- Built-in Function: [H, IERR] = besselh (ALPHA, K, X, OPT)
     See besselj.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
See besselj.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
besseli


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
 -- Built-in Function: [I, IERR] = besseli (ALPHA, X, OPT)
     See besselj.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
See besselj.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
besselj


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2156
 -- Built-in Function: [J, IERR] = besselj (ALPHA, X, OPT)
 -- Built-in Function: [Y, IERR] = bessely (ALPHA, X, OPT)
 -- Built-in Function: [I, IERR] = besseli (ALPHA, X, OPT)
 -- Built-in Function: [K, IERR] = besselk (ALPHA, X, OPT)
 -- Built-in Function: [H, IERR] = besselh (ALPHA, K, X, OPT)
     Compute Bessel or Hankel functions of various kinds:

     'besselj'
          Bessel functions of the first kind.  If the argument OPT is
          supplied, the result is multiplied by 'exp (-abs (imag (X)))'.

     'bessely'
          Bessel functions of the second kind.  If the argument OPT is
          supplied, the result is multiplied by 'exp (-abs (imag (X)))'.

     'besseli'

          Modified Bessel functions of the first kind.  If the argument
          OPT is supplied, the result is multiplied by 'exp (-abs (real
          (X)))'.

     'besselk'

          Modified Bessel functions of the second kind.  If the argument
          OPT is supplied, the result is multiplied by 'exp (X)'.

     'besselh'
          Compute Hankel functions of the first (K = 1) or second (K =
          2) kind.  If the argument OPT is supplied, the result is
          multiplied by 'exp (-I*X)' for K = 1 or 'exp (I*X)' for K = 2.

     If ALPHA is a scalar, the result is the same size as X.  If X is a
     scalar, the result is the same size as ALPHA.  If ALPHA is a row
     vector and X is a column vector, the result is a matrix with
     'length (X)' rows and 'length (ALPHA)' columns.  Otherwise, ALPHA
     and X must conform and the result will be the same size.

     The value of ALPHA must be real.  The value of X may be complex.

     If requested, IERR contains the following status information and is
     the same size as the result.

       0. Normal return.

       1. Input error, return 'NaN'.

       2. Overflow, return 'Inf'.

       3. Loss of significance by argument reduction results in less
          than half of machine accuracy.

       4. Complete loss of significance by argument reduction, return
          'NaN'.

       5. Error--no computation, algorithm termination condition not
          met, return 'NaN'.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Compute Bessel or Hankel functions of various kinds:



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
besselk


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
 -- Built-in Function: [K, IERR] = besselk (ALPHA, X, OPT)
     See besselj.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
See besselj.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
bessely


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
 -- Built-in Function: [Y, IERR] = bessely (ALPHA, X, OPT)
     See besselj.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
See besselj.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
betainc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 528
 -- Mapping Function: betainc (X, A, B)
     Return the regularized incomplete Beta function,

                                             x
                                    1       /
          betainc (x, a, b) = -----------   | t^(a-1) (1-t)^(b-1) dt.
                              beta (a, b)   /
                                         t=0

     If X has more than one component, both A and B must be scalars.  If
     X is a scalar, A and B must be of compatible dimensions.

     See also: betaincinv, beta, betaln.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Return the regularized incomplete Beta function,



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
betaincinv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 198
 -- Mapping Function: betaincinv (Y, A, B)
     Compute the inverse of the incomplete Beta function, i.e., X such
     that

          Y == betainc (X, A, B)

     See also: betainc, beta, betaln.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Compute the inverse of the incomplete Beta function, i.e., X such that



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
bitand


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 208
 -- Built-in Function: bitand (X, Y)
     Return the bitwise AND of non-negative integers.  X, Y must be in
     the range [0,bitmax]

     See also: bitor, bitxor, bitset, bitget, bitcmp, bitshift, bitmax.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Return the bitwise AND of non-negative integers.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
bitmax


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 431
 -- Built-in Function: bitmax ()
 -- Built-in Function: bitmax ("double")
 -- Built-in Function: bitmax ("single")
     Return the largest integer that can be represented within a
     floating point value.  The default class is "double", but "single"
     is a valid option.  On IEEE-754 compatible systems, 'bitmax' is 2^{53} - 1
     for "double" and 2^{24} -1 for "single".

     See also: flintmax, intmax, realmax, realmin.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the largest integer that can be represented within a floating
point value



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
bitor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 206
 -- Built-in Function: bitor (X, Y)
     Return the bitwise OR of non-negative integers.  X, Y must be in
     the range [0,bitmax]

     See also: bitor, bitxor, bitset, bitget, bitcmp, bitshift, bitmax.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Return the bitwise OR of non-negative integers.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
bitpack


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 790
 -- Built-in Function: Y = bitpack (X, CLASS)
     Return a new array Y resulting from interpreting an array X as raw
     bit patterns for data of the numeric class CLASS.  CLASS must be
     one of the built-in numeric classes:

          "char"
          "int8"
          "int16"
          "int32"
          "int64"
          "uint8"
          "uint16"
          "uint32"
          "uint64"
          "double"
          "single"

     The number of elements of X should be divisible by the bit length
     of CLASS.  If it is not, excess bits are discarded.  Bits come in
     increasing order of significance, i.e., 'x(1)' is bit 0, 'x(2)' is
     bit 1, etc.  The result is a row vector if X is a row vector,
     otherwise it is a column vector.

     See also: bitunpack, typecast.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a new array Y resulting from interpreting an array X as raw bit
patterns 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
bitshift


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 577
 -- Built-in Function: bitshift (A, K)
 -- Built-in Function: bitshift (A, K, N)
     Return a K bit shift of N-digit unsigned integers in A.  A positive
     K leads to a left shift; A negative value to a right shift.  If N
     is omitted it defaults to log2(bitmax)+1.  N must be in the range
     [1,log2(bitmax)+1] usually [1,33].

          bitshift (eye (3), 1)
          =>
          2 0 0
          0 2 0
          0 0 2

          bitshift (10, [-2, -1, 0, 1, 2])
          => 2   5  10  20  40

     See also: bitand, bitor, bitxor, bitset, bitget, bitcmp, bitmax.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Return a K bit shift of N-digit unsigned integers in A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
bitunpack


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 500
 -- Built-in Function: Y = bitunpack (X)
     Return an array Y corresponding to the raw bit patterns of X.  X
     must belong to one of the built-in numeric classes:

          "char"
          "int8"
          "int16"
          "int32"
          "int64"
          "uint8"
          "uint16"
          "uint32"
          "uint64"
          "double"
          "single"

     The result is a row vector if X is a row vector; otherwise, it is a
     column vector.

     See also: bitpack, typecast.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Return an array Y corresponding to the raw bit patterns of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
bitxor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 208
 -- Built-in Function: bitxor (X, Y)
     Return the bitwise XOR of non-negative integers.  X, Y must be in
     the range [0,bitmax]

     See also: bitand, bitor, bitset, bitget, bitcmp, bitshift, bitmax.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Return the bitwise XOR of non-negative integers.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
blkmm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 414
 -- Built-in Function: blkmm (A, B)
     Compute products of matrix blocks.  The blocks are given as
     2-dimensional subarrays of the arrays A, B.  The size of A must
     have the form '[m,k,...]' and size of B must be '[k,n,...]'.  The
     result is then of size '[m,n,...]' and is computed as follows:

          for i = 1:prod (size (A)(3:end))
            C(:,:,i) = A(:,:,i) * B(:,:,i)
          endfor




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Compute products of matrix blocks.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
bsxfun


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 756
 -- Built-in Function: bsxfun (F, A, B)
     The binary singleton expansion function applier performs
     broadcasting, that is, applies a binary function F
     element-by-element to two array arguments A and B, and expands as
     necessary singleton dimensions in either input argument.  F is a
     function handle, inline function, or string containing the name of
     the function to evaluate.  The function F must be capable of
     accepting two column-vector arguments of equal length, or one
     column vector argument and a scalar.

     The dimensions of A and B must be equal or singleton.  The
     singleton dimensions of the arrays will be expanded to the same
     dimensionality as the other array.

     See also: arrayfun, cellfun.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
The binary singleton expansion function applier performs broadcasting,
that is, 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
built_in_docstrings_file


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 877
 -- Built-in Function: VAL = built_in_docstrings_file ()
 -- Built-in Function: OLD_VAL = built_in_docstrings_file (NEW_VAL)
 -- Built-in Function: built_in_docstrings_file (NEW_VAL, "local")
     Query or set the internal variable that specifies the name of the
     file containing docstrings for built-in Octave functions.  The
     default value is
     'OCTAVE-HOME/share/octave/VERSION/etc/built-in-docstrings', in
     which OCTAVE-HOME is the root directory of the Octave installation,
     and VERSION is the Octave version number.  The default value may be
     overridden by the environment variable
     'OCTAVE_BUILT_IN_DOCSTRINGS_FILE', or the command line argument
     '--built-in-docstrings-file FNAME'.

     Note: This variable is only used when Octave is initializing
     itself.  Modifying it during a running session of Octave will have
     no effect.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that specifies the name of the file
containin



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
builtin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 640
 -- Built-in Function: [...] = builtin (F, ...)
     Call the base function F even if F is overloaded to another
     function for the given type signature.

     This is normally useful when doing object-oriented programming and
     there is a requirement to call one of Octave's base functions
     rather than the overloaded one of a new class.

     A trivial example which redefines the 'sin' function to be the
     'cos' function shows how 'builtin' works.

          sin (0)
            => 0
          function y = sin (x), y = cos (x); endfunction
          sin (0)
            => 1
          builtin ("sin", 0)
            => 0




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Call the base function F even if F is overloaded to another function for
the giv



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
canonicalize_file_name


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 298
 -- Built-in Function: [CNAME, STATUS, MSG] = canonicalize_file_name
          (FNAME)
     Return the canonical name of file FNAME.  If the file does not
     exist the empty string ("") is returned.

     See also: make_absolute_filename, is_absolute_filename,
     is_rooted_relative_filename.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Return the canonical name of file FNAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
cat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 798
 -- Built-in Function: cat (DIM, ARRAY1, ARRAY2, ..., ARRAYN)
     Return the concatenation of N-D array objects, ARRAY1, ARRAY2, ...,
     ARRAYN along dimension DIM.

          A = ones (2, 2);
          B = zeros (2, 2);
          cat (2, A, B)
            => 1 1 0 0
               1 1 0 0

     Alternatively, we can concatenate A and B along the second
     dimension in the following way:

          [A, B]

     DIM can be larger than the dimensions of the N-D array objects and
     the result will thus have DIM dimensions as the following example
     shows:

          cat (4, ones (2, 2), zeros (2, 2))
            => ans(:,:,1,1) =

                 1 1
                 1 1

               ans(:,:,1,2) =

                 0 0
                 0 0

     See also: horzcat, vertcat.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the concatenation of N-D array objects, ARRAY1, ARRAY2, ...,
ARRAYN along



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
cbrt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 181
 -- Mapping Function: cbrt (X)
     Compute the real cube root of each element of X.  Unlike 'X^(1/3)',
     the result will be negative if X is negative.

     See also: nthroot.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Compute the real cube root of each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
cd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 762
 -- Command: cd DIR
 -- Command: cd
 -- Built-in Function: OLD_DIR = cd DIR
 -- Command: chdir ...
     Change the current working directory to DIR.

     If DIR is omitted, the current directory is changed to the user's
     home directory ("~").

     For example,

          cd ~/octave

     changes the current working directory to '~/octave'.  If the
     directory does not exist, an error message is printed and the
     working directory is not changed.

     'chdir' is an alias for 'cd' and can be used in all of the same
     calling formats.

     Compatibility Note: When called with no arguments, MATLAB prints
     the present working directory rather than changing to the user's
     home directory.

     See also: pwd, mkdir, rmdir, dir, ls.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Change the current working directory to DIR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
ceil


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 307
 -- Mapping Function: ceil (X)
     Return the smallest integer not less than X.  This is equivalent to
     rounding towards positive infinity.  If X is complex, return 'ceil
     (real (X)) + ceil (imag (X)) * I'.

          ceil ([-2.7, 2.7])
              => -2    3

     See also: floor, round, fix.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return the smallest integer not less than X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
cell


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 478
 -- Built-in Function: cell (N)
 -- Built-in Function: cell (M, N)
 -- Built-in Function: cell (M, N, K, ...)
 -- Built-in Function: cell ([M N ...])
     Create a new cell array object.

     If invoked with a single scalar integer argument, return a square
     NxN cell array.  If invoked with two or more scalar integer
     arguments, or a vector of integer values, return an array with the
     given dimensions.

     See also: cellstr, mat2cell, num2cell, struct2cell.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Create a new cell array object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
cell2struct


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 673
 -- Built-in Function: cell2struct (CELL, FIELDS)
 -- Built-in Function: cell2struct (CELL, FIELDS, DIM)
     Convert CELL to a structure.  The number of fields in FIELDS must
     match the number of elements in CELL along dimension DIM, that is
     'numel (FIELDS) == size (CELL, DIM)'.  If DIM is omitted, a value
     of 1 is assumed.

          A = cell2struct ({"Peter", "Hannah", "Robert";
                             185, 170, 168},
                           {"Name","Height"}, 1);
          A(1)
             =>
                {
                  Name   = Peter
                  Height = 185
                }


     See also: struct2cell, cell2mat, struct.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Convert CELL to a structure.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
cellfun


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4147
 -- Built-in Function: cellfun (NAME, C)
 -- Built-in Function: cellfun ("size", C, K)
 -- Built-in Function: cellfun ("isclass", C, CLASS)
 -- Built-in Function: cellfun (FUNC, C)
 -- Built-in Function: cellfun (FUNC, C, D)
 -- Built-in Function: [A, ...] = cellfun (...)
 -- Built-in Function: cellfun (..., "ErrorHandler", ERRFUNC)
 -- Built-in Function: cellfun (..., "UniformOutput", VAL)

     Evaluate the function named NAME on the elements of the cell array
     C.  Elements in C are passed on to the named function individually.
     The function NAME can be one of the functions

     'isempty'
          Return 1 for empty elements.

     'islogical'
          Return 1 for logical elements.

     'isnumeric'
          Return 1 for numeric elements.

     'isreal'
          Return 1 for real elements.

     'length'
          Return a vector of the lengths of cell elements.

     'ndims'
          Return the number of dimensions of each element.

     'numel'
     'prodofsize'
          Return the number of elements contained within each cell
          element.  The number is the product of the dimensions of the
          object at each cell element.

     'size'
          Return the size along the K-th dimension.

     'isclass'
          Return 1 for elements of CLASS.

     Additionally, 'cellfun' accepts an arbitrary function FUNC in the
     form of an inline function, function handle, or the name of a
     function (in a character string).  The function can take one or
     more arguments, with the inputs arguments given by C, D, etc.
     Equally the function can return one or more output arguments.  For
     example:

          cellfun ("atan2", {1, 0}, {0, 1})
               => [ 1.57080   0.00000 ]

     The number of output arguments of 'cellfun' matches the number of
     output arguments of the function.  The outputs of the function will
     be collected into the output arguments of 'cellfun' like this:

          function [a, b] = twoouts (x)
            a = x;
            b = x*x;
          endfunction
          [aa, bb] = cellfun (@twoouts, {1, 2, 3})
               =>
                  aa =
                     1 2 3
                  bb =
                     1 4 9

     Note that per default the output argument(s) are arrays of the same
     size as the input arguments.  Input arguments that are singleton
     (1x1) cells will be automatically expanded to the size of the other
     arguments.

     If the parameter "UniformOutput" is set to true (the default), then
     the function must return scalars which will be concatenated into
     the return array(s).  If "UniformOutput" is false, the outputs are
     concatenated into a cell array (or cell arrays).  For example:

          cellfun ("tolower", {"Foo", "Bar", "FooBar"},
                   "UniformOutput", false)
          => {"foo", "bar", "foobar"}

     Given the parameter "ErrorHandler", then ERRFUNC defines a function
     to call in case FUNC generates an error.  The form of the function
     is

          function [...] = errfunc (S, ...)

     where there is an additional input argument to ERRFUNC relative to
     FUNC, given by S.  This is a structure with the elements
     "identifier", "message" and "index", giving respectively the error
     identifier, the error message, and the index into the input
     arguments of the element that caused the error.  For example:

          function y = foo (s, x), y = NaN; endfunction
          cellfun ("factorial", {-1,2}, "ErrorHandler", @foo)
          => [NaN 2]

     Use 'cellfun' intelligently.  The 'cellfun' function is a useful
     tool for avoiding loops.  It is often used with anonymous function
     handles; however, calling an anonymous function involves an
     overhead quite comparable to the overhead of an m-file function.
     Passing a handle to a built-in function is faster, because the
     interpreter is not involved in the internal loop.  For example:

          a = {...}
          v = cellfun (@(x) det (x), a); # compute determinants
          v = cellfun (@det, a); # faster

     See also: arrayfun, structfun, spfun.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Evaluate the function named NAME on the elements of the cell array C.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
cellindexmat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 271
 -- Built-in Function: Y = cellindexmat (X, VARARGIN)
     Given a cell array of matrices X, this function computes

          Y = cell (size (X));
          for i = 1:numel (X)
            Y{i} = X{i}(varargin{:});
          endfor

     See also: cellslices, cellfun.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Given a cell array of matrices X, this function computes



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
cellslices


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 632
 -- Built-in Function: SL = cellslices (X, LB, UB, DIM)
     Given an array X, this function produces a cell array of slices
     from the array determined by the index vectors LB, UB, for lower
     and upper bounds, respectively.  In other words, it is equivalent
     to the following code:

          n = length (lb);
          sl = cell (1, n);
          for i = 1:length (lb)
            sl{i} = x(:,...,lb(i):ub(i),...,:);
          endfor

     The position of the index is determined by DIM.  If not specified,
     slicing is done along the first non-singleton dimension.

     See also: cell2mat, cellindexmat, cellfun.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Given an array X, this function produces a cell array of slices from the
array d



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
cellstr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 352
 -- Built-in Function: CSTR = cellstr (STRMAT)
     Create a new cell array object from the elements of the string
     array STRMAT.

     Each row of STRMAT becomes an element of CSTR.  Any trailing spaces
     in a row are deleted before conversion.

     To convert back from a cellstr to a character array use 'char'.

     See also: cell, char.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Create a new cell array object from the elements of the string array
STRMAT.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
char


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1140
 -- Built-in Function: char (X)
 -- Built-in Function: char (X, ...)
 -- Built-in Function: char (S1, S2, ...)
 -- Built-in Function: char (CELL_ARRAY)
     Create a string array from one or more numeric matrices, character
     matrices, or cell arrays.  Arguments are concatenated vertically.
     The returned values are padded with blanks as needed to make each
     row of the string array have the same length.  Empty input strings
     are significant and will concatenated in the output.

     For numerical input, each element is converted to the corresponding
     ASCII character.  A range error results if an input is outside the
     ASCII range (0-255).

     For cell arrays, each element is concatenated separately.  Cell
     arrays converted through 'char' can mostly be converted back with
     'cellstr'.  For example:

          char ([97, 98, 99], "", {"98", "99", 100}, "str1", ["ha", "lf"])
             => ["abc    "
                 "       "
                 "98     "
                 "99     "
                 "d      "
                 "str1   "
                 "half   "]

     See also: strvcat, cellstr.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Create a string array from one or more numeric matrices, character
matrices, or 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
chdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 762
 -- Command: cd DIR
 -- Command: cd
 -- Built-in Function: OLD_DIR = cd DIR
 -- Command: chdir ...
     Change the current working directory to DIR.

     If DIR is omitted, the current directory is changed to the user's
     home directory ("~").

     For example,

          cd ~/octave

     changes the current working directory to '~/octave'.  If the
     directory does not exist, an error message is printed and the
     working directory is not changed.

     'chdir' is an alias for 'cd' and can be used in all of the same
     calling formats.

     Compatibility Note: When called with no arguments, MATLAB prints
     the present working directory rather than changing to the user's
     home directory.

     See also: pwd, mkdir, rmdir, dir, ls.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Change the current working directory to DIR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
class


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 357
 -- Function File: CLASSNAME = class (OBJ)
 -- Function File: class (S, ID)
 -- Function File: class (S, ID, P, ...)
     Return the class of the object OBJ or create a class with fields
     from structure S and name (string) ID.  Additional arguments name a
     list of parent classes from which the new class is derived.

     See also: typeinfo, isa.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the class of the object OBJ or create a class with fields from
structure 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
clc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 144
 -- Built-in Function: clc ()
 -- Built-in Function: home ()
     Clear the terminal screen and move the cursor to the upper left
     corner.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Clear the terminal screen and move the cursor to the upper left corner.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
clear


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2166
 -- Command: clear [options] pattern ...
     Delete the names matching the given patterns from the symbol table.
     The pattern may contain the following special characters:

     '?'
          Match any single character.

     '*'
          Match zero or more characters.

     '[ LIST ]'
          Match the list of characters specified by LIST.  If the first
          character is '!' or '^', match all characters except those
          specified by LIST.  For example, the pattern '[a-zA-Z]' will
          match all lowercase and uppercase alphabetic characters.

     For example, the command

          clear foo b*r

     clears the name 'foo' and all names that begin with the letter 'b'
     and end with the letter 'r'.

     If 'clear' is called without any arguments, all user-defined
     variables (local and global) are cleared from the symbol table.  If
     'clear' is called with at least one argument, only the visible
     names matching the arguments are cleared.  For example, suppose you
     have defined a function 'foo', and then hidden it by performing the
     assignment 'foo = 2'.  Executing the command 'clear foo' once will
     clear the variable definition and restore the definition of 'foo'
     as a function.  Executing 'clear foo' a second time will clear the
     function definition.

     The following options are available in both long and short form

     '-all, -a'
          Clears all local and global user-defined variables and all
          functions from the symbol table.

     '-exclusive, -x'
          Clears the variables that don't match the following pattern.

     '-functions, -f'
          Clears the function names and the built-in symbols names.

     '-global, -g'
          Clears the global symbol names.

     '-variables, -v'
          Clears the local variable names.

     '-classes, -c'
          Clears the class structure table and clears all objects.

     '-regexp, -r'
          The arguments are treated as regular expressions as any
          variables that match will be cleared.

     With the exception of 'exclusive', all long options can be used
     without the dash as well.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Delete the names matching the given patterns from the symbol table.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
colloc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 305
 -- Built-in Function: [R, AMAT, BMAT, Q] = colloc (N, "left", "right")
     Compute derivative and integral weight matrices for orthogonal
     collocation using the subroutines given in J. Villadsen and M. L.
     Michelsen, 'Solution of Differential Equation Models by Polynomial
     Approximation'.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute derivative and integral weight matrices for orthogonal
collocation using



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
columns


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 149
 -- Built-in Function: columns (A)
     Return the number of columns of A.

     See also: rows, size, length, numel, isscalar, isvector, ismatrix.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Return the number of columns of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
command_line_path


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 173
 -- Built-in Function: command_line_path (...)
     Return the command line path variable.

     See also: path, addpath, rmpath, genpath, pathdef, savepath,
     pathsep.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Return the command line path variable.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
completion_append_char


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 584
 -- Built-in Function: VAL = completion_append_char ()
 -- Built-in Function: OLD_VAL = completion_append_char (NEW_VAL)
 -- Built-in Function: completion_append_char (NEW_VAL, "local")
     Query or set the internal character variable that is appended to
     successful command-line completion attempts.  The default value is
     " " (a single space).

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal character variable that is appended to
successful comm



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
completion_matches


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 350
 -- Built-in Function: completion_matches (HINT)
     Generate possible completions given HINT.

     This function is provided for the benefit of programs like Emacs
     which might be controlling Octave and handling user input.  The
     current command number is not incremented when this function is
     called.  This is a feature, not a bug.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Generate possible completions given HINT.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
complex


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 473
 -- Built-in Function: complex (X)
 -- Built-in Function: complex (RE, IM)
     Return a complex result from real arguments.  With 1 real argument
     X, return the complex result 'X + 0i'.  With 2 real arguments,
     return the complex result 'RE + IM'.  'complex' can often be more
     convenient than expressions such as 'a + i*b'.  For example:

          complex ([1, 2], [3, 4])
            => [ 1 + 3i   2 + 4i ]

     See also: real, imag, iscomplex, abs, arg.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return a complex result from real arguments.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
confirm_recursive_rmdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 592
 -- Built-in Function: VAL = confirm_recursive_rmdir ()
 -- Built-in Function: OLD_VAL = confirm_recursive_rmdir (NEW_VAL)
 -- Built-in Function: confirm_recursive_rmdir (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave
     will ask for confirmation before recursively removing a directory
     tree.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: rmdir.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that controls whether Octave will ask
for con



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
conj


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 132
 -- Mapping Function: conj (Z)
     Return the complex conjugate of Z, defined as 'conj (Z)' = X - IY.

     See also: real, imag.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Return the complex conjugate of Z, defined as 'conj (Z)' = X - IY.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
conv2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 923
 -- Built-in Function: conv2 (A, B)
 -- Built-in Function: conv2 (V1, V2, M)
 -- Built-in Function: conv2 (..., SHAPE)
     Return the 2-D convolution of A and B.  The size of the result is
     determined by the optional SHAPE argument which takes the following
     values

     SHAPE = "full"
          Return the full convolution.  (default)

     SHAPE = "same"
          Return the central part of the convolution with the same size
          as A.  The central part of the convolution begins at the
          indices 'floor ([size(B)/2] + 1)'.

     SHAPE = "valid"
          Return only the parts which do not include zero-padded edges.
          The size of the result is 'max (size (A) - size (B) + 1, 0)'.

     When the third argument is a matrix, return the convolution of the
     matrix M by the vector V1 in the column direction and by the vector
     V2 in the row direction.

     See also: conv, convn.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Return the 2-D convolution of A and B.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
convn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 711
 -- Built-in Function: C = convn (A, B)
 -- Built-in Function: C = convn (A, B, SHAPE)
     Return the n-D convolution of A and B.  The size of the result is
     determined by the optional SHAPE argument which takes the following
     values

     SHAPE = "full"
          Return the full convolution.  (default)

     SHAPE = "same"
          Return central part of the convolution with the same size as
          A.  The central part of the convolution begins at the indices
          'floor ([size(B)/2] + 1)'.

     SHAPE = "valid"
          Return only the parts which do not include zero-padded edges.
          The size of the result is 'max (size (A) - size (B) + 1, 0)'.

     See also: conv2, conv.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Return the n-D convolution of A and B.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
cos


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 123
 -- Mapping Function: cos (X)
     Compute the cosine for each element of X in radians.

     See also: acos, cosd, cosh.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Compute the cosine for each element of X in radians.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
cosh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 125
 -- Mapping Function: cosh (X)
     Compute the hyperbolic cosine for each element of X.

     See also: acosh, sinh, tanh.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Compute the hyperbolic cosine for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
cputime


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 717
 -- Built-in Function: [TOTAL, USER, SYSTEM] = cputime ();
     Return the CPU time used by your Octave session.  The first output
     is the total time spent executing your process and is equal to the
     sum of second and third outputs, which are the number of CPU
     seconds spent executing in user mode and the number of CPU seconds
     spent executing in system mode, respectively.  If your system does
     not have a way to report CPU time usage, 'cputime' returns 0 for
     each of its output values.  Note that because Octave used some CPU
     time to start, it is reasonable to check to see if 'cputime' works
     by checking to see if the total CPU time used is nonzero.

     See also: tic, toc.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Return the CPU time used by your Octave session.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
crash_dumps_octave_core


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 723
 -- Built-in Function: VAL = crash_dumps_octave_core ()
 -- Built-in Function: OLD_VAL = crash_dumps_octave_core (NEW_VAL)
 -- Built-in Function: crash_dumps_octave_core (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave
     tries to save all current variables to the file 'octave-workspace'
     if it crashes or receives a hangup, terminate or similar signal.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: octave_core_file_limit, octave_core_file_name,
     octave_core_file_options.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that controls whether Octave tries to
save al



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
ctranspose


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 159
 -- Built-in Function: ctranspose (X)
     Return the complex conjugate transpose of X.  This function and x'
     are equivalent.

     See also: transpose.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return the complex conjugate transpose of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
cummax


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 587
 -- Built-in Function: cummax (X)
 -- Built-in Function: cummax (X, DIM)
 -- Built-in Function: [W, IW] = cummax (...)
     Return the cumulative maximum values along dimension DIM.

     If DIM is unspecified it defaults to column-wise operation.  For
     example:

          cummax ([1 3 2 6 4 5])
             =>  1  3  3  6  6  6

     If called with two output arguments the index of the maximum value
     is also returned.

          [w, iw] = cummax ([1 3 2 6 4 5])
          =>
          w =  1  3  3  6  6  6
          iw = 1  2  2  4  4  4

     See also: cummin, max, min.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Return the cumulative maximum values along dimension DIM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
cummin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 585
 -- Built-in Function: cummin (X)
 -- Built-in Function: cummin (X, DIM)
 -- Built-in Function: [W, IW] = cummin (X)
     Return the cumulative minimum values along dimension DIM.

     If DIM is unspecified it defaults to column-wise operation.  For
     example:

          cummin ([5 4 6 2 3 1])
             =>  5  4  4  2  2  1

     If called with two output arguments the index of the minimum value
     is also returned.

          [w, iw] = cummin ([5 4 6 2 3 1])
          =>
          w =  5  4  4  2  2  1
          iw = 1  2  2  4  4  6

     See also: cummax, min, max.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Return the cumulative minimum values along dimension DIM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
cumprod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 238
 -- Built-in Function: cumprod (X)
 -- Built-in Function: cumprod (X, DIM)
     Cumulative product of elements along dimension DIM.  If DIM is
     omitted, it defaults to the first non-singleton dimension.

     See also: prod, cumsum.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Cumulative product of elements along dimension DIM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
cumsum


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 469
 -- Built-in Function: cumsum (X)
 -- Built-in Function: cumsum (X, DIM)
 -- Built-in Function: cumsum (..., "native")
 -- Built-in Function: cumsum (..., "double")
 -- Built-in Function: cumsum (..., "extra")
     Cumulative sum of elements along dimension DIM.  If DIM is omitted,
     it defaults to the first non-singleton dimension.

     See 'sum' for an explanation of the optional parameters "native",
     "double", and "extra".

     See also: sum, cumprod.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Cumulative sum of elements along dimension DIM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
daspk


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2572
 -- Built-in Function: [X, XDOT, ISTATE, MSG] = daspk (FCN, X_0, XDOT_0,
          T, T_CRIT)
     Solve the set of differential-algebraic equations

          0 = f (x, xdot, t)

     with

          x(t_0) = x_0, xdot(t_0) = xdot_0

     The solution is returned in the matrices X and XDOT, with each row
     in the result matrices corresponding to one of the elements in the
     vector T.  The first element of T should be t_0 and correspond to
     the initial state of the system X_0 and its derivative XDOT_0, so
     that the first row of the output X is X_0 and the first row of the
     output XDOT is XDOT_0.

     The first argument, FCN, is a string, inline, or function handle
     that names the function f to call to compute the vector of
     residuals for the set of equations.  It must have the form

          RES = f (X, XDOT, T)

     in which X, XDOT, and RES are vectors, and T is a scalar.

     If FCN is a two-element string array or a two-element cell array of
     strings, inline functions, or function handles, the first element
     names the function f described above, and the second element names
     a function to compute the modified Jacobian

                df       df
          jac = -- + c ------
                dx     d xdot

     The modified Jacobian function must have the form


          JAC = j (X, XDOT, T, C)


     The second and third arguments to 'daspk' specify the initial
     condition of the states and their derivatives, and the fourth
     argument specifies a vector of output times at which the solution
     is desired, including the time corresponding to the initial
     condition.

     The set of initial states and derivatives are not strictly required
     to be consistent.  If they are not consistent, you must use the
     'daspk_options' function to provide additional information so that
     'daspk' can compute a consistent starting point.

     The fifth argument is optional, and may be used to specify a set of
     times that the DAE solver should not integrate past.  It is useful
     for avoiding difficulties with singularities and points where there
     is a discontinuity in the derivative.

     After a successful computation, the value of ISTATE will be greater
     than zero (consistent with the Fortran version of DASPK).

     If the computation is not successful, the value of ISTATE will be
     less than zero and MSG will contain additional information.

     You can use the function 'daspk_options' to set optional parameters
     for 'daspk'.

     See also: dassl.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Solve the set of differential-algebraic equations



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
daspk_options


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6422
 -- Built-in Function: daspk_options ()
 -- Built-in Function: val = daspk_options (OPT)
 -- Built-in Function: daspk_options (OPT, VAL)
     Query or set options for the function 'daspk'.  When called with no
     arguments, the names of all available options and their current
     values are displayed.  Given one argument, return the value of the
     corresponding option.  When called with two arguments,
     'daspk_options' set the option OPT to value VAL.

     Options include

     '"absolute tolerance"'
          Absolute tolerance.  May be either vector or scalar.  If a
          vector, it must match the dimension of the state vector, and
          the relative tolerance must also be a vector of the same
          length.

     '"relative tolerance"'
          Relative tolerance.  May be either vector or scalar.  If a
          vector, it must match the dimension of the state vector, and
          the absolute tolerance must also be a vector of the same
          length.

          The local error test applied at each integration step is

                 abs (local error in x(i))
                      <= rtol(i) * abs (Y(i)) + atol(i)

     '"compute consistent initial condition"'
          Denoting the differential variables in the state vector by
          'Y_d' and the algebraic variables by 'Y_a', 'ddaspk' can solve
          one of two initialization problems:

            1. Given Y_d, calculate Y_a and Y'_d

            2. Given Y', calculate Y.

          In either case, initial values for the given components are
          input, and initial guesses for the unknown components must
          also be provided as input.  Set this option to 1 to solve the
          first problem, or 2 to solve the second (the default is 0, so
          you must provide a set of initial conditions that are
          consistent).

          If this option is set to a nonzero value, you must also set
          the "algebraic variables" option to declare which variables in
          the problem are algebraic.

     '"use initial condition heuristics"'
          Set to a nonzero value to use the initial condition heuristics
          options described below.

     '"initial condition heuristics"'
          A vector of the following parameters that can be used to
          control the initial condition calculation.

          'MXNIT'
               Maximum number of Newton iterations (default is 5).

          'MXNJ'
               Maximum number of Jacobian evaluations (default is 6).

          'MXNH'
               Maximum number of values of the artificial stepsize
               parameter to be tried if the "compute consistent initial
               condition" option has been set to 1 (default is 5).

               Note that the maximum total number of Newton iterations
               allowed is 'MXNIT*MXNJ*MXNH' if the "compute consistent
               initial condition" option has been set to 1 and
               'MXNIT*MXNJ' if it is set to 2.

          'LSOFF'
               Set to a nonzero value to disable the linesearch
               algorithm (default is 0).

          'STPTOL'
               Minimum scaled step in linesearch algorithm (default is
               eps^(2/3)).

          'EPINIT'
               Swing factor in the Newton iteration convergence test.
               The test is applied to the residual vector, premultiplied
               by the approximate Jacobian.  For convergence, the
               weighted RMS norm of this vector (scaled by the error
               weights) must be less than 'EPINIT*EPCON', where 'EPCON'
               = 0.33 is the analogous test constant used in the time
               steps.  The default is 'EPINIT' = 0.01.

     '"print initial condition info"'
          Set this option to a nonzero value to display detailed
          information about the initial condition calculation (default
          is 0).

     '"exclude algebraic variables from error test"'
          Set to a nonzero value to exclude algebraic variables from the
          error test.  You must also set the "algebraic variables"
          option to declare which variables in the problem are algebraic
          (default is 0).

     '"algebraic variables"'
          A vector of the same length as the state vector.  A nonzero
          element indicates that the corresponding element of the state
          vector is an algebraic variable (i.e., its derivative does not
          appear explicitly in the equation set.

          This option is required by the compute consistent initial
          condition" and "exclude algebraic variables from error test"
          options.

     '"enforce inequality constraints"'
          Set to one of the following values to enforce the inequality
          constraints specified by the "inequality constraint types"
          option (default is 0).

            1. To have constraint checking only in the initial condition
               calculation.

            2. To enforce constraint checking during the integration.

            3. To enforce both options 1 and 2.

     '"inequality constraint types"'
          A vector of the same length as the state specifying the type
          of inequality constraint.  Each element of the vector
          corresponds to an element of the state and should be assigned
          one of the following codes

          -2
               Less than zero.

          -1
               Less than or equal to zero.

          0
               Not constrained.

          1
               Greater than or equal to zero.

          2
               Greater than zero.

          This option only has an effect if the "enforce inequality
          constraints" option is nonzero.

     '"initial step size"'
          Differential-algebraic problems may occasionally suffer from
          severe scaling difficulties on the first step.  If you know a
          great deal about the scaling of your problem, you can help to
          alleviate this problem by specifying an initial stepsize
          (default is computed automatically).

     '"maximum order"'
          Restrict the maximum order of the solution method.  This
          option must be between 1 and 5, inclusive (default is 5).

     '"maximum step size"'
          Setting the maximum stepsize will avoid passing over very
          large regions (default is not specified).




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Query or set options for the function 'daspk'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
dasrt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4356
 -- Built-in Function: [X, XDOT, T_OUT, ISTAT, MSG] = dasrt (FCN, [],
          X_0, XDOT_0, T)
 -- Built-in Function: ... = dasrt (FCN, G, X_0, XDOT_0, T)
 -- Built-in Function: ... = dasrt (FCN, [], X_0, XDOT_0, T, T_CRIT)
 -- Built-in Function: ... = dasrt (FCN, G, X_0, XDOT_0, T, T_CRIT)
     Solve the set of differential-algebraic equations

          0 = f (x, xdot, t)

     with

          x(t_0) = x_0, xdot(t_0) = xdot_0

     with functional stopping criteria (root solving).

     The solution is returned in the matrices X and XDOT, with each row
     in the result matrices corresponding to one of the elements in the
     vector T_OUT.  The first element of T should be t_0 and correspond
     to the initial state of the system X_0 and its derivative XDOT_0,
     so that the first row of the output X is X_0 and the first row of
     the output XDOT is XDOT_0.

     The vector T provides an upper limit on the length of the
     integration.  If the stopping condition is met, the vector T_OUT
     will be shorter than T, and the final element of T_OUT will be the
     point at which the stopping condition was met, and may not
     correspond to any element of the vector T.

     The first argument, FCN, is a string, inline, or function handle
     that names the function f to call to compute the vector of
     residuals for the set of equations.  It must have the form

          RES = f (X, XDOT, T)

     in which X, XDOT, and RES are vectors, and T is a scalar.

     If FCN is a two-element string array or a two-element cell array of
     strings, inline functions, or function handles, the first element
     names the function f described above, and the second element names
     a function to compute the modified Jacobian

                df       df
          jac = -- + c ------
                dx     d xdot

     The modified Jacobian function must have the form


          JAC = j (X, XDOT, T, C)


     The optional second argument names a function that defines the
     constraint functions whose roots are desired during the
     integration.  This function must have the form

          G_OUT = g (X, T)

     and return a vector of the constraint function values.  If the
     value of any of the constraint functions changes sign, DASRT will
     attempt to stop the integration at the point of the sign change.

     If the name of the constraint function is omitted, 'dasrt' solves
     the same problem as 'daspk' or 'dassl'.

     Note that because of numerical errors in the constraint functions
     due to round-off and integration error, DASRT may return false
     roots, or return the same root at two or more nearly equal values
     of T.  If such false roots are suspected, the user should consider
     smaller error tolerances or higher precision in the evaluation of
     the constraint functions.

     If a root of some constraint function defines the end of the
     problem, the input to DASRT should nevertheless allow integration
     to a point slightly past that root, so that DASRT can locate the
     root by interpolation.

     The third and fourth arguments to 'dasrt' specify the initial
     condition of the states and their derivatives, and the fourth
     argument specifies a vector of output times at which the solution
     is desired, including the time corresponding to the initial
     condition.

     The set of initial states and derivatives are not strictly required
     to be consistent.  In practice, however, DASSL is not very good at
     determining a consistent set for you, so it is best if you ensure
     that the initial values result in the function evaluating to zero.

     The sixth argument is optional, and may be used to specify a set of
     times that the DAE solver should not integrate past.  It is useful
     for avoiding difficulties with singularities and points where there
     is a discontinuity in the derivative.

     After a successful computation, the value of ISTATE will be greater
     than zero (consistent with the Fortran version of DASSL).

     If the computation is not successful, the value of ISTATE will be
     less than zero and MSG will contain additional information.

     You can use the function 'dasrt_options' to set optional parameters
     for 'dasrt'.

     See also: dasrt_options, daspk, dasrt, lsode.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Solve the set of differential-algebraic equations



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
dasrt_options


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1880
 -- Built-in Function: dasrt_options ()
 -- Built-in Function: val = dasrt_options (OPT)
 -- Built-in Function: dasrt_options (OPT, VAL)
     Query or set options for the function 'dasrt'.  When called with no
     arguments, the names of all available options and their current
     values are displayed.  Given one argument, return the value of the
     corresponding option.  When called with two arguments,
     'dasrt_options' set the option OPT to value VAL.

     Options include

     '"absolute tolerance"'
          Absolute tolerance.  May be either vector or scalar.  If a
          vector, it must match the dimension of the state vector, and
          the relative tolerance must also be a vector of the same
          length.

     '"relative tolerance"'
          Relative tolerance.  May be either vector or scalar.  If a
          vector, it must match the dimension of the state vector, and
          the absolute tolerance must also be a vector of the same
          length.

          The local error test applied at each integration step is

                 abs (local error in x(i)) <= ...
                     rtol(i) * abs (Y(i)) + atol(i)

     '"initial step size"'
          Differential-algebraic problems may occasionally suffer from
          severe scaling difficulties on the first step.  If you know a
          great deal about the scaling of your problem, you can help to
          alleviate this problem by specifying an initial stepsize.

     '"maximum order"'
          Restrict the maximum order of the solution method.  This
          option must be between 1 and 5, inclusive.

     '"maximum step size"'
          Setting the maximum stepsize will avoid passing over very
          large regions.

     '"step limit"'
          Maximum number of integration steps to attempt on a single
          call to the underlying Fortran code.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Query or set options for the function 'dasrt'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
dassl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2606
 -- Built-in Function: [X, XDOT, ISTATE, MSG] = dassl (FCN, X_0, XDOT_0,
          T, T_CRIT)
     Solve the set of differential-algebraic equations

          0 = f (x, xdot, t)

     with

          x(t_0) = x_0, xdot(t_0) = xdot_0

     The solution is returned in the matrices X and XDOT, with each row
     in the result matrices corresponding to one of the elements in the
     vector T.  The first element of T should be t_0 and correspond to
     the initial state of the system X_0 and its derivative XDOT_0, so
     that the first row of the output X is X_0 and the first row of the
     output XDOT is XDOT_0.

     The first argument, FCN, is a string, inline, or function handle
     that names the function f to call to compute the vector of
     residuals for the set of equations.  It must have the form

          RES = f (X, XDOT, T)

     in which X, XDOT, and RES are vectors, and T is a scalar.

     If FCN is a two-element string array or a two-element cell array of
     strings, inline functions, or function handles, the first element
     names the function f described above, and the second element names
     a function to compute the modified Jacobian

                df       df
          jac = -- + c ------
                dx     d xdot

     The modified Jacobian function must have the form


          JAC = j (X, XDOT, T, C)


     The second and third arguments to 'dassl' specify the initial
     condition of the states and their derivatives, and the fourth
     argument specifies a vector of output times at which the solution
     is desired, including the time corresponding to the initial
     condition.

     The set of initial states and derivatives are not strictly required
     to be consistent.  In practice, however, DASSL is not very good at
     determining a consistent set for you, so it is best if you ensure
     that the initial values result in the function evaluating to zero.

     The fifth argument is optional, and may be used to specify a set of
     times that the DAE solver should not integrate past.  It is useful
     for avoiding difficulties with singularities and points where there
     is a discontinuity in the derivative.

     After a successful computation, the value of ISTATE will be greater
     than zero (consistent with the Fortran version of DASSL).

     If the computation is not successful, the value of ISTATE will be
     less than zero and MSG will contain additional information.

     You can use the function 'dassl_options' to set optional parameters
     for 'dassl'.

     See also: daspk, dasrt, lsode.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Solve the set of differential-algebraic equations



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
dassl_options


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2558
 -- Built-in Function: dassl_options ()
 -- Built-in Function: val = dassl_options (OPT)
 -- Built-in Function: dassl_options (OPT, VAL)
     Query or set options for the function 'dassl'.  When called with no
     arguments, the names of all available options and their current
     values are displayed.  Given one argument, return the value of the
     corresponding option.  When called with two arguments,
     'dassl_options' set the option OPT to value VAL.

     Options include

     '"absolute tolerance"'
          Absolute tolerance.  May be either vector or scalar.  If a
          vector, it must match the dimension of the state vector, and
          the relative tolerance must also be a vector of the same
          length.

     '"relative tolerance"'
          Relative tolerance.  May be either vector or scalar.  If a
          vector, it must match the dimension of the state vector, and
          the absolute tolerance must also be a vector of the same
          length.

          The local error test applied at each integration step is

                 abs (local error in x(i))
                      <= rtol(i) * abs (Y(i)) + atol(i)

     '"compute consistent initial condition"'
          If nonzero, 'dassl' will attempt to compute a consistent set
          of initial conditions.  This is generally not reliable, so it
          is best to provide a consistent set and leave this option set
          to zero.

     '"enforce nonnegativity constraints"'
          If you know that the solutions to your equations will always
          be non-negative, it may help to set this parameter to a
          nonzero value.  However, it is probably best to try leaving
          this option set to zero first, and only setting it to a
          nonzero value if that doesn't work very well.

     '"initial step size"'
          Differential-algebraic problems may occasionally suffer from
          severe scaling difficulties on the first step.  If you know a
          great deal about the scaling of your problem, you can help to
          alleviate this problem by specifying an initial stepsize.

     '"maximum order"'
          Restrict the maximum order of the solution method.  This
          option must be between 1 and 5, inclusive.

     '"maximum step size"'
          Setting the maximum stepsize will avoid passing over very
          large regions (default is not specified).

     '"step limit"'
          Maximum number of integration steps to attempt on a single
          call to the underlying Fortran code.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Query or set options for the function 'dassl'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dawson


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 201
 -- Mapping Function: dawson (Z)
     Compute the Dawson (scaled imaginary error) function,

          (sqrt (pi) / 2) * exp (-z^2) * erfi (z)

     See also: erfc, erf, erfcx, erfi, erfinv, erfcinv.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Compute the Dawson (scaled imaginary error) function,



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
dbclear


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 751
 -- Built-in Function: dbclear ("FUNC")
 -- Built-in Function: dbclear ("FUNC", LINE, ...)
 -- Built-in Function: dbclear (LINE, ...)
     Delete a breakpoint in the function FUNC.

     Arguments are

     FUNC
          Function name as a string variable.  When already in debug
          mode this argument should be omitted and only the line number
          should be given.

     LINE
          Line number from which to remove a breakpoint.  Multiple lines
          may be given as separate arguments or as a vector.

     When called without a line number specification all breakpoints in
     the named function are cleared.

     If the requested line is not a breakpoint no action is performed.

     See also: dbstop, dbstatus, dbwhere.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Delete a breakpoint in the function FUNC.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dbcont


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 135
 -- Command: dbcont
     Leave command-line debugging mode and continue code execution
     normally.

     See also: dbstep, dbquit.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Leave command-line debugging mode and continue code execution normally.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dbdown


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 204
 -- Built-in Function: dbdown
 -- Built-in Function: dbdown (N)
     In debugging mode, move down the execution stack N frames.  If N is
     omitted, move down one frame.

     See also: dbstack, dbup.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
In debugging mode, move down the execution stack N frames.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dblist


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 250
 -- Command: dblist
 -- Command: dblist N
     In debugging mode, list N lines of the function being debugged
     centered around the current line to be executed.  If unspecified N
     defaults to 10 (+/- 5 lines)

     See also: dbwhere, dbtype.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
In debugging mode, list N lines of the function being debugged centered
around t



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dbnext


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 627
 -- Command: dbstep
 -- Command: dbstep N
 -- Command: dbstep in
 -- Command: dbstep out
 -- Command: dbnext ...
     In debugging mode, execute the next N lines of code.  If N is
     omitted, execute the next single line of code.  If the next line of
     code is itself defined in terms of an m-file remain in the existing
     function.

     Using 'dbstep in' will cause execution of the next line to step
     into any m-files defined on the next line.  Using 'dbstep out' will
     cause execution to continue until the current function returns.

     'dbnext' is an alias for 'dbstep'.

     See also: dbcont, dbquit.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
In debugging mode, execute the next N lines of code.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dbquit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 159
 -- Command: dbquit
     Quit debugging mode immediately without further code execution and
     return to the Octave prompt.

     See also: dbcont, dbstep.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Quit debugging mode immediately without further code execution and
return to the



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
dbstack


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1076
 -- Command: dbstack
 -- Command: dbstack N
 -- Command: dbstack -COMPLETENAMES
 -- Built-in Function: [STACK, IDX] = dbstack (...)
     Display or return current debugging function stack information.
     With optional argument N, omit the N innermost stack frames.

     Although accepted, the argument -COMPLETENAMES is silently ignored.
     Octave always returns absolute file names.  The arguments N and
     -COMPLETENAMES can be both specified in any order.

     The optional return argument STACK is a struct array with the
     following fields:

     file
          The name of the m-file where the function code is located.

     name
          The name of the function with a breakpoint.

     line
          The line number of an active breakpoint.

     column
          The column number of the line where the breakpoint begins.

     scope
          Undocumented.

     context
          Undocumented.

     The return argument IDX specifies which element of the STACK struct
     array is currently active.

     See also: dbup, dbdown, dbwhere, dbstatus.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Display or return current debugging function stack information.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
dbstatus


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 799
 -- Built-in Function: dbstatus ()
 -- Built-in Function: BRK_LIST = dbstatus ()
 -- Built-in Function: BRK_LIST = dbstatus ("FUNC")
     Report the location of active breakpoints.

     When called with no input or output arguments, print the list of
     all functions with breakpoints and the line numbers where those
     breakpoints are set.  If a function name FUNC is specified then
     only report breakpoints for the named function.

     The optional return argument BRK_LIST is a struct array with the
     following fields.

     name
          The name of the function with a breakpoint.

     file
          The name of the m-file where the function code is located.

     line
          A line number, or vector of line numbers, with a breakpoint.

     See also: dbclear, dbwhere.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Report the location of active breakpoints.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dbstep


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 627
 -- Command: dbstep
 -- Command: dbstep N
 -- Command: dbstep in
 -- Command: dbstep out
 -- Command: dbnext ...
     In debugging mode, execute the next N lines of code.  If N is
     omitted, execute the next single line of code.  If the next line of
     code is itself defined in terms of an m-file remain in the existing
     function.

     Using 'dbstep in' will cause execution of the next line to step
     into any m-files defined on the next line.  Using 'dbstep out' will
     cause execution to continue until the current function returns.

     'dbnext' is an alias for 'dbstep'.

     See also: dbcont, dbquit.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
In debugging mode, execute the next N lines of code.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dbstop


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1065
 -- Built-in Function: RLINE = dbstop ("FUNC")
 -- Built-in Function: RLINE = dbstop ("FUNC", LINE)
 -- Built-in Function: RLINE = dbstop ("FUNC", LINE1, LINE2, ...)
     Set a breakpoint in function FUNC.

     Arguments are

     FUNC
          Function name as a string variable.  When already in debug
          mode this should be left out and only the line should be
          given.

     LINE
          Line number where the breakpoint should be set.  Multiple
          lines may be given as separate arguments or as a vector.

     When called with a single argument FUNC, the breakpoint is set at
     the first executable line in the named function.

     The optional output RLINE is the real line number where the
     breakpoint was set.  This can differ from specified line if the
     line is not executable.  For example, if a breakpoint attempted on
     a blank line then Octave will set the real breakpoint at the next
     executable line.

     See also: dbclear, dbstatus, dbstep, debug_on_error,
     debug_on_warning, debug_on_interrupt.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Set a breakpoint in function FUNC.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
dbtype


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 724
 -- Command: dbtype
 -- Command: dbtype LINENO
 -- Command: dbtype STARTL:ENDL
 -- Command: dbtype STARTL:END
 -- Command: dbtype FUNC
 -- Command: dbtype FUNC LINENO
 -- Command: dbtype FUNC STARTL:ENDL
 -- Command: dbtype FUNC STARTL:END
     Display a script file with line numbers.

     When called with no arguments in debugging mode, display the script
     file currently being debugged.  An optional range specification can
     be used to list only a portion of the file.  The special keyword
     "end" is a valid line number specification for the last line of the
     file.

     When called with the name of a function, list that script file with
     line numbers.

     See also: dbwhere, dbstatus, dbstop.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Display a script file with line numbers.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
dbup


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 198
 -- Built-in Function: dbup
 -- Built-in Function: dbup (N)
     In debugging mode, move up the execution stack N frames.  If N is
     omitted, move up one frame.

     See also: dbstack, dbdown.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
In debugging mode, move up the execution stack N frames.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
dbwhere


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 167
 -- Command: dbwhere
     In debugging mode, report the current file and line number where
     execution is stopped.

     See also: dbstatus, dbcont, dbstep, dbup.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
In debugging mode, report the current file and line number where
execution is st



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
debug_java


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 631
 -- Built-in Function: VAL = debug_java ()
 -- Built-in Function: OLD_VAL = debug_java (NEW_VAL)
 -- Built-in Function: debug_java (NEW_VAL, "local")
     Query or set the internal variable that determines whether extra
     debugging information regarding the initialization of the JVM and
     any Java exceptions is printed.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: java_matrix_autoconversion, java_unsigned_autoconversion.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that determines whether extra
debugging infor



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
debug_jit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 543
 -- Built-in Function: VAL = debug_jit ()
 -- Built-in Function: OLD_VAL = debug_jit (NEW_VAL)
 -- Built-in Function: debug_jit (NEW_VAL, "local")
     Query or set the internal variable that determines whether
     debugging/tracing is enabled for Octave's JIT compiler.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: jit_enable, jit_startcnt.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that determines whether
debugging/tracing is 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
debug_on_error


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 704
 -- Built-in Function: VAL = debug_on_error ()
 -- Built-in Function: OLD_VAL = debug_on_error (NEW_VAL)
 -- Built-in Function: debug_on_error (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave
     will try to enter the debugger when an error is encountered.  This
     will also inhibit printing of the normal traceback message (you
     will only see the top-level error message).

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: debug_on_warning, debug_on_interrupt.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that controls whether Octave will try
to ente



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
debug_on_interrupt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 755
 -- Built-in Function: VAL = debug_on_interrupt ()
 -- Built-in Function: OLD_VAL = debug_on_interrupt (NEW_VAL)
 -- Built-in Function: debug_on_interrupt (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave
     will try to enter debugging mode when it receives an interrupt
     signal (typically generated with 'C-c').  If a second interrupt
     signal is received before reaching the debugging mode, a normal
     interrupt will occur.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: debug_on_error, debug_on_warning.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that controls whether Octave will try
to ente



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
debug_on_warning


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 585
 -- Built-in Function: VAL = debug_on_warning ()
 -- Built-in Function: OLD_VAL = debug_on_warning (NEW_VAL)
 -- Built-in Function: debug_on_warning (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave
     will try to enter the debugger when a warning is encountered.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: debug_on_error, debug_on_interrupt.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that controls whether Octave will try
to ente



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
dellistener


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 647
 -- Built-in Function: dellistener (H, PROP, FCN)
     Remove the registration of FCN as a listener for the property PROP
     of the graphics object H.  The function FCN must be the same
     variable (not just the same value), as was passed to the original
     call to 'addlistener'.

     If FCN is not defined then all listener functions of PROP are
     removed.

     Example:

          function my_listener (h, dummy, p1)
            fprintf ("my_listener called with p1=%s\n", p1);
          endfunction

          c = {@my_listener, "my string"};
          addlistener (gcf, "position", c);
          dellistener (gcf, "position", c);




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Remove the registration of FCN as a listener for the property PROP of
the graphi



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
det


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 501
 -- Built-in Function: det (A)
 -- Built-in Function: [D, RCOND] = det (A)
     Compute the determinant of A.

     Return an estimate of the reciprocal condition number if requested.

     Routines from LAPACK are used for full matrices and code from
     UMFPACK is used for sparse matrices.

     The determinant should not be used to check a matrix for
     singularity.  For that, use any of the condition number functions:
     'cond', 'condest', 'rcond'.

     See also: cond, condest, rcond.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
Compute the determinant of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
diag


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 928
 -- Built-in Function: M = diag (V)
 -- Built-in Function: M = diag (V, K)
 -- Built-in Function: M = diag (V, M, N)
 -- Built-in Function: V = diag (M)
 -- Built-in Function: V = diag (M, K)
     Return a diagonal matrix with vector V on diagonal K.  The second
     argument is optional.  If it is positive, the vector is placed on
     the K-th super-diagonal.  If it is negative, it is placed on the
     -K-th sub-diagonal.  The default value of K is 0, and the vector is
     placed on the main diagonal.  For example:

          diag ([1, 2, 3], 1)
             =>  0  1  0  0
                 0  0  2  0
                 0  0  0  3
                 0  0  0  0

     The 3-input form returns a diagonal matrix with vector V on the
     main diagonal and the resulting matrix being of size M rows x N
     columns.

     Given a matrix argument, instead of a vector, 'diag' extracts the
     K-th diagonal of the matrix.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Return a diagonal matrix with vector V on diagonal K.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
diary


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 584
 -- Command: diary
 -- Command: diary on
 -- Command: diary off
 -- Command: diary FILENAME
     Record a list of all commands _and_ the output they produce, mixed
     together just as they appear on the terminal.

     Valid options are:

     on
          Start recording a session in a file called 'diary' in the
          current working directory.

     off
          Stop recording the session in the diary file.

     FILENAME
          Record the session in the file named FILENAME.

     With no arguments, 'diary' toggles the current diary state.

     See also: history.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Record a list of all commands _and_ the output they produce, mixed
together just



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
diff


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 988
 -- Built-in Function: diff (X)
 -- Built-in Function: diff (X, K)
 -- Built-in Function: diff (X, K, DIM)
     If X is a vector of length n, 'diff (X)' is the vector of first
     differences X(2) - X(1), ..., X(n) - X(n-1).

     If X is a matrix, 'diff (X)' is the matrix of column differences
     along the first non-singleton dimension.

     The second argument is optional.  If supplied, 'diff (X, K)', where
     K is a non-negative integer, returns the K-th differences.  It is
     possible that K is larger than the first non-singleton dimension of
     the matrix.  In this case, 'diff' continues to take the differences
     along the next non-singleton dimension.

     The dimension along which to take the difference can be explicitly
     stated with the optional variable DIM.  In this case the K-th order
     differences are calculated along this dimension.  In the case where
     K exceeds 'size (X, DIM)' an empty matrix is returned.

     See also: sort, merge.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If X is a vector of length n, 'diff (X)' is the vector of first
differences X(2)



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
disp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 393
 -- Built-in Function: disp (X)
     Display the value of X.  For example:

          disp ("The value of pi is:"), disp (pi)

               -| the value of pi is:
               -| 3.1416

     Note that the output from 'disp' always ends with a newline.

     If an output value is requested, 'disp' prints nothing and returns
     the formatted output in a string.

     See also: fdisp.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Display the value of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
dlmread


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1339
 -- Built-in Function: DATA = dlmread (FILE)
 -- Built-in Function: DATA = dlmread (FILE, SEP)
 -- Built-in Function: DATA = dlmread (FILE, SEP, R0, C0)
 -- Built-in Function: DATA = dlmread (FILE, SEP, RANGE)
 -- Built-in Function: DATA = dlmread (..., "emptyvalue", EMPTYVAL)
     Read the matrix DATA from a text file.  If not defined the
     separator between fields is determined from the file itself.
     Otherwise the separation character is defined by SEP.

     Given two scalar arguments R0 and C0, these define the starting row
     and column of the data to be read.  These values are indexed from
     zero, such that the first row corresponds to an index of zero.

     The RANGE parameter may be a 4-element vector containing the upper
     left and lower right corner '[R0,C0,R1,C1]' where the lowest index
     value is zero.  Alternatively, a spreadsheet style range such as
     "A2..Q15" or "T1:AA5" can be used.  The lowest alphabetical index
     'A' refers to the first column.  The lowest row index is 1.

     FILE should be a file name or file id given by 'fopen'.  In the
     latter case, the file is read until end of file is reached.

     The "emptyvalue" option may be used to specify the value used to
     fill empty fields.  The default is zero.

     See also: csvread, textscan, textread, dlmwrite.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Read the matrix DATA from a text file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
do_braindead_shortcircuit_evaluation


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 959
 -- Built-in Function: VAL = do_braindead_shortcircuit_evaluation ()
 -- Built-in Function: OLD_VAL = do_braindead_shortcircuit_evaluation
          (NEW_VAL)
 -- Built-in Function: do_braindead_shortcircuit_evaluation (NEW_VAL,
          "local")
     Query or set the internal variable that controls whether Octave
     will do short-circuit evaluation of '|' and '&' operators inside
     the conditions of if or while statements.

     This feature is only provided for compatibility with MATLAB and
     should not be used unless you are porting old code that relies on
     this feature.

     To obtain short-circuit behavior for logical expressions in new
     programs, you should always use the '&&' and '||' operators.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that controls whether Octave will do
short-ci



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
do_string_escapes


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 117
 -- Built-in Function: do_string_escapes (STRING)
     Convert special characters in STRING to their escaped forms.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Convert special characters in STRING to their escaped forms.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
doc_cache_file


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1030
 -- Built-in Function: VAL = doc_cache_file ()
 -- Built-in Function: OLD_VAL = doc_cache_file (NEW_VAL)
 -- Built-in Function: doc_cache_file (NEW_VAL, "local")
     Query or set the internal variable that specifies the name of the
     Octave documentation cache file.  A cache file significantly
     improves the performance of the 'lookfor' command.  The default
     value is 'OCTAVE-HOME/share/octave/VERSION/etc/doc-cache', in which
     OCTAVE-HOME is the root directory of the Octave installation, and
     VERSION is the Octave version number.  The default value may be
     overridden by the environment variable 'OCTAVE_DOC_CACHE_FILE', or
     the command line argument '--doc-cache-file FNAME'.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: doc_cache_create, lookfor, info_program, doc, help,
     makeinfo_program.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that specifies the name of the Octave
documen



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
dot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 507
 -- Built-in Function: dot (X, Y, DIM)
     Compute the dot product of two vectors.  If X and Y are matrices,
     calculate the dot products along the first non-singleton dimension.
     If the optional argument DIM is given, calculate the dot products
     along this dimension.

     This is equivalent to 'sum (conj (X) .* Y, DIM)', but avoids
     forming a temporary array and is faster.  When X and Y are column
     vectors, the result is equivalent to 'X' * Y'.

     See also: cross, divergence.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Compute the dot product of two vectors.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
double


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 100
 -- Built-in Function: double (X)
     Convert X to double precision type.

     See also: single.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Convert X to double precision type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
drawnow


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 470
 -- Built-in Function: drawnow ()
 -- Built-in Function: drawnow ("expose")
 -- Built-in Function: drawnow (TERM, FILE, MONO, DEBUG_FILE)
     Update figure windows and their children.  The event queue is
     flushed and any callbacks generated are executed.  With the
     optional argument "expose", only graphic objects are updated and no
     other events or callbacks are processed.  The third calling form of
     'drawnow' is for debugging and is undocumented.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Update figure windows and their children.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
dup2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 252
 -- Built-in Function: [FID, MSG] = dup2 (OLD, NEW)
     Duplicate a file descriptor.

     If successful, FID is greater than zero and contains the new file
     ID.  Otherwise, FID is negative and MSG contains a system-dependent
     error message.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Duplicate a file descriptor.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
e


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 846
 -- Built-in Function: e
 -- Built-in Function: e (N)
 -- Built-in Function: e (N, M)
 -- Built-in Function: e (N, M, K, ...)
 -- Built-in Function: e (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are
     all equal to the base of natural logarithms.  The constant 'e'
     satisfies the equation 'log' (e) = 1.

     When called with no arguments, return a scalar with the value e.
     When called with a single argument, return a square matrix with the
     dimension specified.  When called with more than one scalar
     argument the first two arguments are taken as the number of rows
     and columns and any further arguments specify additional matrix
     dimensions.  The optional argument CLASS specifies the return type
     and may be either "double" or "single".

     See also: log, exp, pi, I.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a scalar, matrix, or N-dimensional array whose elements are all
equal to 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
echo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 606
 -- Command: echo options
     Control whether commands are displayed as they are executed.  Valid
     options are:

     'on'
          Enable echoing of commands as they are executed in script
          files.

     'off'
          Disable echoing of commands as they are executed in script
          files.

     'on all'
          Enable echoing of commands as they are executed in script
          files and functions.

     'off all'
          Disable echoing of commands as they are executed in script
          files and functions.

     With no arguments, 'echo' toggles the current echo state.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Control whether commands are displayed as they are executed.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
echo_executing_commands


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 950
 -- Built-in Function: VAL = echo_executing_commands ()
 -- Built-in Function: OLD_VAL = echo_executing_commands (NEW_VAL)
 -- Built-in Function: echo_executing_commands (NEW_VAL, "local")
     Query or set the internal variable that controls the echo state.
     It may be the sum of the following values:

     1
          Echo commands read from script files.

     2
          Echo commands from functions.

     4
          Echo commands read from command line.

     More than one state can be active at once.  For example, a value of
     3 is equivalent to the command 'echo on all'.

     The value of 'echo_executing_commands' may be set by the 'echo'
     command or the command line option '--echo-commands'.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Query or set the internal variable that controls the echo state.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
edit_history


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1345
 -- Command: edit_history
 -- Command: edit_history CMD_NUMBER
 -- Command: edit_history FIRST LAST
     Edit the history list using the editor named by the variable
     'EDITOR'.

     The commands to be edited are first copied to a temporary file.
     When you exit the editor, Octave executes the commands that remain
     in the file.  It is often more convenient to use 'edit_history' to
     define functions rather than attempting to enter them directly on
     the command line.  The block of commands is executed as soon as you
     exit the editor.  To avoid executing any commands, simply delete
     all the lines from the buffer before leaving the editor.

     When invoked with no arguments, edit the previously executed
     command; With one argument, edit the specified command CMD_NUMBER;
     With two arguments, edit the list of commands between FIRST and
     LAST.  Command number specifiers may also be negative where -1
     refers to the most recently executed command.  The following are
     equivalent and edit the most recently executed command.

          edit_history
          edit_history -1

     When using ranges, specifying a larger number for the first command
     than the last command reverses the list of commands before they are
     placed in the buffer to be edited.

     See also: run_history.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Edit the history list using the editor named by the variable 'EDITOR'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
eig


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 549
 -- Built-in Function: LAMBDA = eig (A)
 -- Built-in Function: LAMBDA = eig (A, B)
 -- Built-in Function: [V, LAMBDA] = eig (A)
 -- Built-in Function: [V, LAMBDA] = eig (A, B)
     Compute the eigenvalues (and optionally the eigenvectors) of a
     matrix or a pair of matrices

     The algorithm used depends on whether there are one or two input
     matrices, if they are real or complex and if they are symmetric
     (Hermitian if complex) or non-symmetric.

     The eigenvalues returned by 'eig' are not ordered.

     See also: eigs, svd.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the eigenvalues (and optionally the eigenvectors) of a matrix or
a pair 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ellipj


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1196
 -- Built-in Function: [SN, CN, DN, ERR] = ellipj (U, M)
 -- Built-in Function: [SN, CN, DN, ERR] = ellipj (U, M, TOL)
     Compute the Jacobi elliptic functions SN, CN, and DN of complex
     argument U and real parameter M.

     If M is a scalar, the results are the same size as U.  If U is a
     scalar, the results are the same size as M.  If U is a column
     vector and M is a row vector, the results are matrices with 'length
     (U)' rows and 'length (M)' columns.  Otherwise, U and M must
     conform in size and the results will be the same size as the
     inputs.

     The value of U may be complex.  The value of M must be 0 <= M <= 1.

     The optional input TOL is currently ignored (MATLAB uses this to
     allow faster, less accurate approximation).

     If requested, ERR contains the following status information and is
     the same size as the result.

       0. Normal return.

       1. Error--no computation, algorithm termination condition not
          met, return 'NaN'.

     Reference: Milton Abramowitz and Irene A Stegun, 'Handbook of
     Mathematical Functions', Chapter 16 (Sections 16.4, 16.13, and
     16.15), Dover, 1965.

     See also: ellipke.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the Jacobi elliptic functions SN, CN, and DN of complex argument
U and r



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
end


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 296
 -- Built-in Function: end
     The magic index "end" refers to the last valid entry in an indexing
     operation.

     Example:

          X = [ 1 2 3
                4 5 6 ];
          X(1,end)
              => 3
          X(end,1)
              => 4
          X(end,end)
              => 6




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 78
The magic index "end" refers to the last valid entry in an indexing
operation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
endgrent


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
 -- Built-in Function: endgrent ()
     Close the group database.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
Close the group database.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
endpwent


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
 -- Built-in Function: endpwent ()
     Close the password database.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Close the password database.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
eps


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1136
 -- Built-in Function: eps
 -- Built-in Function: eps (X)
 -- Built-in Function: eps (N, M)
 -- Built-in Function: eps (N, M, K, ...)
 -- Built-in Function: eps (..., CLASS)
     Return a scalar, matrix or N-dimensional array whose elements are
     all eps, the machine precision.  More precisely, 'eps' is the
     relative spacing between any two adjacent numbers in the machine's
     floating point system.  This number is obviously system dependent.
     On machines that support IEEE floating point arithmetic, 'eps' is
     approximately 2.2204e-16 for double precision and 1.1921e-07 for
     single precision.

     When called with no arguments, return a scalar with the value 'eps
     (1.0)'.  Given a single argument X, return the distance between X
     and the next largest value.  When called with more than one
     argument the first two arguments are taken as the number of rows
     and columns and any further arguments specify additional matrix
     dimensions.  The optional argument CLASS specifies the return type
     and may be either "double" or "single".

     See also: realmax, realmin, intmax, bitmax.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a scalar, matrix or N-dimensional array whose elements are all
eps, the m



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
eq


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 176
 -- Built-in Function: eq (X, Y)
     Return true if the two inputs are equal.  This function is
     equivalent to 'x == y'.

     See also: ne, isequal, le, ge, gt, ne, lt.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Return true if the two inputs are equal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
erf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 312
 -- Mapping Function: erf (Z)
     Compute the error function,

                                  z
                        2        /
          erf (z) = --------- *  | e^(-t^2) dt
                    sqrt (pi)    /
                              t=0

     See also: erfc, erfcx, erfi, dawson, erfinv, erfcinv.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Compute the error function,



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
erfc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 153
 -- Mapping Function: erfc (Z)
     Compute the complementary error function, '1 - erf (Z)'.

     See also: erfcinv, erfcx, erfi, dawson, erf, erfinv.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Compute the complementary error function, '1 - erf (Z)'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
erfcinv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 189
 -- Mapping Function: erfcinv (X)
     Compute the inverse complementary error function, i.e., Y such that

          erfc (Y) == X

     See also: erfc, erf, erfcx, erfi, dawson, erfinv.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Compute the inverse complementary error function, i.e., Y such that



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
erfcx


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 177
 -- Mapping Function: erfcx (Z)
     Compute the scaled complementary error function,

          exp (z^2) * erfc (z)

     See also: erfc, erf, erfi, dawson, erfinv, erfcinv.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Compute the scaled complementary error function,



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
erfi


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 160
 -- Mapping Function: erfi (Z)
     Compute the imaginary error function,

          -i * erf (i*z)

     See also: erfc, erf, erfcx, dawson, erfinv, erfcinv.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Compute the imaginary error function,



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
erfinv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 174
 -- Mapping Function: erfinv (X)
     Compute the inverse error function, i.e., Y such that

          erf (Y) == X

     See also: erf, erfc, erfcx, erfi, dawson, erfcinv.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Compute the inverse error function, i.e., Y such that



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
errno


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 352
 -- Built-in Function: ERR = errno ()
 -- Built-in Function: ERR = errno (VAL)
 -- Built-in Function: ERR = errno (NAME)
     Return the current value of the system-dependent variable errno,
     set its value to VAL and return the previous value, or return the
     named error code given NAME as a character string, or -1 if NAME is
     not found.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the current value of the system-dependent variable errno, set its
value t



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
errno_list


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 108
 -- Built-in Function: errno_list ()
     Return a structure containing the system-dependent errno values.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Return a structure containing the system-dependent errno values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
error


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2729
 -- Built-in Function: error (TEMPLATE, ...)
 -- Built-in Function: error (ID, TEMPLATE, ...)
     Format the optional arguments under the control of the template
     string TEMPLATE using the same rules as the 'printf' family of
     functions (*note Formatted Output::) and print the resulting
     message on the 'stderr' stream.  The message is prefixed by the
     character string 'error: '.

     Calling 'error' also sets Octave's internal error state such that
     control will return to the top level without evaluating any more
     commands.  This is useful for aborting from functions or scripts.

     If the error message does not end with a new line character, Octave
     will print a traceback of all the function calls leading to the
     error.  For example, given the following function definitions:

          function f () g (); end
          function g () h (); end
          function h () nargin == 1 || error ("nargin != 1"); end

     calling the function 'f' will result in a list of messages that can
     help you to quickly locate the exact location of the error:

          f ()
          error: nargin != 1
          error: called from:
          error:   error at line -1, column -1
          error:   h at line 1, column 27
          error:   g at line 1, column 15
          error:   f at line 1, column 15

     If the error message ends in a new line character, Octave will
     print the message but will not display any traceback messages as it
     returns control to the top level.  For example, modifying the error
     message in the previous example to end in a new line causes Octave
     to only print a single message:

          function h () nargin == 1 || error ("nargin != 1\n"); end
          f ()
          error: nargin != 1

     A null string ("") input to 'error' will be ignored and the code
     will continue running as if the statement were a NOP.  This is for
     compatibility with MATLAB.  It also makes it possible to write code
     such as

          err_msg = "";
          if (CONDITION 1)
            err_msg = "CONDITION 1 found";
          elseif (CONDITION2)
            err_msg = "CONDITION 2 found";
          ...
          endif
          error (err_msg);

     which will only stop execution if an error has been found.

     Implementation Note: For compatibility with MATLAB, escape
     sequences (e.g., "\n" => newline) are processed in TEMPLATE
     regardless of whether TEMPLATE has been defined within single
     quotes as long as there are two or more input arguments.  Use a
     second backslash to stop interpolation of the escape sequence
     (e.g., "\\n") or use the 'regexptranslate' function.

     See also: warning, lasterror.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Format the optional arguments under the control of the template string
TEMPLATE 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
eval


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1224
 -- Built-in Function: eval (TRY)
 -- Built-in Function: eval (TRY, CATCH)
     Parse the string TRY and evaluate it as if it were an Octave
     program.  If that fails, evaluate the optional string CATCH.  The
     string TRY is evaluated in the current context, so any results
     remain available after 'eval' returns.

     The following example creates the variable A with the approximate
     value of 3.1416 in the current workspace.

          eval ("A = acos(-1);");

     If an error occurs during the evaluation of TRY then the CATCH
     string is evaluated, as the following example shows:

          eval ('error ("This is a bad example");',
                'printf ("This error occurred:\n%s\n", lasterr ());');
               -| This error occurred:
                  This is a bad example

     Programming Note: if you are only using 'eval' as an
     error-capturing mechanism, rather than for the execution of
     arbitrary code strings, Consider using try/catch blocks or
     unwind_protect/unwind_protect_cleanup blocks instead.  These
     techniques have higher performance and don't introduce the security
     considerations that the evaluation of arbitrary code does.

     See also: evalin.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Parse the string TRY and evaluate it as if it were an Octave program.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
evalin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 259
 -- Built-in Function: evalin (CONTEXT, TRY)
 -- Built-in Function: evalin (CONTEXT, TRY, CATCH)
     Like 'eval', except that the expressions are evaluated in the
     context CONTEXT, which may be either "caller" or "base".

     See also: eval, assignin.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Like 'eval', except that the expressions are evaluated in the context
CONTEXT, w



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
exec


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 503
 -- Built-in Function: [ERR, MSG] = exec (FILE, ARGS)
     Replace current process with a new process.  Calling 'exec' without
     first calling 'fork' will terminate your current Octave process and
     replace it with the program named by FILE.  For example,

          exec ("ls" "-l")

     will run 'ls' and return you to your shell prompt.

     If successful, 'exec' does not return.  If 'exec' does return, ERR
     will be nonzero, and MSG will contain a system-dependent error
     message.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Replace current process with a new process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
exist


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1165
 -- Built-in Function: exist (NAME, TYPE)
     Return 1 if the name exists as a variable, 2 if the name is an
     absolute file name, an ordinary file in Octave's 'path', or (after
     appending '.m') a function file in Octave's 'path', 3 if the name
     is a '.oct' or '.mex' file in Octave's 'path', 5 if the name is a
     built-in function, 7 if the name is a directory, or 103 if the name
     is a function not associated with a file (entered on the command
     line).

     Otherwise, return 0.

     This function also returns 2 if a regular file called NAME exists
     in Octave's search path.  If you want information about other types
     of files, you should use some combination of the functions
     'file_in_path' and 'stat' instead.

     If the optional argument TYPE is supplied, check only for symbols
     of the specified type.  Valid types are

     "var"
          Check only for variables.

     "builtin"
          Check only for built-in functions.

     "file"
          Check only for files and directories.

     "dir"
          Check only for directories.

     See also: file_in_loadpath, file_in_path, find_dir_in_path, stat.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return 1 if the name exists as a variable, 2 if the name is an absolute
file nam



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
exit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 271
 -- Built-in Function: exit (STATUS)
 -- Built-in Function: quit (STATUS)
     Exit the current Octave session.  If the optional integer value
     STATUS is supplied, pass that value to the operating system as the
     Octave's exit status.  The default value is zero.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Exit the current Octave session.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
exp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 163
 -- Mapping Function: exp (X)
     Compute 'e^x' for each element of X.  To compute the matrix
     exponential, see *note Linear Algebra::.

     See also: log.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Compute 'e^x' for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
expm1


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 121
 -- Mapping Function: expm1 (X)
     Compute 'exp (X) - 1' accurately in the neighborhood of zero.

     See also: exp.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Compute 'exp (X) - 1' accurately in the neighborhood of zero.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
eye


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1143
 -- Built-in Function: eye (N)
 -- Built-in Function: eye (M, N)
 -- Built-in Function: eye ([M N])
 -- Built-in Function: eye (..., CLASS)
     Return an identity matrix.  If invoked with a single scalar
     argument N, return a square NxN identity matrix.  If supplied two
     scalar arguments (M, N), 'eye' takes them to be the number of rows
     and columns.  If given a vector with two elements, 'eye' uses the
     values of the elements as the number of rows and columns,
     respectively.  For example:

          eye (3)
           =>  1  0  0
               0  1  0
               0  0  1

     The following expressions all produce the same result:

          eye (2)
          ==
          eye (2, 2)
          ==
          eye (size ([1, 2; 3, 4])

     The optional argument CLASS, allows 'eye' to return an array of the
     specified type, like

          val = zeros (n,m, "uint8")

     Calling 'eye' with no arguments is equivalent to calling it with an
     argument of 1.  Any negative dimensions are treated as zero.  These
     odd definitions are for compatibility with MATLAB.

     See also: speye, ones, zeros.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Return an identity matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
false


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 456
 -- Built-in Function: false (X)
 -- Built-in Function: false (N, M)
 -- Built-in Function: false (N, M, K, ...)
     Return a matrix or N-dimensional array whose elements are all
     logical 0.  If invoked with a single scalar integer argument,
     return a square matrix of the specified size.  If invoked with two
     or more scalar integer arguments, or a vector of integer values,
     return an array with given dimensions.

     See also: true.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Return a matrix or N-dimensional array whose elements are all logical 0.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
fclear


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 112
 -- Built-in Function: fclear (FID)
     Clear the stream state for the specified file.

     See also: fopen.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Clear the stream state for the specified file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
fclose


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 310
 -- Built-in Function: fclose (FID)
 -- Built-in Function: fclose ("all")
     Close the specified file.  If successful, 'fclose' returns 0,
     otherwise, it returns -1.  The second form of the 'fclose' call
     closes all open files except 'stdout', 'stderr', and 'stdin'.

     See also: fopen, freport.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
Close the specified file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fcntl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1350
 -- Built-in Function: [ERR, MSG] = fcntl (FID, REQUEST, ARG)
     Change the properties of the open file FID.  The following values
     may be passed as REQUEST:

     'F_DUPFD'
          Return a duplicate file descriptor.

     'F_GETFD'
          Return the file descriptor flags for FID.

     'F_SETFD'
          Set the file descriptor flags for FID.

     'F_GETFL'
          Return the file status flags for FID.  The following codes may
          be returned (some of the flags may be undefined on some
          systems).

          'O_RDONLY'
               Open for reading only.

          'O_WRONLY'
               Open for writing only.

          'O_RDWR'
               Open for reading and writing.

          'O_APPEND'
               Append on each write.

          'O_CREAT'
               Create the file if it does not exist.

          'O_NONBLOCK'
               Non-blocking mode.

          'O_SYNC'
               Wait for writes to complete.

          'O_ASYNC'
               Asynchronous I/O.

     'F_SETFL'
          Set the file status flags for FID to the value specified by
          ARG.  The only flags that can be changed are 'O_APPEND' and
          'O_NONBLOCK'.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise, ERR
     is nonzero and MSG contains a system-dependent error message.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Change the properties of the open file FID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fdisp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 323
 -- Built-in Function: fdisp (FID, X)
     Display the value of X on the stream FID.  For example:

          fdisp (stdout, "The value of pi is:"), fdisp (stdout, pi)

               -| the value of pi is:
               -| 3.1416

     Note that the output from 'fdisp' always ends with a newline.

     See also: disp.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Display the value of X on the stream FID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
feof


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 335
 -- Built-in Function: feof (FID)
     Return 1 if an end-of-file condition has been encountered for a
     given file and 0 otherwise.  Note that it will only return 1 if the
     end of the file has already been encountered, not if the next read
     operation will result in an end-of-file condition.

     See also: fread, fopen.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return 1 if an end-of-file condition has been encountered for a given
file and 0



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ferror


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 480
 -- Built-in Function: [ERR, MSG] = ferror (FID)
 -- Built-in Function: [ERR, MSG] = ferror (FID, "clear")
     Return 1 if an error condition has been encountered for the file ID
     FID and 0 otherwise.  Note that it will only return 1 if an error
     has already been encountered, not if the next operation will result
     in an error condition.

     The second argument is optional.  If it is supplied, also clear the
     error condition.

     See also: fclear, fopen.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return 1 if an error condition has been encountered for the file ID FID
and 0 ot



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
feval


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 924
 -- Built-in Function: feval (NAME, ...)
     Evaluate the function named NAME.  Any arguments after the first
     are passed as inputs to the named function.  For example,

          feval ("acos", -1)
               => 3.1416

     calls the function 'acos' with the argument '-1'.

     The function 'feval' can also be used with function handles of any
     sort (*note Function Handles::).  Historically, 'feval' was the
     only way to call user-supplied functions in strings, but function
     handles are now preferred due to the cleaner syntax they offer.
     For example,

          F = @exp;
          feval (F, 1)
              => 2.7183
          F (1)
              => 2.7183

     are equivalent ways to call the function referred to by F.  If it
     cannot be predicted beforehand whether F is a function handle,
     function name in a string, or inline function then 'feval' can be
     used instead.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Evaluate the function named NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
fflush


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 412
 -- Built-in Function: fflush (FID)
     Flush output to FID.  This is useful for ensuring that all pending
     output makes it to the screen before some other event occurs.  For
     example, it is always a good idea to flush the standard output
     stream before calling 'input'.

     'fflush' returns 0 on success and an OS dependent error value (-1
     on Unix) on error.

     See also: fopen, fclose.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
Flush output to FID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
fft


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 962
 -- Built-in Function: fft (X)
 -- Built-in Function: fft (X, N)
 -- Built-in Function: fft (X, N, DIM)
     Compute the discrete Fourier transform of A using a Fast Fourier
     Transform (FFT) algorithm.

     The FFT is calculated along the first non-singleton dimension of
     the array.  Thus if X is a matrix, 'fft (X)' computes the FFT for
     each column of X.

     If called with two arguments, N is expected to be an integer
     specifying the number of elements of X to use, or an empty matrix
     to specify that its value should be ignored.  If N is larger than
     the dimension along which the FFT is calculated, then X is resized
     and padded with zeros.  Otherwise, if N is smaller than the
     dimension along which the FFT is calculated, then X is truncated.

     If called with three arguments, DIM is an integer specifying the
     dimension of the matrix along which the FFT is performed

     See also: ifft, fft2, fftn, fftw.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the discrete Fourier transform of A using a Fast Fourier
Transform (FFT)



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
fft2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 533
 -- Built-in Function: fft2 (A)
 -- Built-in Function: fft2 (A, M, N)
     Compute the two-dimensional discrete Fourier transform of A using a
     Fast Fourier Transform (FFT) algorithm.

     The optional arguments M and N may be used specify the number of
     rows and columns of A to use.  If either of these is larger than
     the size of A, A is resized and padded with zeros.

     If A is a multi-dimensional matrix, each two-dimensional sub-matrix
     of A is treated separately.

     See also: ifft2, fft, fftn, fftw.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the two-dimensional discrete Fourier transform of A using a Fast
Fourier



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
fftn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 609
 -- Built-in Function: fftn (A)
 -- Built-in Function: fftn (A, SIZE)
     Compute the N-dimensional discrete Fourier transform of A using a
     Fast Fourier Transform (FFT) algorithm.

     The optional vector argument SIZE may be used specify the
     dimensions of the array to be used.  If an element of SIZE is
     smaller than the corresponding dimension of A, then the dimension
     of A is truncated prior to performing the FFT.  Otherwise, if an
     element of SIZE is larger than the corresponding dimension then A
     is resized and padded with zeros.

     See also: ifftn, fft, fft2, fftw.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the N-dimensional discrete Fourier transform of A using a Fast
Fourier T



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fgetl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 543
 -- Built-in Function: STR = fgetl (FID)
 -- Built-in Function: STR = fgetl (FID, LEN)
     Read characters from a file, stopping after a newline, or EOF, or
     LEN characters have been read.  The characters read, excluding the
     possible trailing newline, are returned as a string.

     If LEN is omitted, 'fgetl' reads until the next newline character.

     If there are no more characters to read, 'fgetl' returns -1.

     To read a line and return the terminating newline see 'fgets'.

     See also: fgets, fscanf, fread, fopen.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Read characters from a file, stopping after a newline, or EOF, or LEN
characters



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fgets


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 551
 -- Built-in Function: STR = fgets (FID)
 -- Built-in Function: STR = fgets (FID, LEN)
     Read characters from a file, stopping after a newline, or EOF, or
     LEN characters have been read.  The characters read, including the
     possible trailing newline, are returned as a string.

     If LEN is omitted, 'fgets' reads until the next newline character.

     If there are no more characters to read, 'fgets' returns -1.

     To read a line and discard the terminating newline see 'fgetl'.

     See also: fputs, fgetl, fscanf, fread, fopen.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Read characters from a file, stopping after a newline, or EOF, or LEN
characters



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
file_in_loadpath


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 706
 -- Built-in Function: file_in_loadpath (FILE)
 -- Built-in Function: file_in_loadpath (FILE, "all")

     Return the absolute name of FILE if it can be found in the list of
     directories specified by 'path'.  If no file is found, return an
     empty character string.

     If the first argument is a cell array of strings, search each
     directory of the loadpath for element of the cell array and return
     the first that matches.

     If the second optional argument "all" is supplied, return a cell
     array containing the list of all files that have the same name in
     the path.  If no files are found, return an empty cell array.

     See also: file_in_path, find_dir_in_path, path.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the absolute name of FILE if it can be found in the list of
directories s



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
file_in_path


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 862
 -- Built-in Function: file_in_path (PATH, FILE)
 -- Built-in Function: file_in_path (PATH, FILE, "all")
     Return the absolute name of FILE if it can be found in PATH.  The
     value of PATH should be a colon-separated list of directories in
     the format described for 'path'.  If no file is found, return an
     empty character string.  For example:

          file_in_path (EXEC_PATH, "sh")
               => "/bin/sh"

     If the second argument is a cell array of strings, search each
     directory of the path for element of the cell array and return the
     first that matches.

     If the third optional argument "all" is supplied, return a cell
     array containing the list of all files that have the same name in
     the path.  If no files are found, return an empty cell array.

     See also: file_in_loadpath, find_dir_in_path, path.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Return the absolute name of FILE if it can be found in PATH.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
filemarker


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1010
 -- Built-in Function: VAL = filemarker ()
 -- Built-in Function: filemarker (NEW_VAL)
 -- Built-in Function: filemarker (NEW_VAL, "local")
     Query or set the character used to separate filename from the the
     subfunction names contained within the file.  This can be used in a
     generic manner to interact with subfunctions.  For example,

          help (["myfunc", filemarker, "mysubfunc"])

     returns the help string associated with the subfunction 'mysubfunc'
     of the function 'myfunc'.  Another use of 'filemarker' is when
     debugging it allows easier placement of breakpoints within
     subfunctions.  For example,

          dbstop (["myfunc", filemarker, "mysubfunc"])

     will set a breakpoint at the first line of the subfunction
     'mysubfunc'.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the character used to separate filename from the the
subfunction na



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
filesep


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 452
 -- Built-in Function: filesep ()
 -- Built-in Function: filesep ("all")
     Return the system-dependent character used to separate directory
     names.

     If "all" is given, the function returns all valid file separators
     in the form of a string.  The list of file separators is
     system-dependent.  It is '/' (forward slash) under UNIX or
     Mac OS X, '/' and '\' (forward and backward slashes) under Windows.

     See also: pathsep.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Return the system-dependent character used to separate directory names.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
filter


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1609
 -- Built-in Function: y = filter (B, A, X)
 -- Built-in Function: [Y, SF] = filter (B, A, X, SI)
 -- Built-in Function: [Y, SF] = filter (B, A, X, [], DIM)
 -- Built-in Function: [Y, SF] = filter (B, A, X, SI, DIM)
     Return the solution to the following linear, time-invariant
     difference equation:

           N                   M
          SUM a(k+1) y(n-k) = SUM b(k+1) x(n-k)    for 1<=n<=length(x)
          k=0                 k=0

     where N=length(a)-1 and M=length(b)-1.  The result is calculated
     over the first non-singleton dimension of X or over DIM if
     supplied.

     An equivalent form of the equation is:

                    N                   M
          y(n) = - SUM c(k+1) y(n-k) + SUM d(k+1) x(n-k)  for 1<=n<=length(x)
                   k=1                 k=0

     where c = a/a(1) and d = b/a(1).

     If the fourth argument SI is provided, it is taken as the initial
     state of the system and the final state is returned as SF.  The
     state vector is a column vector whose length is equal to the length
     of the longest coefficient vector minus one.  If SI is not
     supplied, the initial state vector is set to all zeros.

     In terms of the Z Transform, y is the result of passing the
     discrete- time signal x through a system characterized by the
     following rational system function:

                    M
                   SUM d(k+1) z^(-k)
                   k=0
          H(z) = ---------------------
                      N
                 1 + SUM c(k+1) z^(-k)
                     k=1

     See also: filter2, fftfilt, freqz.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the solution to the following linear, time-invariant difference
equation:



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
find


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1735
 -- Built-in Function: IDX = find (X)
 -- Built-in Function: IDX = find (X, N)
 -- Built-in Function: IDX = find (X, N, DIRECTION)
 -- Built-in Function: [i, j] = find (...)
 -- Built-in Function: [i, j, v] = find (...)
     Return a vector of indices of nonzero elements of a matrix, as a
     row if X is a row vector or as a column otherwise.  To obtain a
     single index for each matrix element, Octave pretends that the
     columns of a matrix form one long vector (like Fortran arrays are
     stored).  For example:

          find (eye (2))
            => [ 1; 4 ]

     If two outputs are requested, 'find' returns the row and column
     indices of nonzero elements of a matrix.  For example:

          [i, j] = find (2 * eye (2))
              => i = [ 1; 2 ]
              => j = [ 1; 2 ]

     If three outputs are requested, 'find' also returns a vector
     containing the nonzero values.  For example:

          [i, j, v] = find (3 * eye (2))
                 => i = [ 1; 2 ]
                 => j = [ 1; 2 ]
                 => v = [ 3; 3 ]

     If two inputs are given, N indicates the maximum number of elements
     to find from the beginning of the matrix or vector.

     If three inputs are given, DIRECTION should be one of "first" or
     "last", requesting only the first or last N indices, respectively.
     However, the indices are always returned in ascending order.

     Note that this function is particularly useful for sparse matrices,
     as it extracts the non-zero elements as vectors, which can then be
     used to create the original matrix.  For example:

          sz = size (a);
          [i, j, v] = find (a);
          b = sparse (i, j, v, sz(1), sz(2));

     See also: nonzeros.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a vector of indices of nonzero elements of a matrix, as a row if
X is a r



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
find_dir_in_path


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 566
 -- Built-in Function: find_dir_in_path (DIR)
 -- Built-in Function: find_dir_in_path (DIR, "all")
     Return the full name of the path element matching DIR.  The match
     is performed at the end of each path element.  For example, if DIR
     is "foo/bar", it matches the path element "/some/dir/foo/bar", but
     not "/some/dir/foo/bar/baz" "/some/dir/allfoo/bar".

     The second argument is optional.  If it is supplied, return a cell
     array containing all name matches rather than just the first.

     See also: file_in_path, file_in_loadpath, path.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Return the full name of the path element matching DIR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
finite


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 310
 -- Mapping Function: isfinite (X)
 -- Mapping Function: finite (X)
     Return a logical array which is true where the elements of X are
     finite values and false where they are not.  For example:

          finite ([13, Inf, NA, NaN])
               => [ 1, 0, 0, 0 ]

     See also: isinf, isnan, isna.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a logical array which is true where the elements of X are finite
values a



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
fix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 309
 -- Mapping Function: fix (X)
     Truncate fractional portion of X and return the integer portion.
     This is equivalent to rounding towards zero.  If X is complex,
     return 'fix (real (X)) + fix (imag (X)) * I'.

          fix ([-2.7, 2.7])
             => -2    2

     See also: ceil, floor, round.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Truncate fractional portion of X and return the integer portion.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
fixed_point_format


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1134
 -- Built-in Function: VAL = fixed_point_format ()
 -- Built-in Function: OLD_VAL = fixed_point_format (NEW_VAL)
 -- Built-in Function: fixed_point_format (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave
     will use a scaled format to print matrix values.

     The scaled format prints a scaling factor on the first line of
     output chosen such that the largest matrix element can be written
     with a single leading digit.  For example:

          logspace (1, 7, 5)'
          ans =

            1.0e+07  *

            0.00000
            0.00003
            0.00100
            0.03162
            1.00000

     Notice that the first value appears to be 0 when it is actually 1.
     Because of the possibilty for confusion you should be careful about
     enabling 'fixed_point_format'.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: format, output_max_field_width, output_precision.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that controls whether Octave will use
a scale



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
flintmax


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 436
 -- Built-in Function: flintmax ()
 -- Built-in Function: flintmax ("double")
 -- Built-in Function: flintmax ("single")
     Return the largest integer that can be represented consecutively in
     a floating point value.  The default class is "double", but
     "single" is a valid option.  On IEEE-754 compatible systems,
     'flintmax' is 2^53 for "double" and 2^24 for "single".

     See also: bitmax, intmax, realmax, realmin.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the largest integer that can be represented consecutively in a
floating p



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
floor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 313
 -- Mapping Function: floor (X)
     Return the largest integer not greater than X.  This is equivalent
     to rounding towards negative infinity.  If X is complex, return
     'floor (real (X)) + floor (imag (X)) * I'.

          floor ([-2.7, 2.7])
               => -3    2

     See also: ceil, round, fix.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Return the largest integer not greater than X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
fmod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 338
 -- Mapping Function: rem (X, Y)
 -- Mapping Function: fmod (X, Y)
     Return the remainder of the division 'X / Y', computed using the
     expression

          x - y .* fix (x ./ y)

     An error message is printed if the dimensions of the arguments do
     not agree, or if either of the arguments is complex.

     See also: mod.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Return the remainder of the division 'X / Y', computed using the
expression



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
fnmatch


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 348
 -- Built-in Function: fnmatch (PATTERN, STRING)
     Return true or false for each element of STRING that matches any of
     the elements of the string array PATTERN, using the rules of
     filename pattern matching.  For example:

          fnmatch ("a*b", {"ab"; "axyzb"; "xyzab"})
               => [ 1; 1; 0 ]

     See also: glob, regexp.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return true or false for each element of STRING that matches any of the
elements



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fopen


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3248
 -- Built-in Function: [FID, MSG] = fopen (NAME, MODE, ARCH)
 -- Built-in Function: FID_LIST = fopen ("all")
 -- Built-in Function: [FILE, MODE, ARCH] = fopen (FID)
     The first form of the 'fopen' function opens the named file with
     the specified mode (read-write, read-only, etc.)  and architecture
     interpretation (IEEE big endian, IEEE little endian, etc.), and
     returns an integer value that may be used to refer to the file
     later.  If an error occurs, FID is set to -1 and MSG contains the
     corresponding system error message.  The MODE is a one or two
     character string that specifies whether the file is to be opened
     for reading, writing, or both.

     The second form of the 'fopen' function returns a vector of file
     ids corresponding to all the currently open files, excluding the
     'stdin', 'stdout', and 'stderr' streams.

     The third form of the 'fopen' function returns information about
     the open file given its file id.

     For example,

          myfile = fopen ("splat.dat", "r", "ieee-le");

     opens the file 'splat.dat' for reading.  If necessary, binary
     numeric values will be read assuming they are stored in IEEE format
     with the least significant bit first, and then converted to the
     native representation.

     Opening a file that is already open simply opens it again and
     returns a separate file id.  It is not an error to open a file
     several times, though writing to the same file through several
     different file ids may produce unexpected results.

     The possible values 'mode' may have are

     'r'
          Open a file for reading.

     'w'
          Open a file for writing.  The previous contents are discarded.

     'a'
          Open or create a file for writing at the end of the file.

     'r+'
          Open an existing file for reading and writing.

     'w+'
          Open a file for reading or writing.  The previous contents are
          discarded.

     'a+'
          Open or create a file for reading or writing at the end of the
          file.

     Append a "t" to the mode string to open the file in text mode or a
     "b" to open in binary mode.  On Windows and Macintosh systems, text
     mode reading and writing automatically converts linefeeds to the
     appropriate line end character for the system (carriage-return
     linefeed on Windows, carriage-return on Macintosh).  The default if
     no mode is specified is binary mode.

     Additionally, you may append a "z" to the mode string to open a
     gzipped file for reading or writing.  For this to be successful,
     you must also open the file in binary mode.

     The parameter ARCH is a string specifying the default data format
     for the file.  Valid values for ARCH are:

     'native'
          The format of the current machine (this is the default).

     'ieee-be'
          IEEE big endian format.

     'ieee-le'
          IEEE little endian format.

     however, conversions are currently only supported for 'native'
     'ieee-be', and 'ieee-le' formats.

     See also: fclose, fgets, fgetl, fscanf, fread, fputs, fdisp,
     fprintf, fwrite, fskipl, fseek, frewind, ftell, feof, ferror,
     fclear, fflush, freport.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
The first form of the 'fopen' function opens the named file with the
specified m



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
fork


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 688
 -- Built-in Function: [PID, MSG] = fork ()
     Create a copy of the current process.

     Fork can return one of the following values:

     > 0
          You are in the parent process.  The value returned from 'fork'
          is the process id of the child process.  You should probably
          arrange to wait for any child processes to exit.

     0
          You are in the child process.  You can call 'exec' to start
          another process.  If that fails, you should probably call
          'exit'.

     < 0
          The call to 'fork' failed for some reason.  You must take
          evasive action.  A system dependent error message will be
          waiting in MSG.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Create a copy of the current process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
format


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5668
 -- Command: format
 -- Command: format options
     Reset or specify the format of the output produced by 'disp' and
     Octave's normal echoing mechanism.  This command only affects the
     display of numbers but not how they are stored or computed.  To
     change the internal representation from the default double use one
     of the conversion functions such as 'single', 'uint8', 'int64',
     etc.

     By default, Octave displays 5 significant digits in a human
     readable form (option 'short' paired with 'loose' format for
     matrices).  If 'format' is invoked without any options, this
     default format is restored.

     Valid formats for floating point numbers are listed in the
     following table.

     'short'
          Fixed point format with 5 significant figures in a field that
          is a maximum of 10 characters wide.  (default).

          If Octave is unable to format a matrix so that columns line up
          on the decimal point and all numbers fit within the maximum
          field width then it switches to an exponential 'e' format.

     'long'
          Fixed point format with 15 significant figures in a field that
          is a maximum of 20 characters wide.

          As with the 'short' format, Octave will switch to an
          exponential 'e' format if it is unable to format a matrix
          properly using the current format.

     'short e'
     'long e'
          Exponential format.  The number to be represented is split
          between a mantissa and an exponent (power of 10).  The
          mantissa has 5 significant digits in the short format and 15
          digits in the long format.  For example, with the 'short e'
          format, 'pi' is displayed as '3.1416e+00'.

     'short E'
     'long E'
          Identical to 'short e' or 'long e' but displays an uppercase
          'E' to indicate the exponent.  For example, with the 'long E'
          format, 'pi' is displayed as '3.14159265358979E+00'.

     'short g'
     'long g'
          Optimally choose between fixed point and exponential format
          based on the magnitude of the number.  For example, with the
          'short g' format, 'pi .^ [2; 4; 8; 16; 32]' is displayed as

               ans =

                     9.8696
                     97.409
                     9488.5
                 9.0032e+07
                 8.1058e+15

     'short eng'
     'long eng'
          Identical to 'short e' or 'long e' but displays the value
          using an engineering format, where the exponent is divisible
          by 3.  For example, with the 'short eng' format, '10 * pi' is
          displayed as '31.4159e+00'.

     'long G'
     'short G'
          Identical to 'short g' or 'long g' but displays an uppercase
          'E' to indicate the exponent.

     'free'
     'none'
          Print output in free format, without trying to line up columns
          of matrices on the decimal point.  This also causes complex
          numbers to be formatted as numeric pairs like this '(0.60419,
          0.60709)' instead of like this '0.60419 + 0.60709i'.

     The following formats affect all numeric output (floating point and
     integer types).

     '+'
     '+ CHARS'
     'plus'
     'plus CHARS'
          Print a '+' symbol for nonzero matrix elements and a space for
          zero matrix elements.  This format can be very useful for
          examining the structure of a large sparse matrix.

          The optional argument CHARS specifies a list of 3 characters
          to use for printing values greater than zero, less than zero
          and equal to zero.  For example, with the '+ "+-."' format,
          '[1, 0, -1; -1, 0, 1]' is displayed as

               ans =

               +.-
               -.+

     'bank'
          Print in a fixed format with two digits to the right of the
          decimal point.

     'native-hex'
          Print the hexadecimal representation of numbers as they are
          stored in memory.  For example, on a workstation which stores
          8 byte real values in IEEE format with the least significant
          byte first, the value of 'pi' when printed in 'native-hex'
          format is '400921fb54442d18'.

     'hex'
          The same as 'native-hex', but always print the most
          significant byte first.

     'native-bit'
          Print the bit representation of numbers as stored in memory.
          For example, the value of 'pi' is

               01000000000010010010000111111011
               01010100010001000010110100011000

          (shown here in two 32 bit sections for typesetting purposes)
          when printed in native-bit format on a workstation which
          stores 8 byte real values in IEEE format with the least
          significant byte first.

     'bit'
          The same as 'native-bit', but always print the most
          significant bits first.

     'rat'
          Print a rational approximation, i.e., values are approximated
          as the ratio of small integers.  For example, with the 'rat'
          format, 'pi' is displayed as '355/113'.

     The following two options affect the display of all matrices.

     'compact'
          Remove blank lines around column number labels and between
          matrices producing more compact output with more data per
          page.

     'loose'
          Insert blank lines above and below column number labels and
          between matrices to produce a more readable output with less
          data per page.  (default).

     See also: fixed_point_format, output_max_field_width,
     output_precision, split_long_rows, rats.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Reset or specify the format of the output produced by 'disp' and
Octave's normal



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
formula


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 214
 -- Built-in Function: formula (FUN)
     Return a character string representing the inline function FUN.
     Note that 'char (FUN)' is equivalent to 'formula (FUN)'.

     See also: argnames, inline, vectorize.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return a character string representing the inline function FUN.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
fprintf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 303
 -- Built-in Function: fprintf (FID, TEMPLATE, ...)
     This function is just like 'printf', except that the output is
     written to the stream FID instead of 'stdout'.  If FID is omitted,
     the output is written to 'stdout'.

     See also: fputs, fdisp, fwrite, fscanf, printf, sprintf, fopen.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This function is just like 'printf', except that the output is written
to the st



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fputs


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 205
 -- Built-in Function: fputs (FID, STRING)
     Write a string to a file with no formatting.

     Return a non-negative number on success and EOF on error.

     See also: fdisp, fprintf, fwrite, fopen.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Write a string to a file with no formatting.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fread


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4147
 -- Built-in Function: [VAL, COUNT] = fread (FID, SIZE, PRECISION, SKIP,
          ARCH)
     Read binary data of type PRECISION from the specified file ID FID.

     The optional argument SIZE specifies the amount of data to read and
     may be one of

     'Inf'
          Read as much as possible, returning a column vector.

     'NR'
          Read up to NR elements, returning a column vector.

     '[NR, Inf]'
          Read as much as possible, returning a matrix with NR rows.  If
          the number of elements read is not an exact multiple of NR,
          the last column is padded with zeros.

     '[NR, NC]'
          Read up to 'NR * NC' elements, returning a matrix with NR
          rows.  If the number of elements read is not an exact multiple
          of NR, the last column is padded with zeros.

     If SIZE is omitted, a value of 'Inf' is assumed.

     The optional argument PRECISION is a string specifying the type of
     data to read and may be one of

     "schar"
     "signed char"
          Signed character.

     "uchar"
     "unsigned char"
          Unsigned character.

     "int8"
     "integer*1"

          8-bit signed integer.

     "int16"
     "integer*2"
          16-bit signed integer.

     "int32"
     "integer*4"
          32-bit signed integer.

     "int64"
     "integer*8"
          64-bit signed integer.

     "uint8"
          8-bit unsigned integer.

     "uint16"
          16-bit unsigned integer.

     "uint32"
          32-bit unsigned integer.

     "uint64"
          64-bit unsigned integer.

     "single"
     "float32"
     "real*4"
          32-bit floating point number.

     "double"
     "float64"
     "real*8"
          64-bit floating point number.

     "char"
     "char*1"
          Single character.

     "short"
          Short integer (size is platform dependent).

     "int"
          Integer (size is platform dependent).

     "long"
          Long integer (size is platform dependent).

     "ushort"
     "unsigned short"
          Unsigned short integer (size is platform dependent).

     "uint"
     "unsigned int"
          Unsigned integer (size is platform dependent).

     "ulong"
     "unsigned long"
          Unsigned long integer (size is platform dependent).

     "float"
          Single precision floating point number (size is platform
          dependent).

     The default precision is "uchar".

     The PRECISION argument may also specify an optional repeat count.
     For example, '32*single' causes 'fread' to read a block of 32
     single precision floating point numbers.  Reading in blocks is
     useful in combination with the SKIP argument.

     The PRECISION argument may also specify a type conversion.  For
     example, 'int16=>int32' causes 'fread' to read 16-bit integer
     values and return an array of 32-bit integer values.  By default,
     'fread' returns a double precision array.  The special form '*TYPE'
     is shorthand for 'TYPE=>TYPE'.

     The conversion and repeat counts may be combined.  For example, the
     specification '32*single=>single' causes 'fread' to read blocks of
     single precision floating point values and return an array of
     single precision values instead of the default array of double
     precision values.

     The optional argument SKIP specifies the number of bytes to skip
     after each element (or block of elements) is read.  If it is not
     specified, a value of 0 is assumed.  If the final block read is not
     complete, the final skip is omitted.  For example,

          fread (f, 10, "3*single=>single", 8)

     will omit the final 8-byte skip because the last read will not be a
     complete block of 3 values.

     The optional argument ARCH is a string specifying the data format
     for the file.  Valid values are

     '"native"'
          The format of the current machine.

     '"ieee-be"'
          IEEE big endian.

     '"ieee-le"'
          IEEE little endian.

     The data read from the file is returned in VAL, and the number of
     values read is returned in 'count'

     See also: fwrite, fgets, fgetl, fscanf, fopen.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Read binary data of type PRECISION from the specified file ID FID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
freport


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 431
 -- Built-in Function: freport ()
     Print a list of which files have been opened, and whether they are
     open for reading, writing, or both.  For example:

          freport ()

               -|  number  mode  name
               -|
               -|       0     r  stdin
               -|       1     w  stdout
               -|       2     w  stderr
               -|       3     r  myfile

     See also: fopen, fclose.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Print a list of which files have been opened, and whether they are open
for read



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
frewind


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 256
 -- Built-in Function: frewind (FID)
     Move the file pointer to the beginning of the file FID, returning 0
     for success, and -1 if an error was encountered.  It is equivalent
     to 'fseek (FID, 0, SEEK_SET)'.

     See also: fseek, ftell, fopen.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Move the file pointer to the beginning of the file FID, returning 0 for
success,



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
fscanf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1737
 -- Built-in Function: [VAL, COUNT, ERRMSG] = fscanf (FID, TEMPLATE,
          SIZE)
 -- Built-in Function: [V1, V2, ..., COUNT, ERRMSG] = fscanf (FID,
          TEMPLATE, "C")
     In the first form, read from FID according to TEMPLATE, returning
     the result in the matrix VAL.

     The optional argument SIZE specifies the amount of data to read and
     may be one of

     'Inf'
          Read as much as possible, returning a column vector.

     'NR'
          Read up to NR elements, returning a column vector.

     '[NR, Inf]'
          Read as much as possible, returning a matrix with NR rows.  If
          the number of elements read is not an exact multiple of NR,
          the last column is padded with zeros.

     '[NR, NC]'
          Read up to 'NR * NC' elements, returning a matrix with NR
          rows.  If the number of elements read is not an exact multiple
          of NR, the last column is padded with zeros.

     If SIZE is omitted, a value of 'Inf' is assumed.

     A string is returned if TEMPLATE specifies only character
     conversions.

     The number of items successfully read is returned in COUNT.

     If an error occurs, ERRMSG contains a system-dependent error
     message.

     In the second form, read from FID according to TEMPLATE, with each
     conversion specifier in TEMPLATE corresponding to a single scalar
     return value.  This form is more "C-like", and also compatible with
     previous versions of Octave.  The number of successful conversions
     is returned in COUNT

     See the Formatted Input section of the GNU Octave manual for a
     complete description of the syntax of the template string.

     See also: fgets, fgetl, fread, scanf, sscanf, fopen.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
In the first form, read from FID according to TEMPLATE, returning the
result in 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
fseek


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 698
 -- Built-in Function: fseek (FID, OFFSET)
 -- Built-in Function: fseek (FID, OFFSET, ORIGIN)
 -- Built-in Function: STATUS = fseek (...)
     Set the file pointer to any location within the file FID.

     The pointer is positioned OFFSET characters from the ORIGIN, which
     may be one of the predefined variables 'SEEK_CUR' (current
     position), 'SEEK_SET' (beginning), or 'SEEK_END' (end of file) or
     strings "cof", "bof" or "eof".  If ORIGIN is omitted, 'SEEK_SET' is
     assumed.  OFFSET may be positive, negative, or zero but not all
     combinations of ORIGIN and OFFSET can be realized.

     Return 0 on success and -1 on error.

     See also: fskipl, frewind, ftell, fopen.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Set the file pointer to any location within the file FID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
fskipl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 684
 -- Built-in Function: NLINES = fskipl (FID)
 -- Built-in Function: NLINES = fskipl (FID, COUNT)
 -- Built-in Function: NLINES = fskipl (FID, Inf)
     Read and skip COUNT lines from the file descriptor FID.  'fskipl'
     discards characters until an end-of-line is encountered exactly
     COUNT-times, or until the end-of-file marker is found.

     If COUNT is omitted, it defaults to 1.  COUNT may also be 'Inf', in
     which case lines are skipped until the end of the file.  This form
     is suitable for counting the number of lines in a file.

     Returns the number of lines skipped (end-of-line sequences
     encountered).

     See also: fgetl, fgets, fscanf, fopen.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Read and skip COUNT lines from the file descriptor FID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ftell


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 186
 -- Built-in Function: ftell (FID)
     Return the position of the file pointer as the number of characters
     from the beginning of the file FID.

     See also: fseek, feof, fopen.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the position of the file pointer as the number of characters from
the beg



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
full


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 169
 -- Built-in Function: FM = full (SM)
     Return a full storage matrix from a sparse, diagonal, permutation
     matrix, or a range.

     See also: sparse, issparse.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a full storage matrix from a sparse, diagonal, permutation
matrix, or a r



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
func2str


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 191
 -- Built-in Function: func2str (FCN_HANDLE)
     Return a string containing the name of the function referenced by
     the function handle FCN_HANDLE.

     See also: str2func, functions.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a string containing the name of the function referenced by the
function h



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
functions


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1158
 -- Built-in Function: S = functions (FCN_HANDLE)
     Return a structure containing information about the function handle
     FCN_HANDLE.

     The structure S always contains these 3 fields:

     function
          The function name.  For an anonymous function (no name) this
          will be the actual function definition.

     type
          Type of the function.

          anonymous
               The function is anonymous.

          private
               The function is private.

          overloaded
               The function overloads an existing function.

          simple
               The function is a built-in or m-file function.

          subfunction
               The function is a subfunction within an m-file.

     file
          The m-file that will be called to perform the function.  This
          field is empty for anonymous and built-in functions.

     In addition, some function types may return more information in
     additional fields.

     *Warning:* 'functions' is provided for debugging purposes only.
     It's behavior may change in the future and programs should not
     depend on a particular output.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
Return a structure containing information about the function handle
FCN_HANDLE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
fwrite


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 651
 -- Built-in Function: COUNT = fwrite (FID, DATA, PRECISION, SKIP, ARCH)
     Write data in binary form of type PRECISION to the specified file
     ID FID, returning the number of values successfully written to the
     file.

     The argument DATA is a matrix of values that are to be written to
     the file.  The values are extracted in column-major order.

     The remaining arguments PRECISION, SKIP, and ARCH are optional, and
     are interpreted as described for 'fread'.

     The behavior of 'fwrite' is undefined if the values in DATA are too
     large to fit in the specified precision.

     See also: fread, fputs, fprintf, fopen.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Write data in binary form of type PRECISION to the specified file ID
FID, return



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
gamma


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 249
 -- Mapping Function: gamma (Z)
     Compute the Gamma function,

                       infinity
                      /
          gamma (z) = | t^(z-1) exp (-t) dt.
                      /
                   t=0

     See also: gammainc, lgamma.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Compute the Gamma function,



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
gammainc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1092
 -- Mapping Function: gammainc (X, A)
 -- Mapping Function: gammainc (X, A, "lower")
 -- Mapping Function: gammainc (X, A, "upper")
     Compute the normalized incomplete gamma function,

                                          x
                                 1       /
          gammainc (x, a) = ---------    | exp (-t) t^(a-1) dt
                            gamma (a)    /
                                      t=0

     with the limiting value of 1 as X approaches infinity.  The
     standard notation is P(a,x), e.g., Abramowitz and Stegun (6.5.1).

     If A is scalar, then 'gammainc (X, A)' is returned for each element
     of X and vice versa.

     If neither X nor A is scalar, the sizes of X and A must agree, and
     'gammainc' is applied element-by-element.

     By default the incomplete gamma function integrated from 0 to X is
     computed.  If "upper" is given then the complementary function
     integrated from X to infinity is calculated.  It should be noted
     that

          gammainc (X, A) == 1 - gammainc (X, A, "upper")

     See also: gamma, lgamma.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Compute the normalized incomplete gamma function,



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
gammaln


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 163
 -- Mapping Function: lgamma (X)
 -- Mapping Function: gammaln (X)
     Return the natural logarithm of the gamma function of X.

     See also: gamma, gammainc.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Return the natural logarithm of the gamma function of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
gcd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 836
 -- Built-in Function: G = gcd (A1, A2, ...)
 -- Built-in Function: [G, V1, ...] = gcd (A1, A2, ...)

     Compute the greatest common divisor of A1, A2, ....  If more than
     one argument is given all arguments must be the same size or
     scalar.  In this case the greatest common divisor is calculated for
     each element individually.  All elements must be ordinary or
     Gaussian (complex) integers.  Note that for Gaussian integers, the
     gcd is not unique up to units (multiplication by 1, -1, I or -I),
     so an arbitrary greatest common divisor amongst four possible is
     returned.

     Example code:

          gcd ([15, 9], [20, 18])
             =>  5  9

     Optional return arguments V1, etc., contain integer vectors such
     that,

          G = V1 .* A1 + V2 .* A2 + ...

     See also: lcm, factor.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Compute the greatest common divisor of A1, A2, ....



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
ge


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 116
 -- Built-in Function: ge (X, Y)
     This function is equivalent to 'x >= y'.

     See also: le, eq, gt, ne, lt.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
This function is equivalent to 'x >= y'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
genpath


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 270
 -- Built-in Function: genpath (DIR)
 -- Built-in Function: genpath (DIR, SKIP, ...)
     Return a path constructed from DIR and all its subdirectories.  If
     additional string parameters are given, the resulting path will
     exclude directories with those names.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Return a path constructed from DIR and all its subdirectories.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
get


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 339
 -- Built-in Function: VAL = get (H)
 -- Built-in Function: VAL = get (H, P)
     Return the value of the named property P from the graphics handle
     H.  If P is omitted, return the complete property list for H.  If H
     is a vector, return a cell array including the property values or
     lists respectively.

     See also: set.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
Return the value of the named property P from the graphics handle H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
get_help_text


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 264
 -- Built-in Function: [TEXT, FORMAT] = get_help_text (NAME)
     Return the raw help text of function NAME.

     The raw help text is returned in TEXT and the format in FORMAT The
     format is a string which is one of "texinfo", "html", or "plain
     text".




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Return the raw help text of function NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
get_help_text_from_file


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 278
 -- Built-in Function: [TEXT, FORMAT] = get_help_text_from_file (FNAME)
     Return the raw help text from the file FNAME.

     The raw help text is returned in TEXT and the format in FORMAT The
     format is a string which is one of "texinfo", "html", or "plain
     text".




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Return the raw help text from the file FNAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
getegid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 101
 -- Built-in Function: egid = getegid ()
     Return the effective group id of the current process.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Return the effective group id of the current process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
getenv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 191
 -- Built-in Function: getenv (VAR)
     Return the value of the environment variable VAR.  For example,

          getenv ("PATH")

     returns a string containing the value of your path.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Return the value of the environment variable VAR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
geteuid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 100
 -- Built-in Function: euid = geteuid ()
     Return the effective user id of the current process.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Return the effective user id of the current process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
getgid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 94
 -- Built-in Function: gid = getgid ()
     Return the real group id of the current process.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Return the real group id of the current process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
getgrent


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 186
 -- Built-in Function: GRP_STRUCT = getgrent ()
     Return an entry from the group database, opening it if necessary.
     Once the end of data has been reached, 'getgrent' returns 0.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Return an entry from the group database, opening it if necessary.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
getgrgid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 209
 -- Built-in Function: GRP_STRUCT = getgrgid (GID).
     Return the first entry from the group database with the group ID
     GID.  If the group ID does not exist in the database, 'getgrgid'
     returns 0.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Return the first entry from the group database with the group ID GID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
getgrnam


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 214
 -- Built-in Function: GRP_STRUCT = getgrnam (NAME)
     Return the first entry from the group database with the group name
     NAME.  If the group name does not exist in the database, 'getgrnam'
     returns 0.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Return the first entry from the group database with the group name NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
gethostname


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 103
 -- Built-in Function: gethostname ()
     Return the hostname of the system where Octave is running.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Return the hostname of the system where Octave is running.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
getpgrp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 99
 -- Built-in Function: pgid = getpgrp ()
     Return the process group id of the current process.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Return the process group id of the current process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
getpid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 91
 -- Built-in Function: pid = getpid ()
     Return the process id of the current process.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Return the process id of the current process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
getppid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 91
 -- Built-in Function: pid = getppid ()
     Return the process id of the parent process.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return the process id of the parent process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
getpwent


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 221
 -- Built-in Function: PW_STRUCT = getpwent ()
     Return a structure containing an entry from the password database,
     opening it if necessary.  Once the end of the data has been
     reached, 'getpwent' returns 0.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a structure containing an entry from the password database,
opening it if



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
getpwnam


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 238
 -- Built-in Function: PW_STRUCT = getpwnam (NAME)
     Return a structure containing the first entry from the password
     database with the user name NAME.  If the user name does not exist
     in the database, 'getpwname' returns 0.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a structure containing the first entry from the password database
with th



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
getpwuid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 232
 -- Built-in Function: PW_STRUCT = getpwuid (UID).
     Return a structure containing the first entry from the password
     database with the user ID UID.  If the user ID does not exist in
     the database, 'getpwuid' returns 0.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a structure containing the first entry from the password database
with th



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
getrusage


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1405
 -- Built-in Function: getrusage ()
     Return a structure containing a number of statistics about the
     current Octave process.  Not all fields are available on all
     systems.  If it is not possible to get CPU time statistics, the CPU
     time slots are set to zero.  Other missing data are replaced by
     NaN.  The list of possible fields is:

     'idrss'
          Unshared data size.

     'inblock'
          Number of block input operations.

     'isrss'
          Unshared stack size.

     'ixrss'
          Shared memory size.

     'majflt'
          Number of major page faults.

     'maxrss'
          Maximum data size.

     'minflt'
          Number of minor page faults.

     'msgrcv'
          Number of messages received.

     'msgsnd'
          Number of messages sent.

     'nivcsw'
          Number of involuntary context switches.

     'nsignals'
          Number of signals received.

     'nswap'
          Number of swaps.

     'nvcsw'
          Number of voluntary context switches.

     'oublock'
          Number of block output operations.

     'stime'
          A structure containing the system CPU time used.  The
          structure has the elements 'sec' (seconds) 'usec'
          (microseconds).

     'utime'
          A structure containing the user CPU time used.  The structure
          has the elements 'sec' (seconds) 'usec' (microseconds).




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a structure containing a number of statistics about the current
Octave pr



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
getuid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 93
 -- Built-in Function: uid = getuid ()
     Return the real user id of the current process.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Return the real user id of the current process.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
givens


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 319
 -- Built-in Function: G = givens (X, Y)
 -- Built-in Function: [C, S] = givens (X, Y)
     Return a 2 by 2 orthogonal matrix 'G = [C S; -S' C]' such that 'G
     [X; Y] = [*; 0]' with X and Y scalars.

     For example:

          givens (1, 1)
             =>   0.70711   0.70711
                 -0.70711   0.70711




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a 2 by 2 orthogonal matrix 'G = [C S; -S' C]' such that 'G [X; Y]
= [*; 0



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
glob


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1204
 -- Built-in Function: glob (PATTERN)
     Given an array of pattern strings (as a char array or a cell array)
     in PATTERN, return a cell array of file names that match any of
     them, or an empty cell array if no patterns match.  The pattern
     strings are interpreted as filename globbing patterns (as they are
     used by Unix shells).  Within a pattern

     '*'
          matches any string, including the null string,

     '?'
          matches any single character, and

     '[...]'
          matches any of the enclosed characters.

     Tilde expansion is performed on each of the patterns before looking
     for matching file names.  For example:

          ls
             =>
                file1  file2  file3  myfile1 myfile1b
          glob ("*file1")
             =>
                {
                  [1,1] = file1
                  [2,1] = myfile1
                }
          glob ("myfile?")
             =>
                {
                  [1,1] = myfile1
                }
          glob ("file[12]")
             =>
                {
                  [1,1] = file1
                  [2,1] = file2
                }

     See also: ls, dir, readdir, what, fnmatch.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Given an array of pattern strings (as a char array or a cell array) in
PATTERN, 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
gmtime


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 748
 -- Built-in Function: TM_STRUCT = gmtime (T)
     Given a value returned from 'time', or any non-negative integer,
     return a time structure corresponding to CUT (Coordinated Universal
     Time).  For example:

          gmtime (time ())
               => {
                     usec = 0
                     sec = 6
                     min = 15
                     hour = 7
                     mday = 17
                     mon = 1
                     year = 97
                     wday = 1
                     yday = 47
                     isdst = 0
                     zone = CST
                  }

     See also: strftime, strptime, localtime, mktime, time, now, date,
     clock, datenum, datestr, datevec, calendar, weekday.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Given a value returned from 'time', or any non-negative integer, return
a time s



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
gt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 115
 -- Built-in Function: gt (X, Y)
     This function is equivalent to 'x > y'.

     See also: le, eq, ge, ne, lt.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
This function is equivalent to 'x > y'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
have_window_system


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 151
 -- Built-in Function: have_window_system ()
     Return true if a window system is available (X11, Windows, or Apple
     OS X) and false otherwise.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return true if a window system is available (X11, Windows, or Apple OS
X) and fa



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
hess


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 634
 -- Built-in Function: H = hess (A)
 -- Built-in Function: [P, H] = hess (A)
     Compute the Hessenberg decomposition of the matrix A.

     The Hessenberg decomposition is 'P * H * P' = A' where P is a
     square unitary matrix ('P' * P = I', using complex-conjugate
     transposition) and H is upper Hessenberg ('H(i, j) = 0 forall i >=
     j+1)'.

     The Hessenberg decomposition is usually used as the first step in
     an eigenvalue computation, but has other applications as well (see
     Golub, Nash, and Van Loan, IEEE Transactions on Automatic Control,
     1979).

     See also: eig, chol, lu, qr, qz, schur, svd.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Compute the Hessenberg decomposition of the matrix A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
hex2num


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 841
 -- Built-in Function: N = hex2num (S)
 -- Built-in Function: N = hex2num (S, CLASS)
     Typecast the 16 character hexadecimal character string to an IEEE
     754 double precision number.  If fewer than 16 characters are given
     the strings are right padded with '0' characters.

     Given a string matrix, 'hex2num' treats each row as a separate
     number.

          hex2num (["4005bf0a8b145769"; "4024000000000000"])
             => [2.7183; 10.000]

     The optional argument CLASS can be passed as the string "single" to
     specify that the given string should be interpreted as a single
     precision number.  In this case, S should be an 8 character
     hexadecimal string.  For example:

          hex2num (["402df854"; "41200000"], "single")
             => [2.7183; 10.000]

     See also: num2hex, hex2dec, dec2hex.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Typecast the 16 character hexadecimal character string to an IEEE 754
double pre



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
history


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1211
 -- Command: history
 -- Command: history OPT1 ...
 -- Built-in Function: H = history ()
 -- Built-in Function: H = history (OPT1, ...)
     If invoked with no arguments, 'history' displays a list of commands
     that you have executed.  Valid options are:

     'N'
     '-N'
          Display only the most recent N lines of history.

     '-c'
          Clear the history list.

     '-q'
          Don't number the displayed lines of history.  This is useful
          for cutting and pasting commands using the X Window System.

     '-r FILE'
          Read the file FILE, appending its contents to the current
          history list.  If the name is omitted, use the default history
          file (normally '~/.octave_hist').

     '-w FILE'
          Write the current history to the file FILE.  If the name is
          omitted, use the default history file (normally
          '~/.octave_hist').

     For example, to display the five most recent commands that you have
     typed without displaying line numbers, use the command 'history -q
     5'.

     If invoked with a single output argument, the history will be saved
     to that argument as a cell string and will not be output to screen.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
If invoked with no arguments, 'history' displays a list of commands that
you hav



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
history_control


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1222
 -- Built-in Function: VAL = history_control ()
 -- Built-in Function: OLD_VAL = history_control (NEW_VAL)
     Query or set the internal variable that specifies how commands are
     saved to the history list.  The default value is an empty character
     string, but may be overridden by the environment variable
     'OCTAVE_HISTCONTROL'.

     The value of 'history_control' is a colon-separated list of values
     controlling how commands are saved on the history list.  If the
     list of values includes 'ignorespace', lines which begin with a
     space character are not saved in the history list.  A value of
     'ignoredups' causes lines matching the previous history entry to
     not be saved.  A value of 'ignoreboth' is shorthand for
     'ignorespace' and 'ignoredups'.  A value of 'erasedups' causes all
     previous lines matching the current line to be removed from the
     history list before that line is saved.  Any value not in the above
     list is ignored.  If 'history_control' is the empty string, all
     commands are saved on the history list, subject to the value of
     'history_save'.

     See also: history_file, history_size,
     history_timestamp_format_string, history_save.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that specifies how commands are saved
to the 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
history_file


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 415
 -- Built-in Function: VAL = history_file ()
 -- Built-in Function: OLD_VAL = history_file (NEW_VAL)
     Query or set the internal variable that specifies the name of the
     file used to store command history.  The default value is
     '~/.octave_hist', but may be overridden by the environment variable
     'OCTAVE_HISTFILE'.

     See also: history_size, history_save,
     history_timestamp_format_string.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that specifies the name of the file
used to s



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
history_save


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 619
 -- Built-in Function: VAL = history_save ()
 -- Built-in Function: OLD_VAL = history_save (NEW_VAL)
 -- Built-in Function: history_save (NEW_VAL, "local")
     Query or set the internal variable that controls whether commands
     entered on the command line are saved in the history file.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: history_control, history_file, history_size,
     history_timestamp_format_string.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that controls whether commands
entered on the



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
history_size


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 395
 -- Built-in Function: VAL = history_size ()
 -- Built-in Function: OLD_VAL = history_size (NEW_VAL)
     Query or set the internal variable that specifies how many entries
     to store in the history file.  The default value is '1000', but may
     be overridden by the environment variable 'OCTAVE_HISTSIZE'.

     See also: history_file, history_timestamp_format_string,
     history_save.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that specifies how many entries to
store in t



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
history_timestamp_format_string


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 827
 -- Built-in Function: VAL = history_timestamp_format_string ()
 -- Built-in Function: OLD_VAL = history_timestamp_format_string
          (NEW_VAL)
 -- Built-in Function: history_timestamp_format_string (NEW_VAL,
          "local")
     Query or set the internal variable that specifies the format string
     for the comment line that is written to the history file when
     Octave exits.  The format string is passed to 'strftime'.  The
     default value is

          "# Octave VERSION, %a %b %d %H:%M:%S %Y %Z <USER@HOST>"

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: strftime, history_file, history_size, history_save.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that specifies the format string for
the comm



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
home


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 144
 -- Built-in Function: clc ()
 -- Built-in Function: home ()
     Clear the terminal screen and move the cursor to the upper left
     corner.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Clear the terminal screen and move the cursor to the upper left corner.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
horzcat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 363
 -- Built-in Function: horzcat (ARRAY1, ARRAY2, ..., ARRAYN)
     Return the horizontal concatenation of N-D array objects, ARRAY1,
     ARRAY2, ..., ARRAYN along dimension 2.

     Arrays may also be concatenated horizontally using the syntax for
     creating new matrices.  For example:

          HCAT = [ ARRAY1, ARRAY2, ... ]

     See also: cat, vertcat.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the horizontal concatenation of N-D array objects, ARRAY1,
ARRAY2, ..., A



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
hypot


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 515
 -- Built-in Function: hypot (X, Y)
 -- Built-in Function: hypot (X, Y, Z, ...)
     Compute the element-by-element square root of the sum of the
     squares of X and Y.  This is equivalent to 'sqrt (X.^2 + Y.^2)',
     but calculated in a manner that avoids overflows for large values
     of X or Y.  'hypot' can also be called with more than 2 arguments;
     in this case, the arguments are accumulated from left to right:

          hypot (hypot (X, Y), Z)
          hypot (hypot (hypot (X, Y), Z), W), etc.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the element-by-element square root of the sum of the squares of
X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
i


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 957
 -- Built-in Function: I
 -- Built-in Function: I (N)
 -- Built-in Function: I (N, M)
 -- Built-in Function: I (N, M, K, ...)
 -- Built-in Function: I (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are
     all equal to the pure imaginary unit, defined as 'sqrt (-1)'.

     I, and its equivalents i, j, and J, are functions so any of the
     names may be reused for other purposes (such as i for a counter
     variable).

     When called with no arguments, return a scalar with the value i.
     When called with a single argument, return a square matrix with the
     dimension specified.  When called with more than one scalar
     argument the first two arguments are taken as the number of rows
     and columns and any further arguments specify additional matrix
     dimensions.  The optional argument CLASS specifies the return type
     and may be either "double" or "single".

     See also: e, pi, log, exp.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a scalar, matrix, or N-dimensional array whose elements are all
equal to 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ifelse


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 850
 -- Built-in Function: merge (MASK, TVAL, FVAL)
 -- Built-in Function: ifelse (MASK, TVAL, FVAL)
     Merge elements of TRUE_VAL and FALSE_VAL, depending on the value of
     MASK.  If MASK is a logical scalar, the other two arguments can be
     arbitrary values.  Otherwise, MASK must be a logical array, and
     TVAL, FVAL should be arrays of matching class, or cell arrays.  In
     the scalar mask case, TVAL is returned if MASK is true, otherwise
     FVAL is returned.

     In the array mask case, both TVAL and FVAL must be either scalars
     or arrays with dimensions equal to MASK.  The result is constructed
     as follows:

          result(mask) = tval(mask);
          result(! mask) = fval(! mask);

     MASK can also be arbitrary numeric type, in which case it is first
     converted to logical.

     See also: logical, diff.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Merge elements of TRUE_VAL and FALSE_VAL, depending on the value of
MASK.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
ifft


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1019
 -- Built-in Function: ifft (X)
 -- Built-in Function: ifft (X, N)
 -- Built-in Function: ifft (X, N, DIM)
     Compute the inverse discrete Fourier transform of A using a Fast
     Fourier Transform (FFT) algorithm.

     The inverse FFT is calculated along the first non-singleton
     dimension of the array.  Thus if X is a matrix, 'fft (X)' computes
     the inverse FFT for each column of X.

     If called with two arguments, N is expected to be an integer
     specifying the number of elements of X to use, or an empty matrix
     to specify that its value should be ignored.  If N is larger than
     the dimension along which the inverse FFT is calculated, then X is
     resized and padded with zeros.  Otherwise, if N is smaller than the
     dimension along which the inverse FFT is calculated, then X is
     truncated.

     If called with three arguments, DIM is an integer specifying the
     dimension of the matrix along which the inverse FFT is performed

     See also: fft, ifft2, ifftn, fftw.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the inverse discrete Fourier transform of A using a Fast Fourier
Transfo



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ifft2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 543
 -- Built-in Function: ifft2 (A)
 -- Built-in Function: ifft2 (A, M, N)
     Compute the inverse two-dimensional discrete Fourier transform of A
     using a Fast Fourier Transform (FFT) algorithm.

     The optional arguments M and N may be used specify the number of
     rows and columns of A to use.  If either of these is larger than
     the size of A, A is resized and padded with zeros.

     If A is a multi-dimensional matrix, each two-dimensional sub-matrix
     of A is treated separately

     See also: fft2, ifft, ifftn, fftw.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the inverse two-dimensional discrete Fourier transform of A
using a Fast



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ifftn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 628
 -- Built-in Function: ifftn (A)
 -- Built-in Function: ifftn (A, SIZE)
     Compute the inverse N-dimensional discrete Fourier transform of A
     using a Fast Fourier Transform (FFT) algorithm.

     The optional vector argument SIZE may be used specify the
     dimensions of the array to be used.  If an element of SIZE is
     smaller than the corresponding dimension of A, then the dimension
     of A is truncated prior to performing the inverse FFT.  Otherwise,
     if an element of SIZE is larger than the corresponding dimension
     then A is resized and padded with zeros.

     See also: fftn, ifft, ifft2, fftw.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the inverse N-dimensional discrete Fourier transform of A using
a Fast F



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
ignore_function_time_stamp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 870
 -- Built-in Function: VAL = ignore_function_time_stamp ()
 -- Built-in Function: OLD_VAL = ignore_function_time_stamp (NEW_VAL)
     Query or set the internal variable that controls whether Octave
     checks the time stamp on files each time it looks up functions
     defined in function files.  If the internal variable is set to
     "system", Octave will not automatically recompile function files in
     subdirectories of 'OCTAVE-HOME/lib/VERSION' if they have changed
     since they were last compiled, but will recompile other function
     files in the search path if they change.  If set to "all", Octave
     will not recompile any function files unless their definitions are
     removed with 'clear'.  If set to "none", Octave will always check
     time stamps on files to determine whether functions defined in
     function files need to recompiled.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that controls whether Octave checks
the time 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
imag


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 114
 -- Mapping Function: imag (Z)
     Return the imaginary part of Z as a real number.

     See also: real, conj.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Return the imaginary part of Z as a real number.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ind2sub


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 433
 -- Function File: [S1, S2, ..., SN] = ind2sub (DIMS, IND)
     Convert a linear index to subscripts.

     The following example shows how to convert the linear index '8' in
     a 3-by-3 matrix into a subscript.  The matrix is linearly indexed
     moving from one column to next, filling up all rows in each column.

          [r, c] = ind2sub ([3, 3], 8)
              => r =  2
              => c =  3

     See also: sub2ind.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Convert a linear index to subscripts.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
inf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1072
 -- Built-in Function: Inf
 -- Built-in Function: Inf (N)
 -- Built-in Function: Inf (N, M)
 -- Built-in Function: Inf (N, M, K, ...)
 -- Built-in Function: Inf (..., CLASS)
     Return a scalar, matrix or N-dimensional array whose elements are
     all equal to the IEEE representation for positive infinity.

     Infinity is produced when results are too large to be represented
     using the the IEEE floating point format for numbers.  Two common
     examples which produce infinity are division by zero and overflow.

          [ 1/0 e^800 ]
          => Inf   Inf

     When called with no arguments, return a scalar with the value
     'Inf'.  When called with a single argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The optional argument CLASS specifies the
     return type and may be either "double" or "single".

     See also: isinf, NaN.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a scalar, matrix or N-dimensional array whose elements are all
equal to t



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
inferiorto


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 344
 -- Built-in Function: inferiorto (CLASS_NAME, ...)
     When called from a class constructor, mark the object currently
     constructed as having a lower precedence than CLASS_NAME.  More
     that one such class can be specified in a single call.  This
     function may only be called from a class constructor.

     See also: superiorto.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
When called from a class constructor, mark the object currently
constructed as h



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
info_file


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 809
 -- Built-in Function: VAL = info_file ()
 -- Built-in Function: OLD_VAL = info_file (NEW_VAL)
 -- Built-in Function: info_file (NEW_VAL, "local")
     Query or set the internal variable that specifies the name of the
     Octave info file.  The default value is
     'OCTAVE-HOME/info/octave.info', in which OCTAVE-HOME is the root
     directory of the Octave installation.  The default value may be
     overridden by the environment variable 'OCTAVE_INFO_FILE', or the
     command line argument '--info-file FNAME'.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: info_program, doc, help, makeinfo_program.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that specifies the name of the Octave
info fi



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
info_program


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 955
 -- Built-in Function: VAL = info_program ()
 -- Built-in Function: OLD_VAL = info_program (NEW_VAL)
 -- Built-in Function: info_program (NEW_VAL, "local")
     Query or set the internal variable that specifies the name of the
     info program to run.  The default value is
     'OCTAVE-HOME/libexec/octave/VERSION/exec/ARCH/info' in which
     OCTAVE-HOME is the root directory of the Octave installation,
     VERSION is the Octave version number, and ARCH is the system type
     (for example, 'i686-pc-linux-gnu').  The default value may be
     overridden by the environment variable 'OCTAVE_INFO_PROGRAM', or
     the command line argument '--info-program NAME'.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: info_file, doc, help, makeinfo_program.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that specifies the name of the info
program t



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
inline


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1264
 -- Built-in Function: inline (STR)
 -- Built-in Function: inline (STR, ARG1, ...)
 -- Built-in Function: inline (STR, N)
     Create an inline function from the character string STR.

     If called with a single argument, the arguments of the generated
     function are extracted from the function itself.  The generated
     function arguments will then be in alphabetical order.  It should
     be noted that i, and j are ignored as arguments due to the
     ambiguity between their use as a variable or their use as an
     inbuilt constant.  All arguments followed by a parenthesis are
     considered to be functions.  If no arguments are found, a function
     taking a single argument named 'x' will be created.

     If the second and subsequent arguments are character strings, they
     are the names of the arguments of the function.

     If the second argument is an integer N, the arguments are "x",
     "P1", ..., "PN".

     Programming Note: The use of 'inline' is discouraged and it may be
     removed from a future version of Octave.  The preferred way to
     create functions from strings is through the use of anonymous
     functions (*note Anonymous Functions::) or 'str2func'.

     See also: argnames, formula, vectorize, str2func.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Create an inline function from the character string STR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
input


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1165
 -- Built-in Function: ANS = input (PROMPT)
 -- Built-in Function: ANS = input (PROMPT, "s")
     Print PROMPT and wait for user input.

     For example,

          input ("Pick a number, any number! ")

     prints the prompt

          Pick a number, any number!

     and waits for the user to enter a value.  The string entered by the
     user is evaluated as an expression, so it may be a literal
     constant, a variable name, or any other valid expression.

     Currently, 'input' only returns one value, regardless of the number
     of values produced by the evaluation of the expression.

     If you are only interested in getting a literal string value, you
     can call 'input' with the character string "s" as the second
     argument.  This tells Octave to return the string entered by the
     user directly, without evaluating it first.

     Because there may be output waiting to be displayed by the pager,
     it is a good idea to always call 'fflush (stdout)' before calling
     'input'.  This will ensure that all pending output is written to
     the screen before your prompt.

     See also: yes_or_no, kbhit, pause, menu, listdlg.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Print PROMPT and wait for user input.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
int16


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 140
 -- Built-in Function: int16 (X)
     Convert X to 16-bit integer type.

     See also: int8, uint8, uint16, int32, uint32, int64, uint64.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Convert X to 16-bit integer type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
int32


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 140
 -- Built-in Function: int32 (X)
     Convert X to 32-bit integer type.

     See also: int8, uint8, int16, uint16, uint32, int64, uint64.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Convert X to 32-bit integer type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
int64


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 140
 -- Built-in Function: int64 (X)
     Convert X to 64-bit integer type.

     See also: int8, uint8, int16, uint16, int32, uint32, uint64.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Convert X to 64-bit integer type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
int8


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 139
 -- Built-in Function: int8 (X)
     Convert X to 8-bit integer type.

     See also: uint8, int16, uint16, int32, uint32, int64, uint64.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Convert X to 8-bit integer type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
intmax


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 610
 -- Built-in Function: intmax (TYPE)
     Return the largest integer that can be represented in an integer
     type.  The variable TYPE can be

     'int8'
          signed 8-bit integer.

     'int16'
          signed 16-bit integer.

     'int32'
          signed 32-bit integer.

     'int64'
          signed 64-bit integer.

     'uint8'
          unsigned 8-bit integer.

     'uint16'
          unsigned 16-bit integer.

     'uint32'
          unsigned 32-bit integer.

     'uint64'
          unsigned 64-bit integer.

     The default for TYPE is 'int32'.

     See also: intmin, flintmax, bitmax.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Return the largest integer that can be represented in an integer type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
intmin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 611
 -- Built-in Function: intmin (TYPE)
     Return the smallest integer that can be represented in an integer
     type.  The variable TYPE can be

     'int8'
          signed 8-bit integer.

     'int16'
          signed 16-bit integer.

     'int32'
          signed 32-bit integer.

     'int64'
          signed 64-bit integer.

     'uint8'
          unsigned 8-bit integer.

     'uint16'
          unsigned 16-bit integer.

     'uint32'
          unsigned 32-bit integer.

     'uint64'
          unsigned 64-bit integer.

     The default for TYPE is 'int32'.

     See also: intmax, flintmax, bitmax.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 71
Return the smallest integer that can be represented in an integer type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
inv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 753
 -- Built-in Function: X = inv (A)
 -- Built-in Function: [X, RCOND] = inv (A)
     Compute the inverse of the square matrix A.  Return an estimate of
     the reciprocal condition number if requested, otherwise warn of an
     ill-conditioned matrix if the reciprocal condition number is small.

     In general it is best to avoid calculating the inverse of a matrix
     directly.  For example, it is both faster and more accurate to
     solve systems of equations (A*x = b) with 'Y = A \ b', rather than
     'Y = inv (A) * b'.

     If called with a sparse matrix, then in general X will be a full
     matrix requiring significantly more storage.  Avoid forming the
     inverse of a sparse matrix if possible.

     See also: ldivide, rdivide.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Compute the inverse of the square matrix A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
inverse


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 192
 -- Built-in Function: X = inverse (A)
 -- Built-in Function: [X, RCOND] = inverse (A)
     Compute the inverse of the square matrix A.

     This is an alias for 'inv'.

     See also: inv.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Compute the inverse of the square matrix A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ipermute


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 211
 -- Built-in Function: ipermute (A, IPERM)
     The inverse of the 'permute' function.  The expression

          ipermute (permute (A, perm), perm)

     returns the original array A.

     See also: permute.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
The inverse of the 'permute' function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
is_absolute_filename


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 183
 -- Built-in Function: is_absolute_filename (FILE)
     Return true if FILE is an absolute filename.

     See also: is_rooted_relative_filename, make_absolute_filename,
     isdir.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return true if FILE is an absolute filename.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
is_dq_string


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 138
 -- Built-in Function: is_dq_string (X)
     Return true if X is a double-quoted character string.

     See also: is_sq_string, ischar.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Return true if X is a double-quoted character string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
is_function_handle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 140
 -- Built-in Function: is_function_handle (X)
     Return true if X is a function handle.

     See also: isa, typeinfo, class, functions.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Return true if X is a function handle.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
is_rooted_relative_filename


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 184
 -- Built-in Function: is_rooted_relative_filename (FILE)
     Return true if FILE is a rooted-relative filename.

     See also: is_absolute_filename, make_absolute_filename, isdir.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Return true if FILE is a rooted-relative filename.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
is_sq_string


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 138
 -- Built-in Function: is_sq_string (X)
     Return true if X is a single-quoted character string.

     See also: is_dq_string, ischar.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Return true if X is a single-quoted character string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isalnum


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 278
 -- Mapping Function: isalnum (S)
     Return a logical array which is true where the elements of S are
     letters or digits and false where they are not.  This is equivalent
     to ('isalpha (S) | isdigit (S)').

     See also: isalpha, isdigit, ispunct, isspace, iscntrl.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a logical array which is true where the elements of S are letters
or digi



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isalpha


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 291
 -- Mapping Function: isalpha (S)
     Return a logical array which is true where the elements of S are
     letters and false where they are not.  This is equivalent to
     ('islower (S) | isupper (S)').

     See also: isdigit, ispunct, isspace, iscntrl, isalnum, islower,
     isupper.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a logical array which is true where the elements of S are letters
and fal



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isargout


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 746
 -- Built-in Function: isargout (K)
     Within a function, return a logical value indicating whether the
     argument K will be assigned to a variable on output.  If the result
     is false, the argument has been ignored during the function call
     through the use of the tilde (~) special output argument.
     Functions can use 'isargout' to avoid performing unnecessary
     calculations for outputs which are unwanted.

     If K is outside the range '1:max (nargout)', the function returns
     false.  K can also be an array, in which case the function works
     element-by-element and a logical array is returned.  At the top
     level, 'isargout' returns an error.

     See also: nargout, nargin, varargin, varargout, nthargout.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Within a function, return a logical value indicating whether the
argument K will



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isascii


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 194
 -- Mapping Function: isascii (S)
     Return a logical array which is true where the elements of S are
     ASCII characters (in the range 0 to 127 decimal) and false where
     they are not.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a logical array which is true where the elements of S are ASCII
character



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
isbool


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 175
 -- Built-in Function: islogical (X)
 -- Built-in Function: isbool (X)
     Return true if X is a logical object.

     See also: isfloat, isinteger, ischar, isnumeric, isa.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Return true if X is a logical object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
iscell


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 133
 -- Built-in Function: iscell (X)
     Return true if X is a cell array object.

     See also: ismatrix, isstruct, iscellstr, isa.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Return true if X is a cell array object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
iscellstr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 150
 -- Built-in Function: iscellstr (CELL)
     Return true if every element of the cell array CELL is a character
     string.

     See also: ischar.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Return true if every element of the cell array CELL is a character
string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
ischar


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 153
 -- Built-in Function: ischar (X)
     Return true if X is a character array.

     See also: isfloat, isinteger, islogical, isnumeric, iscellstr, isa.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Return true if X is a character array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
iscntrl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 211
 -- Mapping Function: iscntrl (S)
     Return a logical array which is true where the elements of S are
     control characters and false where they are not.

     See also: ispunct, isspace, isalpha, isdigit.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a logical array which is true where the elements of S are control
charact



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
iscomplex


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 164
 -- Built-in Function: iscomplex (X)
     Return true if X is a complex-valued numeric object.

     See also: isreal, isnumeric, islogical, ischar, isfloat, isa.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Return true if X is a complex-valued numeric object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
isdebugmode


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 139
 -- Built-in Function: isdebugmode ()
     Return true if in debugging mode, otherwise false.

     See also: dbwhere, dbstack, dbstatus.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Return true if in debugging mode, otherwise false.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isdigit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 233
 -- Mapping Function: isdigit (S)
     Return a logical array which is true where the elements of S are
     decimal digits (0-9) and false where they are not.

     See also: isxdigit, isalpha, isletter, ispunct, isspace, iscntrl.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a logical array which is true where the elements of S are decimal
digits 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isempty


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 174
 -- Built-in Function: isempty (A)
     Return true if A is an empty matrix (any one of its dimensions is
     zero).  Otherwise, return false.

     See also: isnull, isa.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Return true if A is an empty matrix (any one of its dimensions is zero).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isfield


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 292
 -- Built-in Function: isfield (X, "NAME")
 -- Built-in Function: isfield (X, NAME)
     Return true if the X is a structure and it includes an element
     named NAME.  If NAME is a cell array of strings then a logical
     array of equal dimension is returned.

     See also: fieldnames.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Return true if the X is a structure and it includes an element named
NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isfinite


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 310
 -- Mapping Function: isfinite (X)
 -- Mapping Function: finite (X)
     Return a logical array which is true where the elements of X are
     finite values and false where they are not.  For example:

          finite ([13, Inf, NA, NaN])
               => [ 1, 0, 0, 0 ]

     See also: isinf, isnan, isna.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a logical array which is true where the elements of X are finite
values a



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isfloat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 224
 -- Built-in Function: isfloat (X)
     Return true if X is a floating-point numeric object.  Objects of
     class double or single are floating-point objects.

     See also: isinteger, ischar, islogical, isnumeric, isa.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Return true if X is a floating-point numeric object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isglobal


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 208
 -- Built-in Function: isglobal (NAME)
     Return true if NAME is a globally visible variable.  For example:

          global x
          isglobal ("x")
             => 1

     See also: isvarname, exist.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Return true if NAME is a globally visible variable.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isgraph


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 221
 -- Mapping Function: isgraph (S)
     Return a logical array which is true where the elements of S are
     printable characters (but not the space character) and false where
     they are not.

     See also: isprint.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a logical array which is true where the elements of S are
printable chara



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
isguirunning


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 111
 -- Built-in Function: isguirunning ()
     Return true if Octave is running in GUI mode and false otherwise.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Return true if Octave is running in GUI mode and false otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ishandle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 315
 -- Built-in Function: ishandle (H)
     Return true if H is a graphics handle and false otherwise.

     H may also be a matrix of handles in which case a logical array is
     returned that is true where the elements of H are graphics handles
     and false where they are not.

     See also: isaxes, isfigure.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Return true if H is a graphics handle and false otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
isieee


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 184
 -- Built-in Function: isieee ()
     Return true if your computer _claims_ to conform to the IEEE
     standard for floating point calculations.  No actual tests are
     performed.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return true if your computer _claims_ to conform to the IEEE standard
for floati



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isindex


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 440
 -- Built-in Function: isindex (IND)
 -- Built-in Function: isindex (IND, N)
     Return true if IND is a valid index.  Valid indices are either
     positive integers (although possibly of real data type), or logical
     arrays.  If present, N specifies the maximum extent of the
     dimension to be indexed.  When possible the internal result is
     cached so that subsequent indexing using IND will not perform the
     check again.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Return true if IND is a valid index.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
isinf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 276
 -- Mapping Function: isinf (X)
     Return a logical array which is true where the elements of X are
     are infinite and false where they are not.  For example:

          isinf ([13, Inf, NA, NaN])
                => [ 0, 1, 0, 0 ]

     See also: isfinite, isnan, isna.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a logical array which is true where the elements of X are are
infinite an



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
isinteger


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 295
 -- Built-in Function: isinteger (X)
     Return true if X is an integer object (int8, uint8, int16, etc.).
     Note that 'isinteger (14)' is false because numeric constants in
     Octave are double precision floating point values.

     See also: isfloat, ischar, islogical, isnumeric, isa.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Return true if X is an integer object (int8, uint8, int16, etc.).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
isjava


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 125
 -- Built-in Function: isjava (X)
     Return true if X is a Java object.

     See also: class, typeinfo, isa, javaObject.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Return true if X is a Java object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
iskeyword


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 211
 -- Built-in Function: iskeyword ()
 -- Built-in Function: iskeyword (NAME)
     Return true if NAME is an Octave keyword.  If NAME is omitted,
     return a list of keywords.

     See also: isvarname, exist.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Return true if NAME is an Octave keyword.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
islogical


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 175
 -- Built-in Function: islogical (X)
 -- Built-in Function: isbool (X)
     Return true if X is a logical object.

     See also: isfloat, isinteger, ischar, isnumeric, isa.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Return true if X is a logical object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
islower


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 211
 -- Mapping Function: islower (S)
     Return a logical array which is true where the elements of S are
     lowercase letters and false where they are not.

     See also: isupper, isalpha, isletter, isalnum.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a logical array which is true where the elements of S are
lowercase lette



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ismatrix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 356
 -- Built-in Function: ismatrix (A)
     Return true if A is a numeric, logical, or character matrix.
     Scalars (1x1 matrices) and vectors (1xN or Nx1 matrices) are
     subsets of the more general N-dimensional matrix and 'ismatrix'
     will return true for these objects as well.

     See also: isscalar, isvector, iscell, isstruct, issparse, isa.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Return true if A is a numeric, logical, or character matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ismethod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 173
 -- Built-in Function: ismethod (X, METHOD)
     Return true if X is a class object and the string METHOD is a
     method of this class.

     See also: isprop, isobject.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return true if X is a class object and the string METHOD is a method of
this cla



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
isna


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 281
 -- Mapping Function: isna (X)
     Return a logical array which is true where the elements of X are NA
     (missing) values and false where they are not.  For example:

          isna ([13, Inf, NA, NaN])
               => [ 0, 0, 1, 0 ]

     See also: isnan, isinf, isfinite.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a logical array which is true where the elements of X are NA
(missing) va



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
isnan


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 322
 -- Mapping Function: isnan (X)
     Return a logical array which is true where the elements of X are
     NaN values and false where they are not.  NA values are also
     considered NaN values.  For example:

          isnan ([13, Inf, NA, NaN])
                => [ 0, 0, 1, 1 ]

     See also: isna, isinf, isfinite.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a logical array which is true where the elements of X are NaN
values and 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
isnull


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 557
 -- Built-in Function: isnull (X)
     Return true if X is a special null matrix, string, or single quoted
     string.  Indexed assignment with such a value on the right-hand
     side should delete array elements.  This function should be used
     when overloading indexed assignment for user-defined classes
     instead of 'isempty', to distinguish the cases:

     'A(I) = []'
          This should delete elements if 'I' is nonempty.

     'X = []; A(I) = X'
          This should give an error if 'I' is nonempty.

     See also: isempty, isindex.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Return true if X is a special null matrix, string, or single quoted
string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
isnumeric


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 299
 -- Built-in Function: isnumeric (X)
     Return true if X is a numeric object, i.e., an integer, real, or
     complex array.  Logical and character arrays are not considered to
     be numeric.

     See also: isinteger, isfloat, isreal, iscomplex, islogical, ischar,
     iscell, isstruct, isa.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
Return true if X is a numeric object, i.e., an integer, real, or complex
array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isobject


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 126
 -- Built-in Function: isobject (X)
     Return true if X is a class object.

     See also: class, typeinfo, isa, ismethod.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Return true if X is a class object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isprint


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 223
 -- Mapping Function: isprint (S)
     Return a logical array which is true where the elements of S are
     printable characters (including the space character) and false
     where they are not.

     See also: isgraph.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a logical array which is true where the elements of S are
printable chara



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ispunct


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 215
 -- Mapping Function: ispunct (S)
     Return a logical array which is true where the elements of S are
     punctuation characters and false where they are not.

     See also: isalpha, isdigit, isspace, iscntrl.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a logical array which is true where the elements of S are
punctuation cha



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
isreal


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 223
 -- Built-in Function: isreal (X)
     Return true if X is a non-complex matrix or scalar.  For
     compatibility with MATLAB, this includes logical and character
     matrices.

     See also: iscomplex, isnumeric, isa.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Return true if X is a non-complex matrix or scalar.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
issorted


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 585
 -- Built-in Function: issorted (A)
 -- Built-in Function: issorted (A, MODE)
 -- Built-in Function: issorted (A, "rows", MODE)
     Return true if the array is sorted according to MODE, which may be
     either "ascending", "descending", or "either".  By default, MODE is
     "ascending".  NaNs are treated in the same manner as 'sort'.

     If the optional argument "rows" is supplied, check whether the
     array is sorted by rows as output by the function 'sortrows' (with
     no options).

     This function does not support sparse matrices.

     See also: sort, sortrows.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return true if the array is sorted according to MODE, which may be
either "ascen



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isspace


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 286
 -- Mapping Function: isspace (S)
     Return a logical array which is true where the elements of S are
     whitespace characters (space, formfeed, newline, carriage return,
     tab, and vertical tab) and false where they are not.

     See also: iscntrl, ispunct, isalpha, isdigit.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a logical array which is true where the elements of S are
whitespace char



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
issparse


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 105
 -- Built-in Function: issparse (X)
     Return true if X is a sparse matrix.

     See also: ismatrix.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Return true if X is a sparse matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isstruct


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 135
 -- Built-in Function: isstruct (X)
     Return true if X is a structure or a structure array.

     See also: ismatrix, iscell, isa.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Return true if X is a structure or a structure array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
isupper


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 211
 -- Mapping Function: isupper (S)
     Return a logical array which is true where the elements of S are
     uppercase letters and false where they are not.

     See also: islower, isalpha, isletter, isalnum.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a logical array which is true where the elements of S are
uppercase lette



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
isvarname


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 131
 -- Built-in Function: isvarname (NAME)
     Return true if NAME is a valid variable name.

     See also: iskeyword, exist, who.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Return true if NAME is a valid variable name.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
isxdigit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 173
 -- Mapping Function: isxdigit (S)
     Return a logical array which is true where the elements of S are
     hexadecimal digits (0-9 and a-fA-F).

     See also: isdigit.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a logical array which is true where the elements of S are
hexadecimal dig



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1
j


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 957
 -- Built-in Function: I
 -- Built-in Function: I (N)
 -- Built-in Function: I (N, M)
 -- Built-in Function: I (N, M, K, ...)
 -- Built-in Function: I (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are
     all equal to the pure imaginary unit, defined as 'sqrt (-1)'.

     I, and its equivalents i, j, and J, are functions so any of the
     names may be reused for other purposes (such as i for a counter
     variable).

     When called with no arguments, return a scalar with the value i.
     When called with a single argument, return a square matrix with the
     dimension specified.  When called with more than one scalar
     argument the first two arguments are taken as the number of rows
     and columns and any further arguments specify additional matrix
     dimensions.  The optional argument CLASS specifies the return type
     and may be either "double" or "single".

     See also: e, pi, log, exp.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a scalar, matrix, or N-dimensional array whose elements are all
equal to 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
java2mat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
 -- Built-in Function: java2mat (JAVAOBJ)
     Undocumented internal function.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Undocumented internal function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
javaMethod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 706
 -- Built-in Function: RET = javaMethod (METHODNAME, OBJ)
 -- Built-in Function: RET = javaMethod (METHODNAME, OBJ, ARG1, ...)
     Invoke the method METHODNAME on the Java object OBJ with the
     arguments ARG1, ... For static methods, OBJ can be a string
     representing the fully qualified name of the corresponding class.
     The function returns the result of the method invocation.

     When OBJ is a regular Java object, structure-like indexing can be
     used as a shortcut syntax.  For instance, the two following
     statements are equivalent

            ret = javaMethod ("method1", x, 1.0, "a string")
            ret = x.method1 (1.0, "a string")

     See also: methods, javaObject.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Invoke the method METHODNAME on the Java object OBJ with the arguments
ARG1, ...



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
javaObject


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 536
 -- Built-in Function: JOBJ = javaObject (CLASSNAME)
 -- Built-in Function: JOBJ = javaObject (CLASSNAME, ARG1, ...)
     Create a Java object of class CLASSSNAME, by calling the class
     constructor with the arguments ARG1, ...

     The first example below creates an uninitialized object, while the
     second example supplies an initial argument to the constructor.

          x = javaObject ("java.lang.StringBuffer")
          x = javaObject ("java.lang.StringBuffer", "Initial string")

     See also: javaMethod, javaArray.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Create a Java object of class CLASSSNAME, by calling the class
constructor with 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
java_matrix_autoconversion


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 646
 -- Built-in Function: VAL = java_matrix_autoconversion ()
 -- Built-in Function: OLD_VAL = java_matrix_autoconversion (NEW_VAL)
 -- Built-in Function: java_matrix_autoconversion (NEW_VAL, "local")
     Query or set the internal variable that controls whether Java
     arrays are automatically converted to Octave matrices.  The default
     value is false.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: java_unsigned_autoconversion, debug_java.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that controls whether Java arrays are
automat



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
java_unsigned_autoconversion


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 787
 -- Built-in Function: VAL = java_unsigned_autoconversion ()
 -- Built-in Function: OLD_VAL = java_unsigned_autoconversion (NEW_VAL)
 -- Built-in Function: java_unsigned_autoconversion (NEW_VAL, "local")
     Query or set the internal variable that controls how integer
     classes are converted when 'java_matrix_autoconversion' is enabled.
     When enabled, Java arrays of class Byte or Integer are converted to
     matrices of class uint8 or uint32 respectively.  The default value
     is true.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: java_matrix_autoconversion, debug_java.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that controls how integer classes are
convert



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
jit_enable


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 501
 -- Built-in Function: VAL = jit_enable ()
 -- Built-in Function: OLD_VAL = jit_enable (NEW_VAL)
 -- Built-in Function: jit_enable (NEW_VAL, "local")
     Query or set the internal variable that enables Octave's JIT
     compiler.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: jit_startcnt, debug_jit.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Query or set the internal variable that enables Octave's JIT compiler.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
jit_startcnt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 747
 -- Built-in Function: VAL = jit_startcnt ()
 -- Built-in Function: OLD_VAL = jit_startcnt (NEW_VAL)
 -- Built-in Function: jit_startcnt (NEW_VAL, "local")
     Query or set the internal variable that determines whether JIT
     compilation will take place for a specific loop.  Because
     compilation is a costly operation it does not make sense to employ
     JIT when the loop count is low.  By default only loops with greater
     than 1000 iterations will be accelerated.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: jit_enable, debug_jit.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that determines whether JIT
compilation will 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
kbhit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 490
 -- Built-in Function: kbhit ()
 -- Built-in Function: kbhit (1)
     Read a single keystroke from the keyboard.  If called with an
     argument, don't wait for a keypress.  For example,

          x = kbhit ();

     will set X to the next character typed at the keyboard as soon as
     it is typed.

          x = kbhit (1);

     is identical to the above example, but doesn't wait for a keypress,
     returning the empty string if no key is available.

     See also: input, pause.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Read a single keystroke from the keyboard.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
keyboard


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 718
 -- Built-in Function: keyboard ()
 -- Built-in Function: keyboard ("PROMPT")
     This function is normally used for simple debugging.  When the
     'keyboard' function is executed, Octave prints a prompt and waits
     for user input.  The input strings are then evaluated and the
     results are printed.  This makes it possible to examine the values
     of variables within a function, and to assign new values if
     necessary.  To leave the prompt and return to normal execution type
     'return' or 'dbcont'.  The 'keyboard' function does not return an
     exit status.

     If 'keyboard' is invoked without arguments, a default prompt of
     'debug> ' is used.

     See also: dbstop, dbcont, dbquit.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
This function is normally used for simple debugging.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
kill


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 583
 -- Built-in Function: [ERR, MSG] = kill (PID, SIG)
     Send signal SIG to process PID.

     If PID is positive, then signal SIG is sent to PID.

     If PID is 0, then signal SIG is sent to every process in the
     process group of the current process.

     If PID is -1, then signal SIG is sent to every process except
     process 1.

     If PID is less than -1, then signal SIG is sent to every process in
     the process group -PID.

     If SIG is 0, then no signal is sent, but error checking is still
     performed.

     Return 0 if successful, otherwise return -1.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Send signal SIG to process PID.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
kron


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 558
 -- Built-in Function: kron (A, B)
 -- Built-in Function: kron (A1, A2, ...)
     Form the Kronecker product of two or more matrices, defined block
     by block as

          x = [ a(i,j)*b ]

     For example:

          kron (1:4, ones (3, 1))
               =>  1  2  3  4
                   1  2  3  4
                   1  2  3  4

     If there are more than two input arguments A1, A2, ..., AN the
     Kronecker product is computed as

          kron (kron (A1, A2), ..., AN)

     Since the Kronecker product is associative, this is well-defined.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
Form the Kronecker product of two or more matrices, defined block by
block as



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
lasterr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 437
 -- Built-in Function: [MSG, MSGID] = lasterr ()
 -- Built-in Function: lasterr (MSG)
 -- Built-in Function: lasterr (MSG, MSGID)
     Query or set the last error message.  When called without input
     arguments, return the last error message and message identifier.
     With one argument, set the last error message to MSG.  With two
     arguments, also set the last message identifier.

     See also: lasterror, error, lastwarn.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Query or set the last error message.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
lasterror


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1432
 -- Built-in Function: LASTERR = lasterror ()
 -- Built-in Function: lasterror (ERR)
 -- Built-in Function: lasterror ("reset")
     Query or set the last error message structure.  When called without
     arguments, return a structure containing the last error message and
     other information related to this error.  The elements of the
     structure are:

     'message'
          The text of the last error message

     'identifier'
          The message identifier of this error message

     'stack'
          A structure containing information on where the message
          occurred.  This may be an empty structure if the information
          cannot be obtained.  The fields of the structure are:

          'file'
               The name of the file where the error occurred

          'name'
               The name of function in which the error occurred

          'line'
               The line number at which the error occurred

          'column'
               An optional field with the column number at which the
               error occurred

     The last error structure may be set by passing a scalar structure,
     ERR, as input.  Any fields of ERR that match those above are set
     while any unspecified fields are initialized with default values.

     If 'lasterror' is called with the argument "reset", all fields are
     set to their default values.

     See also: lasterr, error, lastwarn.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Query or set the last error message structure.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
lastwarn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 447
 -- Built-in Function: [MSG, MSGID] = lastwarn ()
 -- Built-in Function: lastwarn (MSG)
 -- Built-in Function: lastwarn (MSG, MSGID)
     Query or set the last warning message.  When called without input
     arguments, return the last warning message and message identifier.
     With one argument, set the last warning message to MSG.  With two
     arguments, also set the last message identifier.

     See also: warning, lasterror, lasterr.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Query or set the last warning message.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
ldivide


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 195
 -- Built-in Function: ldivide (X, Y)
     Return the element-by-element left division of X and Y.  This
     function and x .\ y are equivalent.

     See also: rdivide, mldivide, times, plus.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Return the element-by-element left division of X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
le


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 116
 -- Built-in Function: le (X, Y)
     This function is equivalent to 'x <= y'.

     See also: eq, ge, gt, ne, lt.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
This function is equivalent to 'x <= y'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
length


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 363
 -- Built-in Function: length (A)
     Return the length of the object A.

     The length is 0 for empty objects, 1 for scalars, and the number of
     elements for vectors.  For matrix objects, the length is the number
     of rows or columns, whichever is greater (this odd definition is
     used for compatibility with MATLAB).

     See also: numel, size.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Return the length of the object A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
lgamma


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 163
 -- Mapping Function: lgamma (X)
 -- Mapping Function: gammaln (X)
     Return the natural logarithm of the gamma function of X.

     See also: gamma, gammainc.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Return the natural logarithm of the gamma function of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
link


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 352
 -- Built-in Function: link OLD NEW
 -- Built-in Function: [ERR, MSG] = link (OLD, NEW)
     Create a new link (also known as a hard link) to an existing file.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise, ERR
     is nonzero and MSG contains a system-dependent error message.

     See also: symlink, unlink, readlink, lstat.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Create a new link (also known as a hard link) to an existing file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
linspace


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 778
 -- Built-in Function: linspace (BASE, LIMIT)
 -- Built-in Function: linspace (BASE, LIMIT, N)
     Return a row vector with N linearly spaced elements between BASE
     and LIMIT.  If the number of elements is greater than one, then the
     endpoints BASE and LIMIT are always included in the range.  If BASE
     is greater than LIMIT, the elements are stored in decreasing order.
     If the number of points is not specified, a value of 100 is used.

     The 'linspace' function always returns a row vector if both BASE
     and LIMIT are scalars.  If one, or both, of them are column
     vectors, 'linspace' returns a matrix.

     For compatibility with MATLAB, return the second argument (LIMIT)
     if fewer than two values are requested.

     See also: logspace.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Return a row vector with N linearly spaced elements between BASE and
LIMIT.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
list_in_columns


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1071
 -- Built-in Function: list_in_columns (ARG, WIDTH, PREFIX)
     Return a string containing the elements of ARG listed in columns
     with an overall maximum width of WIDTH and optional prefix PREFIX.
     The argument ARG must be a cell array of character strings or a
     character array.  If WIDTH is not specified or is an empty matrix,
     or less than or equal to zero, the width of the terminal screen is
     used.  Newline characters are used to break the lines in the output
     string.  For example:

          list_in_columns ({"abc", "def", "ghijkl", "mnop", "qrs", "tuv"}, 20)
               => abc     mnop
                  def     qrs
                  ghijkl  tuv

          whos ans
               =>
               Variables in the current scope:

                 Attr Name        Size                     Bytes  Class
                 ==== ====        ====                     =====  =====
                      ans         1x37                        37  char

               Total is 37 elements using 37 bytes

     See also: terminal_size.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a string containing the elements of ARG listed in columns with an
overall



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
load


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3860
 -- Command: load file
 -- Command: load options file
 -- Command: load options file v1 v2 ...
 -- Command: S = load ("options", "file", "v1", "v2", ...)
 -- Command: load file options
 -- Command: load file options v1 v2 ...
 -- Command: S = load ("file", "options", "v1", "v2", ...)
     Load the named variables V1, V2, ..., from the file FILE.  If no
     variables are specified then all variables found in the file will
     be loaded.  As with 'save', the list of variables to extract can be
     full names or use a pattern syntax.  The format of the file is
     automatically detected but may be overridden by supplying the
     appropriate option.

     If load is invoked using the functional form

          load ("-option1", ..., "file", "v1", ...)

     then the OPTIONS, FILE, and variable name arguments (V1, ...) must
     be specified as character strings.

     If a variable that is not marked as global is loaded from a file
     when a global symbol with the same name already exists, it is
     loaded in the global symbol table.  Also, if a variable is marked
     as global in a file and a local symbol exists, the local symbol is
     moved to the global symbol table and given the value from the file.

     If invoked with a single output argument, Octave returns data
     instead of inserting variables in the symbol table.  If the data
     file contains only numbers (TAB- or space-delimited columns), a
     matrix of values is returned.  Otherwise, 'load' returns a
     structure with members corresponding to the names of the variables
     in the file.

     The 'load' command can read data stored in Octave's text and binary
     formats, and MATLAB's binary format.  If compiled with zlib
     support, it can also load gzip-compressed files.  It will
     automatically detect the type of file and do conversion from
     different floating point formats (currently only IEEE big and
     little endian, though other formats may be added in the future).

     Valid options for 'load' are listed in the following table.

     '-force'
          This option is accepted for backward compatibility but is
          ignored.  Octave now overwrites variables currently in memory
          with those of the same name found in the file.

     '-ascii'
          Force Octave to assume the file contains columns of numbers in
          text format without any header or other information.  Data in
          the file will be loaded as a single numeric matrix with the
          name of the variable derived from the name of the file.

     '-binary'
          Force Octave to assume the file is in Octave's binary format.

     '-hdf5'
          Force Octave to assume the file is in HDF5 format.  (HDF5 is a
          free, portable binary format developed by the National Center
          for Supercomputing Applications at the University of
          Illinois.)  Note that Octave can read HDF5 files not created
          by itself, but may skip some datasets in formats that it
          cannot support.  This format is only available if Octave was
          built with a link to the HDF5 libraries.

     '-import'
          This option is accepted for backward compatibility but is
          ignored.  Octave can now support multi-dimensional HDF data
          and automatically modifies variable names if they are invalid
          Octave identifiers.

     '-mat'
     '-mat-binary'
     '-6'
     '-v6'
     '-7'
     '-v7'
          Force Octave to assume the file is in MATLAB's version 6 or 7
          binary format.

     '-mat4-binary'
     '-4'
     '-v4'
     '-V4'
          Force Octave to assume the file is in the binary format
          written by MATLAB version 4.

     '-text'
          Force Octave to assume the file is in Octave's text format.

     See also: save, dlmwrite, csvwrite, fwrite.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Load the named variables V1, V2, ..., from the file FILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
loaded_graphics_toolkits


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 165
 -- Built-in Function: loaded_graphics_toolkits ()
     Return a cell array of the currently loaded graphics toolkits.

     See also: available_graphics_toolkits.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Return a cell array of the currently loaded graphics toolkits.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
localtime


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 719
 -- Built-in Function: TM_STRUCT = localtime (T)
     Given a value returned from 'time', or any non-negative integer,
     return a time structure corresponding to the local time zone.

          localtime (time ())
               => {
                     usec = 0
                     sec = 6
                     min = 15
                     hour = 1
                     mday = 17
                     mon = 1
                     year = 97
                     wday = 1
                     yday = 47
                     isdst = 0
                     zone = CST
                  }

     See also: strftime, strptime, gmtime, mktime, time, now, date,
     clock, datenum, datestr, datevec, calendar, weekday.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Given a value returned from 'time', or any non-negative integer, return
a time s



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
log


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 218
 -- Mapping Function: log (X)
     Compute the natural logarithm, 'ln (X)', for each element of X.  To
     compute the matrix logarithm, see *note Linear Algebra::.

     See also: exp, log1p, log2, log10, logspace.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Compute the natural logarithm, 'ln (X)', for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
log10


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 132
 -- Mapping Function: log10 (X)
     Compute the base-10 logarithm of each element of X.

     See also: log, log2, logspace, exp.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Compute the base-10 logarithm of each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
log1p


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 133
 -- Mapping Function: log1p (X)
     Compute 'log (1 + X)' accurately in the neighborhood of zero.

     See also: log, exp, expm1.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Compute 'log (1 + X)' accurately in the neighborhood of zero.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
log2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 337
 -- Mapping Function: log2 (X)
 -- Mapping Function: [F, E] = log2 (X)
     Compute the base-2 logarithm of each element of X.

     If called with two output arguments, split X into binary mantissa
     and exponent so that '1/2 <= abs(f) < 1' and E is an integer.  If
     'x = 0', 'f = e = 0'.

     See also: pow2, log, log10, exp.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Compute the base-2 logarithm of each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
logical


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 418
 -- Built-in Function: logical (X)
     Convert the numeric object X to logical type.

     Any non-zero values will be converted to true (1) while zero values
     will be converted to false (0).  The non-numeric value NaN cannot
     be converted and will produce an error.

     Compatibility Note: Octave accepts complex values as input, whereas
     MATLAB issues an error.

     See also: double, single, char.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Convert the numeric object X to logical type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
lookup


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1650
 -- Built-in Function: IDX = lookup (TABLE, Y)
 -- Built-in Function: IDX = lookup (TABLE, Y, OPT)
     Lookup values in a sorted table.  Usually used as a prelude to
     interpolation.

     If table is increasing and 'idx = lookup (table, y)', then
     'table(idx(i)) <= y(i) < table(idx(i+1))' for all 'y(i)' within the
     table.  If 'y(i) < table(1)' then 'idx(i)' is 0.  If 'y(i) >=
     table(end)' or 'isnan (y(i))' then 'idx(i)' is 'n'.

     If the table is decreasing, then the tests are reversed.  For
     non-strictly monotonic tables, empty intervals are always skipped.
     The result is undefined if TABLE is not monotonic, or if TABLE
     contains a NaN.

     The complexity of the lookup is O(M*log(N)) where N is the size of
     TABLE and M is the size of Y.  In the special case when Y is also
     sorted, the complexity is O(min(M*log(N),M+N)).

     TABLE and Y can also be cell arrays of strings (or Y can be a
     single string).  In this case, string lookup is performed using
     lexicographical comparison.

     If OPTS is specified, it must be a string with letters indicating
     additional options.

     'm'
          'table(idx(i)) == val(i)' if 'val(i)' occurs in table;
          otherwise, 'idx(i)' is zero.

     'b'
          'idx(i)' is a logical 1 or 0, indicating whether 'val(i)' is
          contained in table or not.

     'l'
          For numeric lookups the leftmost subinterval shall be extended
          to infinity (i.e., all indices at least 1)

     'r'
          For numeric lookups the rightmost subinterval shall be
          extended to infinity (i.e., all indices at most n-1).




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Lookup values in a sorted table.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
lower


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 362
 -- Mapping Function: tolower (S)
 -- Mapping Function: lower (S)
     Return a copy of the string or cell string S, with each uppercase
     character replaced by the corresponding lowercase one;
     non-alphabetic characters are left unchanged.  For example:

          tolower ("MiXeD cAsE 123")
                => "mixed case 123"

     See also: toupper.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a copy of the string or cell string S, with each uppercase
character repl



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
lsode


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2751
 -- Built-in Function: [X, ISTATE, MSG] = lsode (FCN, X_0, T)
 -- Built-in Function: [X, ISTATE, MSG] = lsode (FCN, X_0, T, T_CRIT)
     Solve the set of differential equations

          dx
          -- = f (x, t)
          dt

     with

          x(t_0) = x_0

     The solution is returned in the matrix X, with each row
     corresponding to an element of the vector T.  The first element of
     T should be t_0 and should correspond to the initial state of the
     system X_0, so that the first row of the output is X_0.

     The first argument, FCN, is a string, inline, or function handle
     that names the function f to call to compute the vector of right
     hand sides for the set of equations.  The function must have the
     form

          XDOT = f (X, T)

     in which XDOT and X are vectors and T is a scalar.

     If FCN is a two-element string array or a two-element cell array of
     strings, inline functions, or function handles, the first element
     names the function f described above, and the second element names
     a function to compute the Jacobian of f.  The Jacobian function
     must have the form

          JAC = j (X, T)

     in which JAC is the matrix of partial derivatives

                       | df_1  df_1       df_1 |
                       | ----  ----  ...  ---- |
                       | dx_1  dx_2       dx_N |
                       |                       |
                       | df_2  df_2       df_2 |
                       | ----  ----  ...  ---- |
                df_i   | dx_1  dx_2       dx_N |
          jac = ---- = |                       |
                dx_j   |  .    .     .    .    |
                       |  .    .      .   .    |
                       |  .    .       .  .    |
                       |                       |
                       | df_N  df_N       df_N |
                       | ----  ----  ...  ---- |
                       | dx_1  dx_2       dx_N |

     The second and third arguments specify the initial state of the
     system, x_0, and the initial value of the independent variable t_0.

     The fourth argument is optional, and may be used to specify a set
     of times that the ODE solver should not integrate past.  It is
     useful for avoiding difficulties with singularities and points
     where there is a discontinuity in the derivative.

     After a successful computation, the value of ISTATE will be 2
     (consistent with the Fortran version of LSODE).

     If the computation is not successful, ISTATE will be something
     other than 2 and MSG will contain additional information.

     You can use the function 'lsode_options' to set optional parameters
     for 'lsode'.

     See also: daspk, dassl, dasrt.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Solve the set of differential equations



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
lsode_options


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2181
 -- Built-in Function: lsode_options ()
 -- Built-in Function: val = lsode_options (OPT)
 -- Built-in Function: lsode_options (OPT, VAL)
     Query or set options for the function 'lsode'.  When called with no
     arguments, the names of all available options and their current
     values are displayed.  Given one argument, return the value of the
     corresponding option.  When called with two arguments,
     'lsode_options' set the option OPT to value VAL.

     Options include

     '"absolute tolerance"'
          Absolute tolerance.  May be either vector or scalar.  If a
          vector, it must match the dimension of the state vector.

     '"relative tolerance"'
          Relative tolerance parameter.  Unlike the absolute tolerance,
          this parameter may only be a scalar.

          The local error test applied at each integration step is

                 abs (local error in x(i)) <= ...
                     rtol * abs (y(i)) + atol(i)

     '"integration method"'
          A string specifying the method of integration to use to solve
          the ODE system.  Valid values are

          "adams"
          "non-stiff"
               No Jacobian used (even if it is available).

          "bdf"
          "stiff"
               Use stiff backward differentiation formula (BDF) method.
               If a function to compute the Jacobian is not supplied,
               'lsode' will compute a finite difference approximation of
               the Jacobian matrix.

     '"initial step size"'
          The step size to be attempted on the first step (default is
          determined automatically).

     '"maximum order"'
          Restrict the maximum order of the solution method.  If using
          the Adams method, this option must be between 1 and 12.
          Otherwise, it must be between 1 and 5, inclusive.

     '"maximum step size"'
          Setting the maximum stepsize will avoid passing over very
          large regions (default is not specified).

     '"minimum step size"'
          The minimum absolute step size allowed (default is 0).

     '"step limit"'
          Maximum number of steps allowed (default is 100000).




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Query or set options for the function 'lsode'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
lstat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 300
 -- Built-in Function: INFO = lstat (SYMLINK)
 -- Built-in Function: [INFO, ERR, MSG] = lstat (SYMLINK)
     Return a structure INFO containing information about the symbolic
     link SYMLINK.

     The function outputs are described in the documentation for 'stat'.

     See also: stat, symlink.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
Return a structure INFO containing information about the symbolic link
SYMLINK.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
lt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 115
 -- Built-in Function: lt (X, Y)
     This function is equivalent to 'x < y'.

     See also: le, eq, ge, gt, ne.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
This function is equivalent to 'x < y'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
lu


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2597
 -- Built-in Function: [L, U] = lu (A)
 -- Built-in Function: [L, U, P] = lu (A)
 -- Built-in Function: [L, U, P, Q] = lu (S)
 -- Built-in Function: [L, U, P, Q, R] = lu (S)
 -- Built-in Function: [...] = lu (S, THRES)
 -- Built-in Function: Y = lu (...)
 -- Built-in Function: [...] = lu (..., "vector")
     Compute the LU decomposition of A.  If A is full subroutines from
     LAPACK are used and if A is sparse then UMFPACK is used.  The
     result is returned in a permuted form, according to the optional
     return value P.  For example, given the matrix 'a = [1, 2; 3, 4]',

          [l, u, p] = lu (A)

     returns

          l =

            1.00000  0.00000
            0.33333  1.00000

          u =

            3.00000  4.00000
            0.00000  0.66667

          p =

            0  1
            1  0

     The matrix is not required to be square.

     When called with two or three output arguments and a spare input
     matrix, 'lu' does not attempt to perform sparsity preserving column
     permutations.  Called with a fourth output argument, the sparsity
     preserving column transformation Q is returned, such that 'P * A *
     Q = L * U'.

     Called with a fifth output argument and a sparse input matrix, 'lu'
     attempts to use a scaling factor R on the input matrix such that 'P
     * (R \ A) * Q = L * U'.  This typically leads to a sparser and more
     stable factorization.

     An additional input argument THRES, that defines the pivoting
     threshold can be given.  THRES can be a scalar, in which case it
     defines the UMFPACK pivoting tolerance for both symmetric and
     unsymmetric cases.  If THRES is a 2-element vector, then the first
     element defines the pivoting tolerance for the unsymmetric UMFPACK
     pivoting strategy and the second for the symmetric strategy.  By
     default, the values defined by 'spparms' are used ([0.1, 0.001]).

     Given the string argument "vector", 'lu' returns the values of P
     and Q as vector values, such that for full matrix, 'A (P,:) = L *
     U', and 'R(P,:) * A (:, Q) = L * U'.

     With two output arguments, returns the permuted forms of the upper
     and lower triangular matrices, such that 'A = L * U'.  With one
     output argument Y, then the matrix returned by the LAPACK routines
     is returned.  If the input matrix is sparse then the matrix L is
     embedded into U to give a return value similar to the full case.
     For both full and sparse matrices, 'lu' loses the permutation
     information.

     See also: luupdate, chol, hess, qr, qz, schur, svd.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Compute the LU decomposition of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
luinc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2420
 -- Built-in Function: [L, U, P, Q] = luinc (A, '0')
 -- Built-in Function: [L, U, P, Q] = luinc (A, DROPTOL)
 -- Built-in Function: [L, U, P, Q] = luinc (A, OPTS)
     Produce the incomplete LU factorization of the sparse matrix A.
     Two types of incomplete factorization are possible, and the type is
     determined by the second argument to 'luinc'.

     Called with a second argument of '0', the zero-level incomplete
     LU factorization is produced.  This creates a factorization of A
     where the position of the non-zero arguments correspond to the same
     positions as in the matrix A.

     Alternatively, the fill-in of the incomplete LU factorization can
     be controlled through the variable DROPTOL or the structure OPTS.
     The UMFPACK multifrontal factorization code by Tim A. Davis is used
     for the incomplete LU factorization, (availability
     <http://www.cise.ufl.edu/research/sparse/umfpack/>)

     DROPTOL determines the values below which the values in the LU 
     factorization are dropped and replaced by zero.  It must be a
     positive scalar, and any values in the factorization whose absolute
     value are less than this value are dropped, expect if leaving them
     increase the sparsity of the matrix.  Setting DROPTOL to zero
     results in a complete LU factorization which is the default.

     OPTS is a structure containing one or more of the fields

     'droptol'
          The drop tolerance as above.  If OPTS only contains 'droptol'
          then this is equivalent to using the variable DROPTOL.

     'milu'
          A logical variable flagging whether to use the modified
          incomplete LU  factorization.  In the case that 'milu' is
          true, the dropped values are subtracted from the diagonal of
          the matrix U of the factorization.  The default is 'false'.

     'udiag'
          A logical variable that flags whether zero elements on the
          diagonal of U should be replaced with DROPTOL to attempt to
          avoid singular factors.  The default is 'false'.

     'thresh'
          Defines the pivot threshold in the interval [0,1].  Values
          outside that range are ignored.

     All other fields in OPTS are ignored.  The outputs from 'luinc' are
     the same as for 'lu'.

     Given the string argument "vector", 'luinc' returns the values of P
     Q as vector values.

     See also: sparse, lu.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Produce the incomplete LU factorization of the sparse matrix A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
luupdate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1229
 -- Built-in Function: [L, U] = luupdate (L, U, X, Y)
 -- Built-in Function: [L, U, P] = luupdate (L, U, P, X, Y)
     Given an LU factorization of a real or complex matrix A = L*U,
     L lower unit trapezoidal and U upper trapezoidal, return the
     LU factorization of A + X*Y.', where X and Y are column vectors
     (rank-1 update) or matrices with equal number of columns (rank-k
     update).  Optionally, row-pivoted updating can be used by supplying
     a row permutation (pivoting) matrix P; in that case, an updated
     permutation matrix is returned.  Note that if L, U, P is a pivoted
     LU factorization as obtained by 'lu':

          [L, U, P] = lu (A);

     then a factorization of A+X*Y.'  can be obtained either as

          [L1, U1] = lu (L, U, P*X, Y)

     or

          [L1, U1, P1] = lu (L, U, P, X, Y)

     The first form uses the unpivoted algorithm, which is faster, but
     less stable.  The second form uses a slower pivoted algorithm,
     which is more stable.

     The matrix case is done as a sequence of rank-1 updates; thus, for
     large enough k, it will be both faster and more accurate to
     recompute the factorization from scratch.

     See also: lu, cholupdate, qrupdate.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Given an LU factorization of a real or complex matrix A = L*U, L lower
unit trap



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
make_absolute_filename


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 285
 -- Built-in Function: make_absolute_filename (FILE)
     Return the full name of FILE beginning from the root of the file
     system.  No check is done for the existence of FILE.

     See also: canonicalize_file_name, is_absolute_filename,
     is_rooted_relative_filename, isdir.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Return the full name of FILE beginning from the root of the file system.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
makeinfo_program


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 663
 -- Built-in Function: VAL = makeinfo_program ()
 -- Built-in Function: OLD_VAL = makeinfo_program (NEW_VAL)
 -- Built-in Function: makeinfo_program (NEW_VAL, "local")
     Query or set the internal variable that specifies the name of the
     program that Octave runs to format help text containing Texinfo
     markup commands.  The default value is 'makeinfo'.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: texi_macros_file, info_file, info_program, doc, help.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that specifies the name of the
program that O



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
mat2cell


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1002
 -- Built-in Function: C = mat2cell (A, M, N)
 -- Built-in Function: C = mat2cell (A, D1, D2, ...)
 -- Built-in Function: C = mat2cell (A, R)
     Convert the matrix A to a cell array.  If A is 2-D, then it is
     required that 'sum (M) == size (A, 1)' and 'sum (N) == size (A,
     2)'.  Similarly, if A is multi-dimensional and the number of
     dimensional arguments is equal to the dimensions of A, then it is
     required that 'sum (DI) == size (A, i)'.

     Given a single dimensional argument R, the other dimensional
     arguments are assumed to equal 'size (A,I)'.

     An example of the use of mat2cell is

          mat2cell (reshape (1:16,4,4), [3,1], [3,1])
          =>
          {
             [1,1] =

                1   5   9
                2   6  10
                3   7  11

             [2,1] =

                4   8  12

             [1,2] =

               13
               14
               15

             [2,2] = 16
          }

     See also: num2cell, cell2mat.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Convert the matrix A to a cell array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
matrix_type


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3364
 -- Built-in Function: TYPE = matrix_type (A)
 -- Built-in Function: TYPE = matrix_type (A, "nocompute")
 -- Built-in Function: A = matrix_type (A, TYPE)
 -- Built-in Function: A = matrix_type (A, "upper", PERM)
 -- Built-in Function: A = matrix_type (A, "lower", PERM)
 -- Built-in Function: A = matrix_type (A, "banded", NL, NU)
     Identify the matrix type or mark a matrix as a particular type.
     This allows more rapid solutions of linear equations involving A to
     be performed.  Called with a single argument, 'matrix_type' returns
     the type of the matrix and caches it for future use.  Called with
     more than one argument, 'matrix_type' allows the type of the matrix
     to be defined.

     If the option "nocompute" is given, the function will not attempt
     to guess the type if it is still unknown.  This is useful for
     debugging purposes.

     The possible matrix types depend on whether the matrix is full or
     sparse, and can be one of the following

     "unknown"
          Remove any previously cached matrix type, and mark type as
          unknown.

     "full"
          Mark the matrix as full.

     "positive definite"
          Probable full positive definite matrix.

     "diagonal"
          Diagonal matrix.  (Sparse matrices only)

     "permuted diagonal"
          Permuted Diagonal matrix.  The permutation does not need to be
          specifically indicated, as the structure of the matrix
          explicitly gives this.  (Sparse matrices only)

     "upper"
          Upper triangular.  If the optional third argument PERM is
          given, the matrix is assumed to be a permuted upper triangular
          with the permutations defined by the vector PERM.

     "lower"
          Lower triangular.  If the optional third argument PERM is
          given, the matrix is assumed to be a permuted lower triangular
          with the permutations defined by the vector PERM.

     "banded"
     "banded positive definite"
          Banded matrix with the band size of NL below the diagonal and
          NU above it.  If NL and NU are 1, then the matrix is
          tridiagonal and treated with specialized code.  In addition
          the matrix can be marked as probably a positive definite.
          (Sparse matrices only)

     "singular"
          The matrix is assumed to be singular and will be treated with
          a minimum norm solution.

     Note that the matrix type will be discovered automatically on the
     first attempt to solve a linear equation involving A.  Therefore
     'matrix_type' is only useful to give Octave hints of the matrix
     type.  Incorrectly defining the matrix type will result in
     incorrect results from solutions of linear equations; it is
     entirely *the responsibility of the user* to correctly identify the
     matrix type.

     Also, the test for positive definiteness is a low-cost test for a
     Hermitian matrix with a real positive diagonal.  This does not
     guarantee that the matrix is positive definite, but only that it is
     a probable candidate.  When such a matrix is factorized, a
     Cholesky factorization is first attempted, and if that fails the
     matrix is then treated with an LU factorization.  Once the matrix
     has been factorized, 'matrix_type' will return the correct
     classification of the matrix.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Identify the matrix type or mark a matrix as a particular type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
max


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1156
 -- Built-in Function: max (X)
 -- Built-in Function: max (X, Y)
 -- Built-in Function: max (X, [], DIM)
 -- Built-in Function: max (X, Y, DIM)
 -- Built-in Function: [W, IW] = max (X)
     For a vector argument, return the maximum value.  For a matrix
     argument, return the maximum value from each column, as a row
     vector, or over the dimension DIM if defined, in which case Y
     should be set to the empty matrix (it's ignored otherwise).  For
     two matrices (or a matrix and scalar), return the pair-wise
     maximum.  Thus,

          max (max (X))

     returns the largest element of the matrix X, and

          max (2:5, pi)
              =>  3.1416  3.1416  4.0000  5.0000

     compares each element of the range '2:5' with 'pi', and returns a
     row vector of the maximum values.

     For complex arguments, the magnitude of the elements are used for
     comparison.

     If called with one input and two output arguments, 'max' also
     returns the first index of the maximum value(s).  Thus,

          [x, ix] = max ([1, 3, 5, 2, 5])
              =>  x = 5
                  ix = 3

     See also: min, cummax, cummin.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
For a vector argument, return the maximum value.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
max_recursion_depth


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 607
 -- Built-in Function: VAL = max_recursion_depth ()
 -- Built-in Function: OLD_VAL = max_recursion_depth (NEW_VAL)
 -- Built-in Function: max_recursion_depth (NEW_VAL, "local")
     Query or set the internal limit on the number of times a function
     may be called recursively.  If the limit is exceeded, an error
     message is printed and control returns to the top level.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal limit on the number of times a function may be
called 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
md5sum


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 229
 -- Built-in Function: md5sum (FILE)
 -- Built-in Function: md5sum (STR, OPT)
     Calculate the MD5 sum of the file FILE.  If the second parameter
     OPT exists and is true, then calculate the MD5 sum of the string
     STR.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Calculate the MD5 sum of the file FILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
merge


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 850
 -- Built-in Function: merge (MASK, TVAL, FVAL)
 -- Built-in Function: ifelse (MASK, TVAL, FVAL)
     Merge elements of TRUE_VAL and FALSE_VAL, depending on the value of
     MASK.  If MASK is a logical scalar, the other two arguments can be
     arbitrary values.  Otherwise, MASK must be a logical array, and
     TVAL, FVAL should be arrays of matching class, or cell arrays.  In
     the scalar mask case, TVAL is returned if MASK is true, otherwise
     FVAL is returned.

     In the array mask case, both TVAL and FVAL must be either scalars
     or arrays with dimensions equal to MASK.  The result is constructed
     as follows:

          result(mask) = tval(mask);
          result(! mask) = fval(! mask);

     MASK can also be arbitrary numeric type, in which case it is first
     converted to logical.

     See also: logical, diff.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Merge elements of TRUE_VAL and FALSE_VAL, depending on the value of
MASK.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
mfilename


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 465
 -- Built-in Function: mfilename ()
 -- Built-in Function: mfilename ("fullpath")
 -- Built-in Function: mfilename ("fullpathext")
     Return the name of the currently executing file.

     When called from outside an m-file return the empty string.  Given
     the argument "fullpath", include the directory part of the file
     name, but not the extension.  Given the argument "fullpathext",
     include the directory part of the file name and the extension.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Return the name of the currently executing file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
mgorth


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 328
 -- Built-in Function: [Y, H] = mgorth (X, V)
     Orthogonalize a given column vector X with respect to a set of
     orthonormal vectors comprising the columns of V using the modified
     Gram-Schmidt method.  On exit, Y is a unit vector such that:

            norm (Y) = 1
            V' * Y = 0
            X = [V, Y]*H'




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Orthogonalize a given column vector X with respect to a set of
orthonormal vecto



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
min


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1146
 -- Built-in Function: min (X)
 -- Built-in Function: min (X, Y)
 -- Built-in Function: min (X, [], DIM)
 -- Built-in Function: min (X, Y, DIM)
 -- Built-in Function: [W, IW] = min (X)
     For a vector argument, return the minimum value.  For a matrix
     argument, return the minimum value from each column, as a row
     vector, or over the dimension DIM if defined, in which case Y
     should be set to the empty matrix (it's ignored otherwise).  For
     two matrices (or a matrix and scalar), return the pair-wise
     minimum.  Thus,

          min (min (X))

     returns the smallest element of X, and

          min (2:5, pi)
              =>  2.0000  3.0000  3.1416  3.1416

     compares each element of the range '2:5' with 'pi', and returns a
     row vector of the minimum values.

     For complex arguments, the magnitude of the elements are used for
     comparison.

     If called with one input and two output arguments, 'min' also
     returns the first index of the minimum value(s).  Thus,

          [x, ix] = min ([1, 3, 0, 2, 0])
              =>  x = 0
                  ix = 3

     See also: max, cummin, cummax.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
For a vector argument, return the minimum value.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
minus


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 112
 -- Built-in Function: minus (X, Y)
     This function and x - y are equivalent.

     See also: plus, uminus.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
This function and x - y are equivalent.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
mislocked


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 256
 -- Built-in Function: mislocked ()
 -- Built-in Function: mislocked (FCN)
     Return true if the named function FCN is locked.  If no function is
     named then return true if the current function is locked.

     See also: mlock, munlock, persistent.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Return true if the named function FCN is locked.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
missing_component_hook


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1063
 -- Built-in Function: VAL = missing_component_hook ()
 -- Built-in Function: OLD_VAL = missing_component_hook (NEW_VAL)
 -- Built-in Function: missing_component_hook (NEW_VAL, "local")
     Query or set the internal variable that specifies the function to
     call when a component of Octave is missing.  This can be useful for
     packagers that may split the Octave installation into multiple
     sub-packages, for example, to provide a hint to users for how to
     install the missing components.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     The hook function is expected to be of the form

          FCN (COMPONENT)

     Octave will call FCN with the name of the function that requires
     the component and a string describing the missing component.  The
     hook function should return an error message to be displayed.

     See also: missing_function_hook.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that specifies the function to call
when a co



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
missing_function_hook


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 574
 -- Built-in Function: VAL = missing_function_hook ()
 -- Built-in Function: OLD_VAL = missing_function_hook (NEW_VAL)
 -- Built-in Function: missing_function_hook (NEW_VAL, "local")
     Query or set the internal variable that specifies the function to
     call when an unknown identifier is requested.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: missing_component_hook.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that specifies the function to call
when an u



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
mkdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 530
 -- Built-in Function: mkdir DIR
 -- Built-in Function: mkdir (PARENT, DIR)
 -- Built-in Function: [STATUS, MSG, MSGID] = mkdir (...)
     Create a directory named DIR in the directory PARENT.

     If no PARENT directory is specified the present working directory
     is used.

     If successful, STATUS is 1, and MSG, MSGID are empty character
     strings ("").  Otherwise, STATUS is 0, MSG contains a
     system-dependent error message, and MSGID contains a unique message
     identifier.

     See also: rmdir, pwd, cd.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Create a directory named DIR in the directory PARENT.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
mkfifo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 326
 -- Built-in Function: mkfifo (NAME, MODE)
 -- Built-in Function: [ERR, MSG] = mkfifo (NAME, MODE)
     Create a FIFO special file named NAME with file mode MODE

     If successful, ERR is 0 and MSG is an empty string.  Otherwise, ERR
     is nonzero and MSG contains a system-dependent error message.

     See also: pipe.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Create a FIFO special file named NAME with file mode MODE



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
mkstemp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 947
 -- Built-in Function: [FID, NAME, MSG] = mkstemp (TEMPLATE, DELETE)
     Return the file ID corresponding to a new temporary file with a
     unique name created from TEMPLATE.  The last six characters of
     TEMPLATE must be 'XXXXXX' and these are replaced with a string that
     makes the filename unique.  The file is then created with mode
     read/write and permissions that are system dependent (on GNU/Linux
     systems, the permissions will be 0600 for versions of glibc 2.0.7
     and later).  The file is opened in binary mode and with the 'O_EXCL'
     flag.

     If the optional argument DELETE is supplied and is true, the file
     will be deleted automatically when Octave exits.

     If successful, FID is a valid file ID, NAME is the name of the
     file, and MSG is an empty string.  Otherwise, FID is -1, NAME is
     empty, and MSG contains a system-dependent error message.

     See also: tmpfile, tmpnam, P_tmpdir.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the file ID corresponding to a new temporary file with a unique
name crea



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
mktime


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 374
 -- Built-in Function: SECONDS = mktime (TM_STRUCT)
     Convert a time structure corresponding to the local time to the
     number of seconds since the epoch.  For example:

          mktime (localtime (time ()))
               => 856163706

     See also: strftime, strptime, localtime, gmtime, time, now, date,
     clock, datenum, datestr, datevec, calendar, weekday.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Convert a time structure corresponding to the local time to the number
of second



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
mldivide


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 179
 -- Built-in Function: mldivide (X, Y)
     Return the matrix left division of X and Y.  This function and x \ y
     are equivalent.

     See also: mrdivide, ldivide, rdivide.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Return the matrix left division of X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
mlock


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 153
 -- Built-in Function: mlock ()
     Lock the current function into memory so that it can't be cleared.

     See also: munlock, mislocked, persistent.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Lock the current function into memory so that it can't be cleared.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
mod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 510
 -- Mapping Function: mod (X, Y)
     Compute the modulo of X and Y.  Conceptually this is given by

          x - y .* floor (x ./ y)

     and is written such that the correct modulus is returned for
     integer types.  This function handles negative values correctly.
     That is, 'mod (-1, 3)' is 2, not -1, as 'rem (-1, 3)' returns.
     'mod (X, 0)' returns X.

     An error results if the dimensions of the arguments do not agree,
     or if either of the arguments is complex.

     See also: rem.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Compute the modulo of X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
more


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 316
 -- Command: more
 -- Command: more on
 -- Command: more off
     Turn output pagination on or off.  Without an argument, 'more'
     toggles the current state.  The current state can be determined via
     'page_screen_output'.

     See also: page_screen_output, page_output_immediately, PAGER,
     PAGER_FLAGS.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Turn output pagination on or off.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
mpower


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 195
 -- Built-in Function: mpower (X, Y)
     Return the matrix power operation of X raised to the Y power.  This
     function and x ^ y are equivalent.

     See also: power, mtimes, plus, minus.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Return the matrix power operation of X raised to the Y power.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
mrdivide


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 184
 -- Built-in Function: mrdivide (X, Y)
     Return the matrix right division of X and Y.  This function and x / y
     are equivalent.

     See also: mldivide, rdivide, plus, minus.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return the matrix right division of X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
mtimes


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 436
 -- Built-in Function: mtimes (X, Y)
 -- Built-in Function: mtimes (X1, X2, ...)
     Return the matrix multiplication product of inputs.  This function
     and x * y are equivalent.  If more arguments are given, the
     multiplication is applied cumulatively from left to right:

          (...((x1 * x2) * x3) * ...)

     At least one argument is required.

     See also: times, plus, minus, rdivide, mrdivide, mldivide, mpower.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Return the matrix multiplication product of inputs.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
munlock


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 218
 -- Built-in Function: munlock ()
 -- Built-in Function: munlock (FCN)
     Unlock the named function FCN.  If no function is named then unlock
     the current function.

     See also: mlock, mislocked, persistent.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Unlock the named function FCN.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
nan


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1274
 -- Built-in Function: NaN
 -- Built-in Function: NaN (N)
 -- Built-in Function: NaN (N, M)
 -- Built-in Function: NaN (N, M, K, ...)
 -- Built-in Function: NaN (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are
     all equal to the IEEE symbol NaN (Not a Number).  NaN is the result
     of operations which do not produce a well defined numerical result.
     Common operations which produce a NaN are arithmetic with infinity
     (Inf - Inf), zero divided by zero (0/0), and any operation
     involving another NaN value (5 + NaN).

     Note that NaN always compares not equal to NaN (NaN != NaN). This
     behavior is specified by the IEEE standard for floating point
     arithmetic.  To find NaN values, use the 'isnan' function.

     When called with no arguments, return a scalar with the value
     'NaN'.  When called with a single argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The optional argument CLASS specifies the
     return type and may be either "double" or "single".

     See also: isnan, Inf.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a scalar, matrix, or N-dimensional array whose elements are all
equal to 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
nargin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 796
 -- Built-in Function: nargin ()
 -- Built-in Function: nargin (FCN)
     Within a function, return the number of arguments passed to the
     function.  At the top level, return the number of command line
     arguments passed to Octave.

     If called with the optional argument FCN--a function name or
     handle-- return the declared number of arguments that the function
     can accept.

     If the last argument to FCN is VARARGIN the returned value is
     negative.  For example, the function 'union' for sets is declared
     as

          function [y, ia, ib] = union (a, b, varargin)

          and

          nargin ("union")
          => -3

     Programming Note: 'nargin' does not work on built-in functions.

     See also: nargout, varargin, isargout, varargout, nthargout.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Within a function, return the number of arguments passed to the
function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
nargout


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1103
 -- Built-in Function: nargout ()
 -- Built-in Function: nargout (FCN)
     Within a function, return the number of values the caller expects
     to receive.  If called with the optional argument FCN--a function
     name or handle--return the number of declared output values that
     the function can produce.  If the final output argument is
     VARARGOUT the returned value is negative.

     For example,

          f ()

     will cause 'nargout' to return 0 inside the function 'f' and

          [s, t] = f ()

     will cause 'nargout' to return 2 inside the function 'f'.

     In the second usage,

          nargout (@histc) % or nargout ("histc")

     will return 2, because 'histc' has two outputs, whereas

          nargout (@imread)

     will return -2, because 'imread' has two outputs and the second is
     VARARGOUT.

     At the top level, 'nargout' with no argument is undefined and will
     produce an error.  'nargout' does not work for built-in functions
     and returns -1 for all anonymous functions.

     See also: nargin, varargin, isargout, varargout, nthargout.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
Within a function, return the number of values the caller expects to
receive.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
native_float_format


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 104
 -- Built-in Function: native_float_format ()
     Return the native floating point format as a string




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Return the native floating point format as a string



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
ndims


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 282
 -- Built-in Function: ndims (A)
     Return the number of dimensions of A.  For any array, the result
     will always be larger than or equal to 2.  Trailing singleton
     dimensions are not counted.

          ndims (ones (4, 1, 2, 1))
              => 3

     See also: size.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Return the number of dimensions of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
ne


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 172
 -- Built-in Function: ne (X, Y)
     Return true if the two inputs are not equal.  This function is
     equivalent to 'x != y'.

     See also: eq, isequal, le, ge, lt.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return true if the two inputs are not equal.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
nfields


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 117
 -- Built-in Function: nfields (S)
     Return the number of fields of the structure S.

     See also: fieldnames.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Return the number of fields of the structure S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
nnz


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 125
 -- Built-in Function: N = nnz (A)
     Return the number of non-zero elements in A.

     See also: nzmax, nonzeros, find.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Return the number of non-zero elements in A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
norm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1355
 -- Built-in Function: norm (A)
 -- Built-in Function: norm (A, P)
 -- Built-in Function: norm (A, P, OPT)
     Compute the p-norm of the matrix A.  If the second argument is
     missing, 'p = 2' is assumed.

     If A is a matrix (or sparse matrix):

     P = '1'
          1-norm, the largest column sum of the absolute values of A.

     P = '2'
          Largest singular value of A.

     P = 'Inf' or "inf"
          Infinity norm, the largest row sum of the absolute values of
          A.

     P = "fro"
          Frobenius norm of A, 'sqrt (sum (diag (A' * A)))'.

     other P, 'P > 1'
          maximum 'norm (A*x, p)' such that 'norm (x, p) == 1'

     If A is a vector or a scalar:

     P = 'Inf' or "inf"
          'max (abs (A))'.

     P = '-Inf'
          'min (abs (A))'.

     P = "fro"
          Frobenius norm of A, 'sqrt (sumsq (abs (A)))'.

     P = 0
          Hamming norm - the number of nonzero elements.

     other P, 'P > 1'
          p-norm of A, '(sum (abs (A) .^ P)) ^ (1/P)'.

     other P 'P < 1'
          the p-pseudonorm defined as above.

     If OPT is the value "rows", treat each row as a vector and compute
     its norm.  The result is returned as a column vector.  Similarly,
     if OPT is "columns" or "cols" then compute the norms of each column
     and return a row vector.

     See also: cond, svd.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Compute the p-norm of the matrix A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
not


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 135
 -- Built-in Function: not (X)
     Return the logical NOT of X.  This function is equivalent to '! x'.

     See also: and, or, xor.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Return the logical NOT of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
nproc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 466
 -- Built-in Function: nproc ()
 -- Built-in Function: nproc (QUERY)
     Return the current number of available processors.

     If called with the optional argument QUERY, modify how processors
     are counted as follows:

     'all'
          total number of processors.

     'current'
          processors available to the current process.

     'overridable'
          likewise, but overridable through the 'OMP_NUM_THREADS'
          environment variable.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Return the current number of available processors.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
nth_element


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 901
 -- Built-in Function: nth_element (X, N)
 -- Built-in Function: nth_element (X, N, DIM)
     Select the n-th smallest element of a vector, using the ordering
     defined by 'sort'.  In other words, the result is equivalent to
     'sort(X)(N)'.  N can also be a contiguous range, either ascending
     'l:u' or descending 'u:-1:l', in which case a range of elements is
     returned.  If X is an array, 'nth_element' operates along the
     dimension defined by DIM, or the first non-singleton dimension if
     DIM is not given.

     nth_element encapsulates the C++ standard library algorithms
     nth_element and partial_sort.  On average, the complexity of the
     operation is O(M*log(K)), where 'M = size (X, DIM)' and
     'K = length (N)'.  This function is intended for cases where the
     ratio K/M is small; otherwise, it may be better to use 'sort'.

     See also: sort, min, max.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Select the n-th smallest element of a vector, using the ordering defined
by 'sor



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
num2cell


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 735
 -- Built-in Function: C = num2cell (A)
 -- Built-in Function: C = num2cell (A, DIM)
     Convert the numeric matrix A to a cell array.  If DIM is defined,
     the value C is of dimension 1 in this dimension and the elements of
     A are placed into C in slices.  For example:

          num2cell ([1,2;3,4])
             =>
                {
                  [1,1] =  1
                  [2,1] =  3
                  [1,2] =  2
                  [2,2] =  4
                }
          num2cell ([1,2;3,4],1)
             =>
                {
                  [1,1] =
                     1
                     3
                  [1,2] =
                     2
                     4
                }

     See also: mat2cell.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Convert the numeric matrix A to a cell array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
num2hex


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 678
 -- Built-in Function: S = num2hex (N)
     Typecast a double or single precision number or vector to a 8 or 16
     character hexadecimal string of the IEEE 754 representation of the
     number.  For example:

          num2hex ([-1, 1, e, Inf])
          => "bff0000000000000
              3ff0000000000000
              4005bf0a8b145769
              7ff0000000000000"

     If the argument N is a single precision number or vector, the
     returned string has a length of 8.  For example:

          num2hex (single ([-1, 1, e, Inf]))
          => "bf800000
              3f800000
              402df854
              7f800000"

     See also: hex2num, hex2dec, dec2hex.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Typecast a double or single precision number or vector to a 8 or 16
character he



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
numel


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 663
 -- Built-in Function: numel (A)
 -- Built-in Function: numel (A, IDX1, IDX2, ...)
     Return the number of elements in the object A.  Optionally, if
     indices IDX1, IDX2, ... are supplied, return the number of elements
     that would result from the indexing

          A(IDX1, IDX2, ...)

     Note that the indices do not have to be numerical.  For example,

          A = 1;
          B = ones (2, 3);
          numel (A, B)

     will return 6, as this is the number of ways to index with B.

     This method is also called when an object appears as lvalue with
     cs-list indexing, i.e., 'object{...}' or 'object(...).field'.

     See also: size.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Return the number of elements in the object A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
nzmax


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 380
 -- Built-in Function: N = nzmax (SM)
     Return the amount of storage allocated to the sparse matrix SM.

     Note that Octave tends to crop unused memory at the first
     opportunity for sparse objects.  Thus, in general the value of
     'nzmax' will be the the same as 'nnz' except for some cases of
     user-created sparse objects.

     See also: nnz, spalloc, sparse.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return the amount of storage allocated to the sparse matrix SM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
octave_config_info


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 289
 -- Built-in Function: octave_config_info ()
 -- Built-in Function: octave_config_info (OPTION)
     Return a structure containing configuration and installation
     information for Octave.

     If OPTION is a string, return the configuration information for the
     specified option.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a structure containing configuration and installation information
for Oct



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
octave_core_file_limit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1066
 -- Built-in Function: VAL = octave_core_file_limit ()
 -- Built-in Function: OLD_VAL = octave_core_file_limit (NEW_VAL)
 -- Built-in Function: octave_core_file_limit (NEW_VAL, "local")
     Query or set the internal variable that specifies the maximum
     amount of memory (in kilobytes) of the top-level workspace that
     Octave will attempt to save when writing data to the crash dump
     file (the name of the file is specified by OCTAVE_CORE_FILE_NAME).
     If OCTAVE_CORE_FILE_OPTIONS flags specify a binary format, then
     OCTAVE_CORE_FILE_LIMIT will be approximately the maximum size of
     the file.  If a text file format is used, then the file could be
     much larger than the limit.  The default value is -1 (unlimited)

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: crash_dumps_octave_core, octave_core_file_name,
     octave_core_file_options.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that specifies the maximum amount of
memory (



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
octave_core_file_name


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 702
 -- Built-in Function: VAL = octave_core_file_name ()
 -- Built-in Function: OLD_VAL = octave_core_file_name (NEW_VAL)
 -- Built-in Function: octave_core_file_name (NEW_VAL, "local")
     Query or set the internal variable that specifies the name of the
     file used for saving data from the top-level workspace if Octave
     aborts.  The default value is "octave-workspace"

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: crash_dumps_octave_core, octave_core_file_name,
     octave_core_file_options.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that specifies the name of the file
used for 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
octave_core_file_options


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 811
 -- Built-in Function: VAL = octave_core_file_options ()
 -- Built-in Function: OLD_VAL = octave_core_file_options (NEW_VAL)
 -- Built-in Function: octave_core_file_options (NEW_VAL, "local")
     Query or set the internal variable that specifies the options used
     for saving the workspace data if Octave aborts.  The value of
     'octave_core_file_options' should follow the same format as the
     options for the 'save' function.  The default value is Octave's
     binary format.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: crash_dumps_octave_core, octave_core_file_name,
     octave_core_file_limit.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that specifies the options used for
saving th



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
octave_tmp_file_name


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 635
 -- Built-in Function: tmpnam ()
 -- Built-in Function: tmpnam (DIR)
 -- Built-in Function: tmpnam (DIR, PREFIX)
     Return a unique temporary file name as a string.

     If PREFIX is omitted, a value of "oct-" is used.  If DIR is also
     omitted, the default directory for temporary files is used.  If DIR
     is provided, it must exist, otherwise the default directory for
     temporary files is used.  Since the named file is not opened, by
     'tmpnam', it is possible (though relatively unlikely) that it will
     not be available by the time your program attempts to open it.

     See also: tmpfile, mkstemp, P_tmpdir.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Return a unique temporary file name as a string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
onCleanup


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 518
 -- Built-in Function: OBJ = onCleanup (FUNCTION)
     Create a special object that executes a given function upon
     destruction.  If the object is copied to multiple variables (or
     cell or struct array elements) or returned from a function,
     FUNCTION will be executed after clearing the last copy of the
     object.  Note that if multiple local onCleanup variables are
     created, the order in which they are called is unspecified.  For
     similar functionality *Note The unwind_protect Statement::.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Create a special object that executes a given function upon destruction.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
ones


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 817
 -- Built-in Function: ones (N)
 -- Built-in Function: ones (M, N)
 -- Built-in Function: ones (M, N, K, ...)
 -- Built-in Function: ones ([M N ...])
 -- Built-in Function: ones (..., CLASS)
     Return a matrix or N-dimensional array whose elements are all 1.
     If invoked with a single scalar integer argument N, return a square
     NxN matrix.  If invoked with two or more scalar integer arguments,
     or a vector of integer values, return an array with the given
     dimensions.

     If you need to create a matrix whose values are all the same, you
     should use an expression like

          val_matrix = val * ones (m, n)

     The optional argument CLASS specifies the class of the return array
     and defaults to double.  For example:

          val = ones (m,n, "uint8")

     See also: zeros.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Return a matrix or N-dimensional array whose elements are all 1.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
optimize_subsasgn_calls


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 632
 -- Built-in Function: VAL = optimize_subsasgn_calls ()
 -- Built-in Function: OLD_VAL = optimize_subsasgn_calls (NEW_VAL)
 -- Built-in Function: optimize_subsasgn_calls (NEW_VAL, "local")
     Query or set the internal flag for subsasgn method call
     optimizations.

     If true, Octave will attempt to eliminate the redundant copying
     when calling the subsasgn method of a user-defined class.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Query or set the internal flag for subsasgn method call optimizations.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
or


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 364
 -- Built-in Function: or (X, Y)
 -- Built-in Function: or (X1, X2, ...)
     Return the logical OR of X and Y.  This function is equivalent to
     'x | y'.  If more arguments are given, the logical or is applied
     cumulatively from left to right:

          (...((x1 | x2) | x3) | ...)

     At least one argument is required.

     See also: and, not, xor.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Return the logical OR of X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
output_max_field_width


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 582
 -- Built-in Function: VAL = output_max_field_width ()
 -- Built-in Function: OLD_VAL = output_max_field_width (NEW_VAL)
 -- Built-in Function: output_max_field_width (NEW_VAL, "local")
     Query or set the internal variable that specifies the maximum width
     of a numeric output field.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: format, fixed_point_format, output_precision.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that specifies the maximum width of a
numeric



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
output_precision


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 598
 -- Built-in Function: VAL = output_precision ()
 -- Built-in Function: OLD_VAL = output_precision (NEW_VAL)
 -- Built-in Function: output_precision (NEW_VAL, "local")
     Query or set the internal variable that specifies the minimum
     number of significant figures to display for numeric output.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: format, fixed_point_format, output_max_field_width.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that specifies the minimum number of
signific



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
page_output_immediately


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 732
 -- Built-in Function: VAL = page_output_immediately ()
 -- Built-in Function: OLD_VAL = page_output_immediately (NEW_VAL)
 -- Built-in Function: page_output_immediately (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave
     sends output to the pager as soon as it is available.  Otherwise,
     Octave buffers its output and waits until just before the prompt is
     printed to flush it to the pager.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: page_screen_output, more, PAGER, PAGER_FLAGS.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that controls whether Octave sends
output to 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
page_screen_output


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 803
 -- Built-in Function: VAL = page_screen_output ()
 -- Built-in Function: OLD_VAL = page_screen_output (NEW_VAL)
 -- Built-in Function: page_screen_output (NEW_VAL, "local")
     Query or set the internal variable that controls whether output
     intended for the terminal window that is longer than one page is
     sent through a pager.  This allows you to view one screenful at a
     time.  Some pagers (such as 'less'--see *note Installation::) are
     also capable of moving backward on the output.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: more, page_output_immediately, PAGER, PAGER_FLAGS.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that controls whether output intended
for the



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
path


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 569
 -- Built-in Function: path (...)
     Modify or display Octave's load path.

     If NARGIN and NARGOUT are zero, display the elements of Octave's
     load path in an easy to read format.

     If NARGIN is zero and nargout is greater than zero, return the
     current load path.

     If NARGIN is greater than zero, concatenate the arguments,
     separating them with 'pathsep'.  Set the internal search path to
     the result and return it.

     No checks are made for duplicate elements.

     See also: addpath, rmpath, genpath, pathdef, savepath, pathsep.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Modify or display Octave's load path.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
pathsep


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 189
 -- Built-in Function: VAL = pathsep ()
 -- Built-in Function: OLD_VAL = pathsep (NEW_VAL)
     Query or set the character used to separate directories in a path.

     See also: filesep.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Query or set the character used to separate directories in a path.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
pause


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 516
 -- Built-in Function: pause ()
 -- Built-in Function: pause (N)
     Suspend the execution of the program for N seconds.

     N is a positive real value and may be a fraction of a second.  If
     invoked without an input arguments then the program is suspended
     until a character is typed.

     The following example prints a message and then waits 5 seconds
     before clearing the screen.

          fprintf (stderr, "wait please...\n");
          pause (5);
          clc;

     See also: kbhit, sleep.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Suspend the execution of the program for N seconds.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
pclose


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 148
 -- Built-in Function: pclose (FID)
     Close a file identifier that was opened by 'popen'.  You may also
     use 'fclose' for the same purpose.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Close a file identifier that was opened by 'popen'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
permute


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 268
 -- Built-in Function: permute (A, PERM)
     Return the generalized transpose for an N-D array object A.  The
     permutation vector PERM must contain the elements '1:ndims (A)' (in
     any order, but each element must appear only once).

     See also: ipermute.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Return the generalized transpose for an N-D array object A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
pi


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 870
 -- Built-in Function: pi
 -- Built-in Function: pi (N)
 -- Built-in Function: pi (N, M)
 -- Built-in Function: pi (N, M, K, ...)
 -- Built-in Function: pi (..., CLASS)
     Return a scalar, matrix, or N-dimensional array whose elements are
     all equal to the ratio of the circumference of a circle to its
     diameter.  Internally, 'pi' is computed as '4.0 * atan (1.0)'.

     When called with no arguments, return a scalar with the value of
     pi.  When called with a single argument, return a square matrix
     with the dimension specified.  When called with more than one
     scalar argument the first two arguments are taken as the number of
     rows and columns and any further arguments specify additional
     matrix dimensions.  The optional argument CLASS specifies the
     return type and may be either "double" or "single".

     See also: e, I.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a scalar, matrix, or N-dimensional array whose elements are all
equal to 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
pinv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 333
 -- Built-in Function: pinv (X)
 -- Built-in Function: pinv (X, TOL)
     Return the pseudoinverse of X.  Singular values less than TOL are
     ignored.

     If the second argument is omitted, it is taken to be

          tol = max (size (X)) * sigma_max (X) * eps,

     where 'sigma_max (X)' is the maximal singular value of X.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Return the pseudoinverse of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
pipe


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 345
 -- Built-in Function: [READ_FD, WRITE_FD, ERR, MSG] = pipe ()
     Create a pipe and return the reading and writing ends of the pipe
     into READ_FD and WRITE_FD respectively.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise, ERR
     is nonzero and MSG contains a system-dependent error message.

     See also: mkfifo.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Create a pipe and return the reading and writing ends of the pipe into
READ_FD a



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
plus


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 326
 -- Built-in Function: plus (X, Y)
 -- Built-in Function: plus (X1, X2, ...)
     This function and x + y are equivalent.  If more arguments are
     given, the summation is applied cumulatively from left to right:

          (...((x1 + x2) + x3) + ...)

     At least one argument is required.

     See also: minus, uplus.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
This function and x + y are equivalent.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
popen


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 886
 -- Built-in Function: FID = popen (COMMAND, MODE)
     Start a process and create a pipe.  The name of the command to run
     is given by COMMAND.  The file identifier corresponding to the
     input or output stream of the process is returned in FID.  The
     argument MODE may be

     '"r"'
          The pipe will be connected to the standard output of the
          process, and open for reading.

     '"w"'
          The pipe will be connected to the standard input of the
          process, and open for writing.

     For example:

          fid = popen ("ls -ltr / | tail -3", "r");
          while (ischar (s = fgets (fid)))
            fputs (stdout, s);
          endwhile

             -| drwxr-xr-x  33 root  root  3072 Feb 15 13:28 etc
             -| drwxr-xr-x   3 root  root  1024 Feb 15 13:28 lib
             -| drwxrwxrwt  15 root  root  2048 Feb 17 14:53 tmp




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Start a process and create a pipe.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
popen2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1313
 -- Built-in Function: [IN, OUT, PID] = popen2 (COMMAND, ARGS)
     Start a subprocess with two-way communication.  The name of the
     process is given by COMMAND, and ARGS is an array of strings
     containing options for the command.  The file identifiers for the
     input and output streams of the subprocess are returned in IN and
     OUT.  If execution of the command is successful, PID contains the
     process ID of the subprocess.  Otherwise, PID is -1.

     For example:

          [in, out, pid] = popen2 ("sort", "-r");
          fputs (in, "these\nare\nsome\nstrings\n");
          fclose (in);
          EAGAIN = errno ("EAGAIN");
          done = false;
          do
            s = fgets (out);
            if (ischar (s))
              fputs (stdout, s);
            elseif (errno () == EAGAIN)
              sleep (0.1);
              fclear (out);
            else
              done = true;
            endif
          until (done)
          fclose (out);
          waitpid (pid);

             -| these
             -| strings
             -| some
             -| are

     Note that 'popen2', unlike 'popen', will not "reap" the child
     process.  If you don't use 'waitpid' to check the child's exit
     status, it will linger until Octave exits.

     See also: popen, waitpid.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Start a subprocess with two-way communication.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
power


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 412
 -- Built-in Function: power (X, Y)
     Return the element-by-element operation of X raised to the Y power.
     If several complex results are possible, returns the one with
     smallest non-negative argument (angle).  Use 'realpow', 'realsqrt',
     'cbrt', or 'nthroot' if a real result is preferred.

     This function and x .^ y are equivalent.

     See also: mpower, realpow, realsqrt, cbrt, nthroot.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Return the element-by-element operation of X raised to the Y power.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
print_empty_dimensions


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 693
 -- Built-in Function: VAL = print_empty_dimensions ()
 -- Built-in Function: OLD_VAL = print_empty_dimensions (NEW_VAL)
 -- Built-in Function: print_empty_dimensions (NEW_VAL, "local")
     Query or set the internal variable that controls whether the
     dimensions of empty matrices are printed along with the empty
     matrix symbol, '[]'.  For example, the expression

          zeros (3, 0)

     will print

          ans = [](3x0)

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: format.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that controls whether the dimensions
of empty



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
print_struct_array_contents


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 840
 -- Built-in Function: VAL = print_struct_array_contents ()
 -- Built-in Function: OLD_VAL = print_struct_array_contents (NEW_VAL)
 -- Built-in Function: print_struct_array_contents (NEW_VAL, "local")
     Query or set the internal variable that specifies whether to print
     struct array contents.

     If true, values of struct array elements are printed.  This
     variable does not affect scalar structures whose elements are
     always printed.  In both cases, however, printing will be limited
     to the number of levels specified by STRUCT_LEVELS_TO_PRINT.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: struct_levels_to_print.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that specifies whether to print
struct array 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
printf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 380
 -- Built-in Function: printf (TEMPLATE, ...)
     Print optional arguments under the control of the template string
     TEMPLATE to the stream 'stdout' and return the number of characters
     printed.

     See the Formatted Output section of the GNU Octave manual for a
     complete description of the syntax of the template string.

     See also: fprintf, sprintf, scanf.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Print optional arguments under the control of the template string
TEMPLATE to th



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
prod


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 221
 -- Built-in Function: prod (X)
 -- Built-in Function: prod (X, DIM)
     Product of elements along dimension DIM.  If DIM is omitted, it
     defaults to the first non-singleton dimension.

     See also: cumprod, sum.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Product of elements along dimension DIM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
program_invocation_name


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 427
 -- Built-in Function: program_invocation_name ()
     Return the name that was typed at the shell prompt to run Octave.

     If executing a script from the command line (e.g., 'octave foo.m')
     or using an executable Octave script, the program name is set to
     the name of the script.  *Note Executable Octave Programs::, for an
     example of how to create an executable Octave script.

     See also: program_name.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Return the name that was typed at the shell prompt to run Octave.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
program_name


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 169
 -- Built-in Function: program_name ()
     Return the last component of the value returned by
     'program_invocation_name'.

     See also: program_invocation_name.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
Return the last component of the value returned by
'program_invocation_name'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
putenv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 148
 -- Built-in Function: putenv (VAR, VALUE)
 -- Built-in Function: setenv (VAR, VALUE)
     Set the value of the environment variable VAR to VALUE.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Set the value of the environment variable VAR to VALUE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
puts


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 194
 -- Built-in Function: puts (STRING)
     Write a string to the standard output with no formatting.

     Return a non-negative number on success and EOF on error.

     See also: fputs, disp.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Write a string to the standard output with no formatting.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
pwd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 153
 -- Built-in Function: pwd ()
 -- Built-in Function: DIR = pwd ()
     Return the current working directory.

     See also: cd, dir, ls, mkdir, rmdir.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Return the current working directory.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
quad


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1796
 -- Built-in Function: Q = quad (F, A, B)
 -- Built-in Function: Q = quad (F, A, B, TOL)
 -- Built-in Function: Q = quad (F, A, B, TOL, SING)
 -- Built-in Function: [Q, IER, NFUN, ERR] = quad (...)
     Numerically evaluate the integral of F from A to B using Fortran
     routines from QUADPACK.  F is a function handle, inline function,
     or a string containing the name of the function to evaluate.  The
     function must have the form 'y = f (x)' where Y and X are scalars.

     A and B are the lower and upper limits of integration.  Either or
     both may be infinite.

     The optional argument TOL is a vector that specifies the desired
     accuracy of the result.  The first element of the vector is the
     desired absolute tolerance, and the second element is the desired
     relative tolerance.  To choose a relative test only, set the
     absolute tolerance to zero.  To choose an absolute test only, set
     the relative tolerance to zero.  Both tolerances default to 'sqrt
     (eps)' or approximately 1.5e^{-8}.

     The optional argument SING is a vector of values at which the
     integrand is known to be singular.

     The result of the integration is returned in Q.  IER contains an
     integer error code (0 indicates a successful integration).  NFUN
     indicates the number of function evaluations that were made, and
     ERR contains an estimate of the error in the solution.

     The function 'quad_options' can set other optional parameters for
     'quad'.

     Note: because 'quad' is written in Fortran it cannot be called
     recursively.  This prevents its use in integrating over more than
     one variable by routines 'dblquad' and 'triplequad'.

     See also: quad_options, quadv, quadl, quadgk, quadcc, trapz,
     dblquad, triplequad.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Numerically evaluate the integral of F from A to B using Fortran
routines from Q



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
quad_options


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1189
 -- Built-in Function: quad_options ()
 -- Built-in Function: val = quad_options (OPT)
 -- Built-in Function: quad_options (OPT, VAL)
     Query or set options for the function 'quad'.  When called with no
     arguments, the names of all available options and their current
     values are displayed.  Given one argument, return the value of the
     corresponding option.  When called with two arguments,
     'quad_options' set the option OPT to value VAL.

     Options include

     '"absolute tolerance"'
          Absolute tolerance; may be zero for pure relative error test.

     '"relative tolerance"'
          Non-negative relative tolerance.  If the absolute tolerance is
          zero, the relative tolerance must be greater than or equal to
          'max (50*eps, 0.5e-28)'.

     '"single precision absolute tolerance"'
          Absolute tolerance for single precision; may be zero for pure
          relative error test.

     '"single precision relative tolerance"'
          Non-negative relative tolerance for single precision.  If the
          absolute tolerance is zero, the relative tolerance must be
          greater than or equal to 'max (50*eps, 0.5e-28)'.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Query or set options for the function 'quad'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
quadcc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3017
 -- Function File: Q = quadcc (F, A, B)
 -- Function File: Q = quadcc (F, A, B, TOL)
 -- Function File: Q = quadcc (F, A, B, TOL, SING)
 -- Function File: [Q, ERR, NR_POINTS] = quadcc (...)
     Numerically evaluate the integral of F from A to B using the
     doubly-adaptive Clenshaw-Curtis quadrature described by P. Gonnet
     in 'Increasing the Reliability of Adaptive Quadrature Using
     Explicit Interpolants'.  F is a function handle, inline function,
     or string containing the name of the function to evaluate.  The
     function F must be vectorized and must return a vector of output
     values if given a vector of input values.  For example,

          f = @(x) x .* sin (1./x) .* sqrt (abs (1 - x));

     which uses the element-by-element "dot" form for all operators.

     A and B are the lower and upper limits of integration.  Either or
     both limits may be infinite.  'quadcc' handles an inifinite limit
     by substituting the variable of integration with 'x = tan
     (pi/2*u)'.

     The optional argument TOL defines the relative tolerance used to
     stop the integration procedure.  The default value is 1e^{-6}.

     The optional argument SING contains a list of points where the
     integrand has known singularities, or discontinuities in any of its
     derivatives, inside the integration interval.  For the example
     above, which has a discontinuity at x=1, the call to 'quadcc' would
     be as follows

          int = quadcc (f, a, b, 1.0e-6, [ 1 ]);

     The result of the integration is returned in Q.  ERR is an estimate
     of the absolute integration error and NR_POINTS is the number of
     points at which the integrand was evaluated.  If the adaptive
     integration did not converge, the value of ERR will be larger than
     the requested tolerance.  Therefore, it is recommended to verify
     this value for difficult integrands.

     'quadcc' is capable of dealing with non-numeric values of the
     integrand such as 'NaN' or 'Inf'.  If the integral diverges, and
     'quadcc' detects this, then a warning is issued and 'Inf' or '-Inf'
     is returned.

     Note: 'quadcc' is a general purpose quadrature algorithm and, as
     such, may be less efficient for a smooth or otherwise well-behaved
     integrand than other methods such as 'quadgk'.

     The algorithm uses Clenshaw-Curtis quadrature rules of increasing
     degree in each interval and bisects the interval if either the
     function does not appear to be smooth or a rule of maximum degree
     has been reached.  The error estimate is computed from the L2-norm
     of the difference between two successive interpolations of the
     integrand over the nodes of the respective quadrature rules.

     Reference: P. Gonnet, 'Increasing the Reliability of Adaptive
     Quadrature Using Explicit Interpolants', ACM Transactions on
     Mathematical Software, Vol.  37, Issue 3, Article No.  3, 2010.

     See also: quad, quadv, quadl, quadgk, trapz, dblquad, triplequad.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Numerically evaluate the integral of F from A to B using the
doubly-adaptive Cle



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
quit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 271
 -- Built-in Function: exit (STATUS)
 -- Built-in Function: quit (STATUS)
     Exit the current Octave session.  If the optional integer value
     STATUS is supplied, pass that value to the operating system as the
     Octave's exit status.  The default value is zero.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Exit the current Octave session.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2
qz


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1987
 -- Built-in Function: LAMBDA = qz (A, B)
 -- Built-in Function: LAMBDA = qz (A, B, OPT)
     QZ decomposition of the generalized eigenvalue problem (A x = s B
     x).  There are three ways to call this function:
       1. 'LAMBDA = qz (A, B)'

          Computes the generalized eigenvalues LAMBDA of (A - s B).

       2. '[AA, BB, Q, Z, V, W, LAMBDA] = qz (A, B)'

          Computes QZ decomposition, generalized eigenvectors, and
          generalized eigenvalues of (A - s B)


               A * V = B * V * diag (LAMBDA)
               W' * A = diag (LAMBDA) * W' * B
               AA = Q * A * Z, BB = Q * B * Z


          with Q and Z orthogonal (unitary)= I

       3. '[AA,BB,Z{, LAMBDA}] = qz (A, B, OPT)'

          As in form [2], but allows ordering of generalized eigenpairs
          for (e.g.)  solution of discrete time algebraic Riccati
          equations.  Form 3 is not available for complex matrices, and
          does not compute the generalized eigenvectors V, W, nor the
          orthogonal matrix Q.

          OPT
               for ordering eigenvalues of the GEP pencil.  The leading
               block of the revised pencil contains all eigenvalues that
               satisfy:

               "N"
                    = unordered (default)

               "S"
                    = small: leading block has all |lambda| <= 1

               "B"
                    = big: leading block has all |lambda| >= 1

               "-"
                    = negative real part: leading block has all
                    eigenvalues in the open left half-plane

               "+"
                    = non-negative real part: leading block has all
                    eigenvalues in the closed right half-plane

     Note: 'qz' performs permutation balancing, but not scaling (*note
     XREFbalance::).  The order of output arguments was selected for
     compatibility with MATLAB.

     See also: eig, balance, lu, chol, hess, qr, qzhess, schur, svd.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
QZ decomposition of the generalized eigenvalue problem (A x = s B x).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
rand


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3319
 -- Built-in Function: rand (N)
 -- Built-in Function: rand (M, N, ...)
 -- Built-in Function: rand ([M N ...])
 -- Built-in Function: V = rand ("state")
 -- Built-in Function: rand ("state", V)
 -- Built-in Function: rand ("state", "reset")
 -- Built-in Function: V = rand ("seed")
 -- Built-in Function: rand ("seed", V)
 -- Built-in Function: rand ("seed", "reset")
 -- Built-in Function: rand (..., "single")
 -- Built-in Function: rand (..., "double")
     Return a matrix with random elements uniformly distributed on the
     interval (0, 1).  The arguments are handled the same as the
     arguments for 'eye'.

     You can query the state of the random number generator using the
     form

          v = rand ("state")

     This returns a column vector V of length 625.  Later, you can
     restore the random number generator to the state V using the form

          rand ("state", v)

     You may also initialize the state vector from an arbitrary vector
     of length <= 625 for V.  This new state will be a hash based on the
     value of V, not V itself.

     By default, the generator is initialized from '/dev/urandom' if it
     is available, otherwise from CPU time, wall clock time, and the
     current fraction of a second.  Note that this differs from MATLAB,
     which always initializes the state to the same state at startup.
     To obtain behavior comparable to MATLAB, initialize with a
     deterministic state vector in Octave's startup files (*note Startup
     Files::).

     To compute the pseudo-random sequence, 'rand' uses the Mersenne
     Twister with a period of 2^{19937}-1 (See M. Matsumoto and T.
     Nishimura, 'Mersenne Twister: A 623-dimensionally equidistributed
     uniform pseudorandom number generator', ACM Trans.  on Modeling and
     Computer Simulation Vol.  8, No.  1, pp.  3-30, January 1998,
     <http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html>).  Do
     *not* use for cryptography without securely hashing several
     returned values together, otherwise the generator state can be
     learned after reading 624 consecutive values.

     Older versions of Octave used a different random number generator.
     The new generator is used by default as it is significantly faster
     than the old generator, and produces random numbers with a
     significantly longer cycle time.  However, in some circumstances it
     might be desirable to obtain the same random sequences as used by
     the old generators.  To do this the keyword "seed" is used to
     specify that the old generators should be use, as in

          rand ("seed", val)

     which sets the seed of the generator to VAL.  The seed of the
     generator can be queried with

          s = rand ("seed")

     However, it should be noted that querying the seed will not cause
     'rand' to use the old generators, only setting the seed will.  To
     cause 'rand' to once again use the new generators, the keyword
     "state" should be used to reset the state of the 'rand'.

     The state or seed of the generator can be reset to a new random
     value using the "reset" keyword.

     The class of the value returned can be controlled by a trailing
     "double" or "single" argument.  These are the only valid classes.

     See also: randn, rande, randg, randp.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a matrix with random elements uniformly distributed on the
interval (0, 1



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
rande


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1119
 -- Built-in Function: rande (N)
 -- Built-in Function: rande (M, N, ...)
 -- Built-in Function: rande ([M N ...])
 -- Built-in Function: V = rande ("state")
 -- Built-in Function: rande ("state", V)
 -- Built-in Function: rande ("state", "reset")
 -- Built-in Function: V = rande ("seed")
 -- Built-in Function: rande ("seed", V)
 -- Built-in Function: rande ("seed", "reset")
 -- Built-in Function: rande (..., "single")
 -- Built-in Function: rande (..., "double")
     Return a matrix with exponentially distributed random elements.
     The arguments are handled the same as the arguments for 'rand'.

     By default, 'randn' uses the Marsaglia and Tsang "Ziggurat
     technique" to transform from a uniform to an exponential
     distribution.

     The class of the value returned can be controlled by a trailing
     "double" or "single" argument.  These are the only valid classes.

     Reference: G. Marsaglia and W.W. Tsang, 'Ziggurat Method for
     Generating Random Variables', J. Statistical Software, vol 5, 2000,
     <http://www.jstatsoft.org/v05/i08/>)

     See also: rand, randn, randg, randp.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return a matrix with exponentially distributed random elements.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
randg


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2035
 -- Built-in Function: randg (N)
 -- Built-in Function: randg (M, N, ...)
 -- Built-in Function: randg ([M N ...])
 -- Built-in Function: V = randg ("state")
 -- Built-in Function: randg ("state", V)
 -- Built-in Function: randg ("state", "reset")
 -- Built-in Function: V = randg ("seed")
 -- Built-in Function: randg ("seed", V)
 -- Built-in Function: randg ("seed", "reset")
 -- Built-in Function: randg (..., "single")
 -- Built-in Function: randg (..., "double")
     Return a matrix with 'gamma (A,1)' distributed random elements.
     The arguments are handled the same as the arguments for 'rand',
     except for the argument A.

     This can be used to generate many distributions:

     'gamma (a, b)' for 'a > -1', 'b > 0'

               r = b * randg (a)

     'beta (a, b)' for 'a > -1', 'b > -1'

               r1 = randg (a, 1)
               r = r1 / (r1 + randg (b, 1))

     'Erlang (a, n)'

               r = a * randg (n)

     'chisq (df)' for 'df > 0'

               r = 2 * randg (df / 2)

     't (df)' for '0 < df < inf' (use randn if df is infinite)

               r = randn () / sqrt (2 * randg (df / 2) / df)

     'F (n1, n2)' for '0 < n1', '0 < n2'

               ## r1 equals 1 if n1 is infinite
               r1 = 2 * randg (n1 / 2) / n1
               ## r2 equals 1 if n2 is infinite
               r2 = 2 * randg (n2 / 2) / n2
               r = r1 / r2


     negative 'binomial (n, p)' for 'n > 0', '0 < p <= 1'

               r = randp ((1 - p) / p * randg (n))

     non-central 'chisq (df, L)', for 'df >= 0' and 'L > 0'
          (use chisq if 'L = 0')

               r = randp (L / 2)
               r(r > 0) = 2 * randg (r(r > 0))
               r(df > 0) += 2 * randg (df(df > 0)/2)

     'Dirichlet (a1, ... ak)'

               r = (randg (a1), ..., randg (ak))
               r = r / sum (r)

     The class of the value returned can be controlled by a trailing
     "double" or "single" argument.  These are the only valid classes.

     See also: rand, randn, rande, randp.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return a matrix with 'gamma (A,1)' distributed random elements.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
randn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1143
 -- Built-in Function: randn (N)
 -- Built-in Function: randn (M, N, ...)
 -- Built-in Function: randn ([M N ...])
 -- Built-in Function: V = randn ("state")
 -- Built-in Function: randn ("state", V)
 -- Built-in Function: randn ("state", "reset")
 -- Built-in Function: V = randn ("seed")
 -- Built-in Function: randn ("seed", V)
 -- Built-in Function: randn ("seed", "reset")
 -- Built-in Function: randn (..., "single")
 -- Built-in Function: randn (..., "double")
     Return a matrix with normally distributed random elements having
     zero mean and variance one.  The arguments are handled the same as
     the arguments for 'rand'.

     By default, 'randn' uses the Marsaglia and Tsang "Ziggurat
     technique" to transform from a uniform to a normal distribution.

     The class of the value returned can be controlled by a trailing
     "double" or "single" argument.  These are the only valid classes.

     Reference: G. Marsaglia and W.W. Tsang, 'Ziggurat Method for
     Generating Random Variables', J. Statistical Software, vol 5, 2000,
     <http://www.jstatsoft.org/v05/i08/>)

     See also: rand, rande, randg, randp.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a matrix with normally distributed random elements having zero
mean and v



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
randp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1901
 -- Built-in Function: randp (L, N)
 -- Built-in Function: randp (L, M, N, ...)
 -- Built-in Function: randp (L, [M N ...])
 -- Built-in Function: V = randp ("state")
 -- Built-in Function: randp ("state", V)
 -- Built-in Function: randp ("state", "reset")
 -- Built-in Function: V = randp ("seed")
 -- Built-in Function: randp ("seed", V)
 -- Built-in Function: randp ("seed", "reset")
 -- Built-in Function: randp (..., "single")
 -- Built-in Function: randp (..., "double")
     Return a matrix with Poisson distributed random elements with mean
     value parameter given by the first argument, L.  The arguments are
     handled the same as the arguments for 'rand', except for the
     argument L.

     Five different algorithms are used depending on the range of L and
     whether or not L is a scalar or a matrix.

     For scalar L <= 12, use direct method.
          W.H. Press, et al., 'Numerical Recipes in C', Cambridge
          University Press, 1992.

     For scalar L > 12, use rejection method.[1]
          W.H. Press, et al., 'Numerical Recipes in C', Cambridge
          University Press, 1992.

     For matrix L <= 10, use inversion method.[2]
          E. Stadlober, et al., WinRand source code, available via FTP.

     For matrix L > 10, use patchwork rejection method.
          E. Stadlober, et al., WinRand source code, available via FTP,
          or H. Zechner, 'Efficient sampling from continuous and
          discrete unimodal distributions', Doctoral Dissertation,
          156pp., Technical University Graz, Austria, 1994.

     For L > 1e8, use normal approximation.
          L. Montanet, et al., 'Review of Particle Properties', Physical
          Review D 50 p1284, 1994.

     The class of the value returned can be controlled by a trailing
     "double" or "single" argument.  These are the only valid classes.

     See also: rand, randn, rande, randg.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a matrix with Poisson distributed random elements with mean value
paramet



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
randperm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 470
 -- Built-in Function: randperm (N)
 -- Built-in Function: randperm (N, M)
     Return a row vector containing a random permutation of '1:N'.  If M
     is supplied, return M unique entries, sampled without replacement
     from '1:N'.  The complexity is O(N) in memory and O(M) in time,
     unless M < N/5, in which case O(M) memory is used as well.  The
     randomization is performed using rand().  All permutations are
     equally likely.

     See also: perms.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Return a row vector containing a random permutation of '1:N'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
rats


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 393
 -- Built-in Function: rats (X, LEN)
     Convert X into a rational approximation represented as a string.
     You can convert the string back into a matrix as follows:

          r = rats (hilb (4));
          x = str2num (r)

     The optional second argument defines the maximum length of the
     string representing the elements of X.  By default LEN is 9.

     See also: format, rat.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Convert X into a rational approximation represented as a string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
rcond


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 432
 -- Built-in Function: C = rcond (A)
     Compute the 1-norm estimate of the reciprocal condition number as
     returned by LAPACK.  If the matrix is well-conditioned then C will
     be near 1 and if the matrix is poorly conditioned it will be close
     to zero.

     The matrix A must not be sparse.  If the matrix is sparse then
     'condest (A)' or 'rcond (full (A))' should be used instead.

     See also: cond, condest.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Compute the 1-norm estimate of the reciprocal condition number as
returned by LA



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rdivide


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 196
 -- Built-in Function: rdivide (X, Y)
     Return the element-by-element right division of X and Y.  This
     function and x ./ y are equivalent.

     See also: ldivide, mrdivide, times, plus.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Return the element-by-element right division of X and Y.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
readdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 429
 -- Built-in Function: FILES = readdir (DIR)
 -- Built-in Function: [FILES, ERR, MSG] = readdir (DIR)
     Return the names of files in the directory DIR as a cell array of
     strings.

     If an error occurs, return an empty cell array in FILES.  If
     successful, ERR is 0 and MSG is an empty string.  Otherwise, ERR is
     nonzero and MSG contains a system-dependent error message.

     See also: ls, dir, glob, what.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Return the names of files in the directory DIR as a cell array of
strings.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
readline_re_read_init_file


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 226
 -- Built-in Function: readline_re_read_init_file ()
     Re-read the last readline library initialization file that was
     read.  *Note (readline)Readline Init File::, for details.

     See also: readline_read_init_file.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
Re-read the last readline library initialization file that was read.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
readline_read_init_file


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 306
 -- Built-in Function: readline_read_init_file (FILE)
     Read the readline library initialization file FILE.  If FILE is
     omitted, read the default initialization file (normally
     '~/.inputrc').

     *Note (readline)Readline Init File::, for details.

     See also: readline_re_read_init_file.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 51
Read the readline library initialization file FILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
readlink


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 414
 -- Built-in Function: readlink SYMLINK
 -- Built-in Function: [RESULT, ERR, MSG] = readlink (SYMLINK)
     Read the value of the symbolic link SYMLINK.

     If successful, RESULT contains the contents of the symbolic link
     SYMLINK, ERR is 0, and MSG is an empty string.  Otherwise, ERR is
     nonzero and MSG contains a system-dependent error message.

     See also: lstat, symlink, link, unlink, delete.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Read the value of the symbolic link SYMLINK.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
real


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 92
 -- Mapping Function: real (Z)
     Return the real part of Z.

     See also: imag, conj.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Return the real part of Z.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
realmax


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1086
 -- Built-in Function: realmax
 -- Built-in Function: realmax (N)
 -- Built-in Function: realmax (N, M)
 -- Built-in Function: realmax (N, M, K, ...)
 -- Built-in Function: realmax (..., CLASS)
     Return a scalar, matrix or N-dimensional array whose elements are
     all equal to the largest floating point number that is
     representable.  The actual value is system dependent.  On machines
     that support IEEE floating point arithmetic, 'realmax' is
     approximately 1.7977e+308 for double precision and 3.4028e+38 for
     single precision.

     When called with no arguments, return a scalar with the value
     'realmax ("double")'.  When called with a single argument, return a
     square matrix with the dimension specified.  When called with more
     than one scalar argument the first two arguments are taken as the
     number of rows and columns and any further arguments specify
     additional matrix dimensions.  The optional argument CLASS
     specifies the return type and may be either "double" or "single".

     See also: realmin, intmax, bitmax, eps.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a scalar, matrix or N-dimensional array whose elements are all
equal to t



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
realmin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1090
 -- Built-in Function: realmin
 -- Built-in Function: realmin (N)
 -- Built-in Function: realmin (N, M)
 -- Built-in Function: realmin (N, M, K, ...)
 -- Built-in Function: realmin (..., CLASS)
     Return a scalar, matrix or N-dimensional array whose elements are
     all equal to the smallest normalized floating point number that is
     representable.  The actual value is system dependent.  On machines
     that support IEEE floating point arithmetic, 'realmin' is
     approximately 2.2251e-308 for double precision and 1.1755e-38 for
     single precision.

     When called with no arguments, return a scalar with the value
     'realmin ("double")'.  When called with a single argument, return a
     square matrix with the dimension specified.  When called with more
     than one scalar argument the first two arguments are taken as the
     number of rows and columns and any further arguments specify
     additional matrix dimensions.  The optional argument CLASS
     specifies the return type and may be either "double" or "single".

     See also: realmax, intmin, eps.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a scalar, matrix or N-dimensional array whose elements are all
equal to t



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
regexp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5575
 -- Built-in Function: [S, E, TE, M, T, NM, SP] = regexp (STR, PAT)
 -- Built-in Function: [...] = regexp (STR, PAT, "OPT1", ...)
     Regular expression string matching.  Search for PAT in STR and
     return the positions and substrings of any matches, or empty values
     if there are none.

     The matched pattern PAT can include any of the standard regex
     operators, including:

     '.'
          Match any character

     '* + ? {}'
          Repetition operators, representing

          '*'
               Match zero or more times

          '+'
               Match one or more times

          '?'
               Match zero or one times

          '{N}'
               Match exactly N times

          '{N,}'
               Match N or more times

          '{M,N}'
               Match between M and N times

     '[...] [^...]'

          List operators.  The pattern will match any character listed
          between "[" and "]".  If the first character is "^" then the
          pattern is inverted and any character except those listed
          between brackets will match.

          Escape sequences defined below can also be used inside list
          operators.  For example, a template for a floating point
          number might be '[-+.\d]+'.

     '() (?:)'
          Grouping operator.  The first form, parentheses only, also
          creates a token.

     '|'
          Alternation operator.  Match one of a choice of regular
          expressions.  The alternatives must be delimited by the
          grouping operator '()' above.

     '^ $'
          Anchoring operators.  Requires pattern to occur at the start
          ('^') or end ('$') of the string.

     In addition, the following escaped characters have special meaning.

     '\d'
          Match any digit

     '\D'
          Match any non-digit

     '\s'
          Match any whitespace character

     '\S'
          Match any non-whitespace character

     '\w'
          Match any word character

     '\W'
          Match any non-word character

     '\<'
          Match the beginning of a word

     '\>'
          Match the end of a word

     '\B'
          Match within a word

     Implementation Note: For compatibility with MATLAB, ordinary escape
     sequences (e.g., "\n" => newline) are processed in PAT regardless
     of whether PAT has been defined within single quotes.  Use a second
     backslash to stop interpolation of the escape sequence (e.g.,
     "\\n") or use the 'regexptranslate' function.

     The outputs of 'regexp' default to the order given below

     S
          The start indices of each matching substring

     E
          The end indices of each matching substring

     TE
          The extents of each matched token surrounded by '(...)' in PAT

     M
          A cell array of the text of each match

     T
          A cell array of the text of each token matched

     NM
          A structure containing the text of each matched named token,
          with the name being used as the fieldname.  A named token is
          denoted by '(?<name>...)'.

     SP
          A cell array of the text not returned by match, i.e., what
          remains if you split the string based on PAT.

     Particular output arguments, or the order of the output arguments,
     can be selected by additional OPT arguments.  These are strings and
     the correspondence between the output arguments and the optional
     argument are

                    'start'                S
                    'end'                  E
                    'tokenExtents'         TE
                    'match'                M
                    'tokens'               T
                    'names'                NM
                    'split'                SP

     Additional arguments are summarized below.

     'once'
          Return only the first occurrence of the pattern.

     'matchcase'
          Make the matching case sensitive.  (default)

          Alternatively, use (?-i) in the pattern.

     'ignorecase'
          Ignore case when matching the pattern to the string.

          Alternatively, use (?i) in the pattern.

     'stringanchors'
          Match the anchor characters at the beginning and end of the
          string.  (default)

          Alternatively, use (?-m) in the pattern.

     'lineanchors'
          Match the anchor characters at the beginning and end of the
          line.

          Alternatively, use (?m) in the pattern.

     'dotall'
          The pattern '.' matches all characters including the newline
          character.  (default)

          Alternatively, use (?s) in the pattern.

     'dotexceptnewline'
          The pattern '.' matches all characters except the newline
          character.

          Alternatively, use (?-s) in the pattern.

     'literalspacing'
          All characters in the pattern, including whitespace, are
          significant and are used in pattern matching.  (default)

          Alternatively, use (?-x) in the pattern.

     'freespacing'
          The pattern may include arbitrary whitespace and also comments
          beginning with the character '#'.

          Alternatively, use (?x) in the pattern.

     'noemptymatch'
          Zero-length matches are not returned.  (default)

     'emptymatch'
          Return zero-length matches.

          'regexp ('a', 'b*', 'emptymatch')' returns '[1 2]' because
          there are zero or more 'b' characters at positions 1 and
          end-of-string.

     See also: regexpi, strfind, regexprep.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Regular expression string matching.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
regexpi


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 421
 -- Built-in Function: [S, E, TE, M, T, NM, SP] = regexpi (STR, PAT)
 -- Built-in Function: [...] = regexpi (STR, PAT, "OPT1", ...)

     Case insensitive regular expression string matching.  Search for
     PAT in STR and return the positions and substrings of any matches,
     or empty values if there are none.  *Note regexp: XREFregexp, for
     details on the syntax of the search pattern.

     See also: regexp.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Case insensitive regular expression string matching.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
regexprep


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1143
 -- Built-in Function: OUTSTR = regexprep (STRING, PAT, REPSTR)
 -- Built-in Function: OUTSTR = regexprep (STRING, PAT, REPSTR, "OPT1",
          ...)
     Replace occurrences of pattern PAT in STRING with REPSTR.

     The pattern is a regular expression as documented for 'regexp'.
     *Note regexp: XREFregexp.

     The replacement string may contain '$i', which substitutes for the
     ith set of parentheses in the match string.  For example,

          regexprep ("Bill Dunn", '(\w+) (\w+)', '$2, $1')

     returns "Dunn, Bill"

     Options in addition to those of 'regexp' are

     'once'
          Replace only the first occurrence of PAT in the result.

     'warnings'
          This option is present for compatibility but is ignored.

     Implementation Note: For compatibility with MATLAB, ordinary escape
     sequences (e.g., "\n" => newline) are processed in both PAT and
     REPSTR regardless of whether they were defined within single
     quotes.  Use a second backslash to stop interpolation of the escape
     sequence (e.g., "\\n") or use the 'regexptranslate' function.

     See also: regexp, regexpi, strrep.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Replace occurrences of pattern PAT in STRING with REPSTR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
register_graphics_toolkit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 157
 -- Built-in Function: register_graphics_toolkit (TOOLKIT)
     List TOOLKIT as an available graphics toolkit.

     See also: available_graphics_toolkits.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
List TOOLKIT as an available graphics toolkit.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
rehash


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 88
 -- Built-in Function: rehash ()
     Reinitialize Octave's load path directory cache.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Reinitialize Octave's load path directory cache.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
rem


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 338
 -- Mapping Function: rem (X, Y)
 -- Mapping Function: fmod (X, Y)
     Return the remainder of the division 'X / Y', computed using the
     expression

          x - y .* fix (x ./ y)

     An error message is printed if the dimensions of the arguments do
     not agree, or if either of the arguments is complex.

     See also: mod.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Return the remainder of the division 'X / Y', computed using the
expression



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
remove_input_event_hook


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 317
 -- Built-in Function: remove_input_event_hook (NAME)
 -- Built-in Function: remove_input_event_hook (FCN_ID)
     Remove the named function or function handle with the given
     identifier from the list of functions to call periodically when
     Octave is waiting for input.

     See also: add_input_event_hook.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Remove the named function or function handle with the given identifier
from the 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
rename


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 320
 -- Built-in Function: rename OLD NEW
 -- Built-in Function: [ERR, MSG] = rename (OLD, NEW)
     Change the name of file OLD to NEW.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise, ERR
     is nonzero and MSG contains a system-dependent error message.

     See also: movefile, copyfile, ls, dir.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Change the name of file OLD to NEW.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
repelems


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 732
 -- Built-in Function: repelems (X, R)
     Construct a vector of repeated elements from X.  R is a 2xN integer
     matrix specifying which elements to repeat and how often to repeat
     each element.

     Entries in the first row, R(1,j), select an element to repeat.  The
     corresponding entry in the second row, R(2,j), specifies the repeat
     count.  If X is a matrix then the columns of X are imagined to be
     stacked on top of each other for purposes of the selection index.
     A row vector is always returned.

     Conceptually the result is calculated as follows:

          y = [];
          for i = 1:columns (R)
            y = [y, X(R(1,i)*ones(1, R(2,i)))];
          endfor

     See also: repmat, cat.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Construct a vector of repeated elements from X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
reset


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 291
 -- Built-in Function: reset (H, PROPERTY)
     Remove any defaults set for the handle H.  The default figure
     properties of "position", "units", "windowstyle" and "paperunits"
     and the default axes properties of "position" and "units" are not
     reset.

     See also: cla, clf.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Remove any defaults set for the handle H.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
reshape


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1013
 -- Built-in Function: reshape (A, M, N, ...)
 -- Built-in Function: reshape (A, [M N ...])
 -- Built-in Function: reshape (A, ..., [], ...)
 -- Built-in Function: reshape (A, SIZE)
     Return a matrix with the specified dimensions (M, N, ...) whose
     elements are taken from the matrix A.  The elements of the matrix
     are accessed in column-major order (like Fortran arrays are
     stored).

     The following code demonstrates reshaping a 1x4 row vector into a
     2x2 square matrix.

          reshape ([1, 2, 3, 4], 2, 2)
                =>  1  3
                    2  4

     Note that the total number of elements in the original matrix
     ('prod (size (A))') must match the total number of elements in the
     new matrix ('prod ([M N ...])').

     A single dimension of the return matrix may be left unspecified and
     Octave will determine its size automatically.  An empty matrix ([])
     is used to flag the unspecified dimension.

     See also: resize, vec, postpad, cat, squeeze.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a matrix with the specified dimensions (M, N, ...) whose elements
are tak



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
resize


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1228
 -- Built-in Function: resize (X, M)
 -- Built-in Function: resize (X, M, N, ...)
 -- Built-in Function: resize (X, [M N ...])
     Resize X cutting off elements as necessary.

     In the result, element with certain indices is equal to the
     corresponding element of X if the indices are within the bounds of
     X; otherwise, the element is set to zero.

     In other words, the statement

          y = resize (x, dv)

     is equivalent to the following code:

          y = zeros (dv, class (x));
          sz = min (dv, size (x));
          for i = 1:length (sz)
            idx{i} = 1:sz(i);
          endfor
          y(idx{:}) = x(idx{:});

     but is performed more efficiently.

     If only M is supplied, and it is a scalar, the dimension of the
     result is M-by-M.  If M, N, ... are all scalars, then the
     dimensions of the result are M-by-N-by-....  If given a vector as
     input, then the dimensions of the result are given by the elements
     of that vector.

     An object can be resized to more dimensions than it has; in such
     case the missing dimensions are assumed to be 1.  Resizing an
     object to fewer dimensions is not possible.

     See also: reshape, postpad, prepad, cat.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Resize X cutting off elements as necessary.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
restoredefaultpath


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 190
 -- Built-in Function: restoredefaultpath (...)
     Restore Octave's path to its initial state at startup.

     See also: path, addpath, rmpath, genpath, pathdef, savepath,
     pathsep.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Restore Octave's path to its initial state at startup.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rethrow


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 379
 -- Built-in Function: rethrow (ERR)
     Reissue a previous error as defined by ERR.  ERR is a structure
     that must contain at least the "message" and "identifier" fields.
     ERR can also contain a field "stack" that gives information on the
     assumed location of the error.  Typically ERR is returned from
     'lasterror'.

     See also: lasterror, lasterr, error.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Reissue a previous error as defined by ERR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
rmdir


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 559
 -- Built-in Function: rmdir DIR
 -- Built-in Function: rmdir (DIR, "s")
 -- Built-in Function: [STATUS, MSG, MSGID] = rmdir (...)
     Remove the directory named DIR.

     If successful, STATUS is 1, and MSG, MSGID are empty character
     strings ("").  Otherwise, STATUS is 0, MSG contains a
     system-dependent error message, and MSGID contains a unique message
     identifier.

     If the optional second parameter is supplied with value "s",
     recursively remove all subdirectories as well.

     See also: mkdir, confirm_recursive_rmdir, pwd.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Remove the directory named DIR.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rmfield


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 300
 -- Built-in Function: S = rmfield (S, "F")
 -- Built-in Function: S = rmfield (S, F)
     Return a _copy_ of the structure (array) S with the field F
     removed.  If F is a cell array of strings or a character array,
     remove each of the named fields.

     See also: orderfields, fieldnames.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
Return a _copy_ of the structure (array) S with the field F removed.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
rmpath


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 366
 -- Built-in Function: rmpath (DIR1, ...)
     Remove DIR1, ... from the current function search path.

     In addition to accepting individual directory arguments, lists of
     directory names separated by 'pathsep' are also accepted.  For
     example:

          rmpath ("dir1:/dir2:~/dir3")

     See also: path, addpath, genpath, pathdef, savepath, pathsep.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
Remove DIR1, ...



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
round


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 323
 -- Mapping Function: round (X)
     Return the integer nearest to X.  If X is complex, return 'round
     (real (X)) + round (imag (X)) * I'.  If there are two nearest
     integers, return the one further away from zero.

          round ([-2.7, 2.7])
               => -3    3

     See also: ceil, floor, fix, roundb.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Return the integer nearest to X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
roundb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 252
 -- Mapping Function: roundb (X)
     Return the integer nearest to X.  If there are two nearest
     integers, return the even one (banker's rounding).  If X is
     complex, return 'roundb (real (X)) + roundb (imag (X)) * I'.

     See also: round.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Return the integer nearest to X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
rows


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 151
 -- Built-in Function: rows (A)
     Return the number of rows of A.

     See also: columns, size, length, numel, isscalar, isvector,
     ismatrix.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Return the number of rows of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rsf2csf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 340
 -- Function File: [U, T] = rsf2csf (UR, TR)
     Convert a real, upper quasi-triangular Schur form TR to a complex,
     upper triangular Schur form T.

     Note that the following relations hold:

     UR * TR * UR' = U * T * U' and 'U' * U' is the identity matrix I.

     Note also that U and T are not unique.

     See also: schur.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Convert a real, upper quasi-triangular Schur form TR to a complex, upper
triangu



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
run_history


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 979
 -- Command: run_history
 -- Command: run_history CMD_NUMBER
 -- Command: run_history FIRST LAST
     Run commands from the history list.

     When invoked with no arguments, run the previously executed
     command; With one argument, run the specified command CMD_NUMBER;
     With two arguments, run the list of commands between FIRST and
     LAST.  Command number specifiers may also be negative where -1
     refers to the most recently executed command.  For example, the
     command

          run_history
               OR
          run_history -1

     executes the most recent command again.  The command

          run_history 13 169

     executes commands 13 through 169.

     Specifying a larger number for the first command than the last
     command reverses the list of commands before executing them.  For
     example:

          disp (1)
          disp (2)
          run_history -1 -2
          =>
           2
           1

     See also: edit_history.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Run commands from the history list.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
save


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4089
 -- Command: save file
 -- Command: save options file
 -- Command: save options file V1 V2 ...
 -- Command: save options file -struct STRUCT F1 F2 ...
     Save the named variables V1, V2, ..., in the file FILE.  The
     special filename '-' may be used to write output to the terminal.
     If no variable names are listed, Octave saves all the variables in
     the current scope.  Otherwise, full variable names or pattern
     syntax can be used to specify the variables to save.  If the
     '-struct' modifier is used, fields F1 F2 ... of the scalar
     structure STRUCT are saved as if they were variables with
     corresponding names.  Valid options for the 'save' command are
     listed in the following table.  Options that modify the output
     format override the format specified by 'save_default_options'.

     If save is invoked using the functional form

          save ("-option1", ..., "file", "v1", ...)

     then the OPTIONS, FILE, and variable name arguments (V1, ...) must
     be specified as character strings.

     '-append'
          Append to the destination instead of overwriting.

     '-ascii'
          Save a single matrix in a text file without header or any
          other information.

     '-binary'
          Save the data in Octave's binary data format.

     '-float-binary'
          Save the data in Octave's binary data format but only using
          single precision.  Only use this format if you know that all
          the values to be saved can be represented in single precision.

     '-hdf5'
          Save the data in HDF5 format.  (HDF5 is a free, portable
          binary format developed by the National Center for
          Supercomputing Applications at the University of Illinois.)
          This format is only available if Octave was built with a link
          to the HDF5 libraries.

     '-float-hdf5'
          Save the data in HDF5 format but only using single precision.
          Only use this format if you know that all the values to be
          saved can be represented in single precision.

     '-V7'
     '-v7'
     '-7'
     '-mat7-binary'
          Save the data in MATLAB's v7 binary data format.

     '-V6'
     '-v6'
     '-6'
     '-mat'
     '-mat-binary'
          Save the data in MATLAB's v6 binary data format.

     '-V4'
     '-v4'
     '-4'
     '-mat4-binary'
          Save the data in the binary format written by MATLAB version
          4.

     '-text'
          Save the data in Octave's text data format.  (default).

     '-zip'
     '-z'
          Use the gzip algorithm to compress the file.  This works
          equally on files that are compressed with gzip outside of
          octave, and gzip can equally be used to convert the files for
          backward compatibility.  This option is only available if
          Octave was built with a link to the zlib libraries.

     The list of variables to save may use wildcard patterns containing
     the following special characters:

     '?'
          Match any single character.

     '*'
          Match zero or more characters.

     '[ LIST ]'
          Match the list of characters specified by LIST.  If the first
          character is '!' or '^', match all characters except those
          specified by LIST.  For example, the pattern '[a-zA-Z]' will
          match all lower and uppercase alphabetic characters.

          Wildcards may also be used in the field name specifications
          when using the '-struct' modifier (but not in the struct name
          itself).

     Except when using the MATLAB binary data file format or the
     '-ascii' format, saving global variables also saves the global
     status of the variable.  If the variable is restored at a later
     time using 'load', it will be restored as a global variable.

     The command

          save -binary data a b*

     saves the variable 'a' and all variables beginning with 'b' to the
     file 'data' in Octave's binary format.

     See also: load, save_default_options, save_header_format_string,
     dlmread, csvread, fread.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Save the named variables V1, V2, ..., in the file FILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
save_default_options


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 655
 -- Built-in Function: VAL = save_default_options ()
 -- Built-in Function: OLD_VAL = save_default_options (NEW_VAL)
 -- Built-in Function: save_default_options (NEW_VAL, "local")
     Query or set the internal variable that specifies the default
     options for the 'save' command, and defines the default format.
     Typical values include "-ascii", "-text -zip".  The default value
     is '-text'.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: save.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that specifies the default options
for the 's



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
save_header_format_string


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 996
 -- Built-in Function: VAL = save_header_format_string ()
 -- Built-in Function: OLD_VAL = save_header_format_string (NEW_VAL)
 -- Built-in Function: save_header_format_string (NEW_VAL, "local")
     Query or set the internal variable that specifies the format string
     used for the comment line written at the beginning of text-format
     data files saved by Octave.  The format string is passed to
     'strftime' and should begin with the character '#' and contain no
     newline characters.  If the value of 'save_header_format_string' is
     the empty string, the header comment is omitted from text-format
     data files.  The default value is

          "# Created by Octave VERSION, %a %b %d %H:%M:%S %Y %Z <USER@HOST>"

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: strftime, save.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that specifies the format string used
for the



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
save_precision


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 513
 -- Built-in Function: VAL = save_precision ()
 -- Built-in Function: OLD_VAL = save_precision (NEW_VAL)
 -- Built-in Function: save_precision (NEW_VAL, "local")
     Query or set the internal variable that specifies the number of
     digits to keep when saving data in text format.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that specifies the number of digits
to keep w



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
scanf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 335
 -- Built-in Function: [VAL, COUNT, ERRMSG] = scanf (TEMPLATE, SIZE)
 -- Built-in Function: [V1, V2, ..., COUNT, ERRMSG]] = scanf (TEMPLATE,
          "C")
     This is equivalent to calling 'fscanf' with FID = 'stdin'.

     It is currently not useful to call 'scanf' in interactive programs.

     See also: fscanf, sscanf, printf.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
This is equivalent to calling 'fscanf' with FID = 'stdin'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
schur


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1766
 -- Built-in Function: S = schur (A)
 -- Built-in Function: S = schur (A, "real")
 -- Built-in Function: S = schur (A, "complex")
 -- Built-in Function: S = schur (A, OPT)
 -- Built-in Function: [U, S] = schur (A, ...)
     Compute the Schur decomposition of A

          S = U' * A * U

     where U is a unitary matrix ('U'* U' is identity) and S is upper
     triangular.  The eigenvalues of A (and S) are the diagonal elements
     of S.  If the matrix A is real, then the real Schur decomposition
     is computed, in which the matrix U is orthogonal and S is block
     upper triangular with blocks of size at most '2 x 2' along the
     diagonal.  The diagonal elements of S (or the eigenvalues of the '2
     x 2' blocks, when appropriate) are the eigenvalues of A and S.

     The default for real matrices is a real Schur decomposition.  A
     complex decomposition may be forced by passing the flag "complex".

     The eigenvalues are optionally ordered along the diagonal according
     to the value of OPT.  'OPT = "a"' indicates that all eigenvalues
     with negative real parts should be moved to the leading block of S
     (used in 'are'), 'OPT = "d"' indicates that all eigenvalues with
     magnitude less than one should be moved to the leading block of S
     (used in 'dare'), and 'OPT = "u"', the default, indicates that no
     ordering of eigenvalues should occur.  The leading K columns of U
     always span the A-invariant subspace corresponding to the K leading
     eigenvalues of S.

     The Schur decomposition is used to compute eigenvalues of a square
     matrix, and has applications in the solution of algebraic Riccati
     equations in control (see 'are' and 'dare').

     See also: rsf2csf, lu, chol, hess, qr, qz, svd.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Compute the Schur decomposition of A



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
set


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1506
 -- Built-in Function: set (H, PROPERTY, VALUE, ...)
 -- Built-in Function: set (H, PROPERTIES, VALUES)
 -- Built-in Function: set (H, PV)
     Set named property values for the graphics handle (or vector of
     graphics handles) H.  There are three ways how to give the property
     names and values:

        * as a comma separated list of PROPERTY, VALUE pairs

          Here, each PROPERTY is a string containing the property name,
          each VALUE is a value of the appropriate type for the
          property.

        * as a cell array of strings PROPERTIES containing property
          names and a cell array VALUES containing property values.

          In this case, the number of columns of VALUES must match the
          number of elements in PROPERTIES.  The first column of VALUES
          contains values for the first entry in PROPERTIES, etc.  The
          number of rows of VALUES must be 1 or match the number of
          elements of H.  In the first case, each handle in H will be
          assigned the same values.  In the latter case, the first
          handle in H will be assigned the values from the first row of
          VALUES and so on.

        * as a structure array PV

          Here, the field names of PV represent the property names, and
          the field values give the property values.  In contrast to the
          previous case, all elements of PV will be set in all handles
          in H independent of the dimensions of PV.

     See also: get.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Set named property values for the graphics handle (or vector of graphics
handles



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
setenv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 148
 -- Built-in Function: putenv (VAR, VALUE)
 -- Built-in Function: setenv (VAR, VALUE)
     Set the value of the environment variable VAR to VALUE.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Set the value of the environment variable VAR to VALUE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
setgrent


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 109
 -- Built-in Function: setgrent ()
     Return the internal pointer to the beginning of the group database.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 67
Return the internal pointer to the beginning of the group database.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
setpwent


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 117
 -- Built-in Function: setpwent ()
     Return the internal pointer to the beginning of the password
     database.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
Return the internal pointer to the beginning of the password database.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
sighup_dumps_octave_core


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 599
 -- Built-in Function: VAL = sighup_dumps_octave_core ()
 -- Built-in Function: OLD_VAL = sighup_dumps_octave_core (NEW_VAL)
 -- Built-in Function: sighup_dumps_octave_core (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave
     tries to save all current variables to the file 'octave-workspace'
     if it receives a hangup signal.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that controls whether Octave tries to
save al



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
sign


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 474
 -- Mapping Function: sign (X)
     Compute the "signum" function, which is defined as

                     -1, x < 0;
          sign (x) =  0, x = 0;
                      1, x > 0.

     For complex arguments, 'sign' returns 'x ./ abs (X)'.

     Note that 'sign (-0.0)' is 0.  Although IEEE 754 floating point
     allows zero to be signed, 0.0 and -0.0 compare equal.  If you must
     test whether zero is signed, use the 'signbit' function.

     See also: signbit.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Compute the "signum" function, which is defined as



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
signbit


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 561
 -- Mapping Function: signbit (X)
     Return logical true if the value of X has its sign bit set.
     Otherwise return logical false.  This behavior is consistent with
     the other logical functions.  See*note Logical Values::.  The
     behavior differs from the C language function which returns
     non-zero if the sign bit is set.

     This is not the same as 'x < 0.0', because IEEE 754 floating point
     allows zero to be signed.  The comparison '-0.0 < 0.0' is false,
     but 'signbit (-0.0)' will return a nonzero value.

     See also: sign.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 59
Return logical true if the value of X has its sign bit set.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 25
sigterm_dumps_octave_core


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 605
 -- Built-in Function: VAL = sigterm_dumps_octave_core ()
 -- Built-in Function: OLD_VAL = sigterm_dumps_octave_core (NEW_VAL)
 -- Built-in Function: sigterm_dumps_octave_core (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave
     tries to save all current variables to the file 'octave-workspace'
     if it receives a terminate signal.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that controls whether Octave tries to
save al



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
silent_functions


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 682
 -- Built-in Function: VAL = silent_functions ()
 -- Built-in Function: OLD_VAL = silent_functions (NEW_VAL)
 -- Built-in Function: silent_functions (NEW_VAL, "local")
     Query or set the internal variable that controls whether internal
     output from a function is suppressed.  If this option is disabled,
     Octave will display the results produced by evaluating expressions
     within a function body that are not terminated with a semicolon.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that controls whether internal output
from a 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
sin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 121
 -- Mapping Function: sin (X)
     Compute the sine for each element of X in radians.

     See also: asin, sind, sinh.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Compute the sine for each element of X in radians.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
single


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 100
 -- Built-in Function: single (X)
     Convert X to single precision type.

     See also: double.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Convert X to single precision type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
sinh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 123
 -- Mapping Function: sinh (X)
     Compute the hyperbolic sine for each element of X.

     See also: asinh, cosh, tanh.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Compute the hyperbolic sine for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
size


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 815
 -- Built-in Function: size (A)
 -- Built-in Function: size (A, DIM)
     Return the number of rows and columns of A.

     With one input argument and one output argument, the result is
     returned in a row vector.  If there are multiple output arguments,
     the number of rows is assigned to the first, and the number of
     columns to the second, etc.  For example:

          size ([1, 2; 3, 4; 5, 6])
             => [ 3, 2 ]

          [nr, nc] = size ([1, 2; 3, 4; 5, 6])
              => nr = 3
              => nc = 2

     If given a second argument, 'size' will return the size of the
     corresponding dimension.  For example,

          size ([1, 2; 3, 4; 5, 6], 2)
              => 2

     returns the number of columns in the given matrix.

     See also: numel, ndims, length, rows, columns.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Return the number of rows and columns of A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
size_equal


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 259
 -- Built-in Function: size_equal (A, B, ...)
     Return true if the dimensions of all arguments agree.  Trailing
     singleton dimensions are ignored.  Called with a single or no
     argument, size_equal returns true.

     See also: size, numel, ndims.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Return true if the dimensions of all arguments agree.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
sizemax


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 375
 -- Built-in Function: sizemax ()
     Return the largest value allowed for the size of an array.  If
     Octave is compiled with 64-bit indexing, the result is of class
     int64, otherwise it is of class int32.  The maximum array size is
     slightly smaller than the maximum value allowable for the relevant
     class as reported by 'intmax'.

     See also: intmax.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Return the largest value allowed for the size of an array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
sizeof


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 97
 -- Built-in Function: sizeof (VAL)
     Return the size of VAL in bytes.

     See also: whos.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Return the size of VAL in bytes.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
sleep


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 151
 -- Built-in Function: sleep (SECONDS)
     Suspend the execution of the program for the given number of
     seconds.

     See also: usleep, pause.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Suspend the execution of the program for the given number of seconds.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
sort


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1874
 -- Built-in Function: [S, I] = sort (X)
 -- Built-in Function: [S, I] = sort (X, DIM)
 -- Built-in Function: [S, I] = sort (X, MODE)
 -- Built-in Function: [S, I] = sort (X, DIM, MODE)
     Return a copy of X with the elements arranged in increasing order.
     For matrices, 'sort' orders the elements within columns

     For example:

          sort ([1, 2; 2, 3; 3, 1])
             =>  1  1
                 2  2
                 3  3

     If the optional argument DIM is given, then the matrix is sorted
     along the dimension defined by DIM.  The optional argument 'mode'
     defines the order in which the values will be sorted.  Valid values
     of 'mode' are "ascend" or "descend".

     The 'sort' function may also be used to produce a matrix containing
     the original row indices of the elements in the sorted matrix.  For
     example:

          [s, i] = sort ([1, 2; 2, 3; 3, 1])
            => s = 1  1
                   2  2
                   3  3
            => i = 1  3
                   2  1
                   3  2

     For equal elements, the indices are such that equal elements are
     listed in the order in which they appeared in the original list.

     Sorting of complex entries is done first by magnitude ('abs (Z)')
     and for any ties by phase angle ('angle (z)').  For example:

          sort ([1+i; 1; 1-i])
              => 1 + 0i
                 1 - 1i
                 1 + 1i

     NaN values are treated as being greater than any other value and
     are sorted to the end of the list.

     The 'sort' function may also be used to sort strings and cell
     arrays of strings, in which case ASCII dictionary order (uppercase
     'A' precedes lowercase 'a') of the strings is used.

     The algorithm used in 'sort' is optimized for the sorting of
     partially ordered lists.

     See also: sortrows, issorted.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Return a copy of X with the elements arranged in increasing order.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
source


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 229
 -- Built-in Function: source (FILE)
     Parse and execute the contents of FILE.

     This is equivalent to executing commands from a script file, but
     without requiring the file to be named 'FILE.m'.

     See also: run.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Parse and execute the contents of FILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
spalloc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1081
 -- Built-in Function: S = spalloc (M, N, NZ)
     Create an M-by-N sparse matrix with pre-allocated space for at most
     NZ nonzero elements.

     This is useful for building a matrix incrementally by a sequence of
     indexed assignments.  Subsequent indexed assignments after
     'spalloc' will reuse the pre-allocated memory, provided they are of
     one of the simple forms

        * 'S(I:J) = X'

        * 'S(:,I:J) = X'

        * 'S(K:L,I:J) = X'

     and that the following conditions are met:

        * the assignment does not decrease nnz (S).

        * after the assignment, nnz (S) does not exceed NZ.

        * no index is out of bounds.

     Partial movement of data may still occur, but in general the
     assignment will be more memory and time efficient under these
     circumstances.  In particular, it is possible to efficiently build
     a pre-allocated sparse matrix from a contiguous block of columns.

     The amount of pre-allocated memory for a given matrix may be
     queried using the function 'nzmax'.

     See also: nzmax, sparse.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Create an M-by-N sparse matrix with pre-allocated space for at most NZ
nonzero e



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
sparse


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2218
 -- Built-in Function: S = sparse (A)
 -- Built-in Function: S = sparse (I, J, SV, M, N)
 -- Built-in Function: S = sparse (I, J, SV)
 -- Built-in Function: S = sparse (M, N)
 -- Built-in Function: S = sparse (I, J, S, M, N, "unique")
 -- Built-in Function: S = sparse (I, J, SV, M, N, NZMAX)
     Create a sparse matrix from a full matrix or row, column, value
     triplets.

     If A is a full matrix, convert it to a sparse matrix
     representation, removing all zero values in the process.

     Given the integer index vectors I and J, and a 1-by-'nnz' vector of
     real or complex values SV, construct the sparse matrix
     'S(I(K),J(K)) = SV(K)' with overall dimensions M and N.  If any of
     SV, I or J are scalars, they are expanded to have a common size.

     If M or N are not specified their values are derived from the
     maximum index in the vectors I and J as given by 'M = max (I)', 'N
     = max (J)'.

     *Note*: if multiple values are specified with the same I, J
     indices, the corresponding value in S will be the sum of the values
     at the repeated location.  See 'accumarray' for an example of how
     to produce different behavior, such as taking the minimum instead.

     If the option "unique" is given, and more than one value is
     specified at the same I, J indices, then the last specified value
     will be used.

     'sparse (M, N)' will create an empty MxN sparse matrix and is
     equivalent to 'sparse ([], [], [], M, N)'

     The argument 'nzmax' is ignored but accepted for compatibility with
     MATLAB.

     Example 1 (sum at repeated indices):

          I = [1 1 2]; J = [1 1 2]; SV = [3 4 5];
          sparse (I, J, SV, 3, 4)
          =>
          Compressed Column Sparse (rows = 3, cols = 4, nnz = 2 [17%])

            (1, 1) ->  7
            (2, 2) ->  5

     Example 2 ("unique" option):

          I = [1 1 2]; J = [1 1 2]; SV = [3 4 5];
          sparse (I, J, SV, 3, 4, "unique")
          =>
          Compressed Column Sparse (rows = 3, cols = 4, nnz = 2 [17%])

            (1, 1) ->  4
            (2, 2) ->  5

     See also: full, accumarray, spalloc, spdiags, speye, spones,
     sprand, sprandn, sprandsym, spconvert, spfun.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 73
Create a sparse matrix from a full matrix or row, column, value
triplets.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 18
sparse_auto_mutate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 811
 -- Built-in Function: VAL = sparse_auto_mutate ()
 -- Built-in Function: OLD_VAL = sparse_auto_mutate (NEW_VAL)
 -- Built-in Function: sparse_auto_mutate (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave
     will automatically mutate sparse matrices to full matrices to save
     memory.  For example:

          s = speye (3);
          sparse_auto_mutate (false);
          s(:, 1) = 1;
          typeinfo (s)
          => sparse matrix
          sparse_auto_mutate (true);
          s(1, :) = 1;
          typeinfo (s)
          => matrix

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that controls whether Octave will
automatical



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 15
split_long_rows


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1187
 -- Built-in Function: VAL = split_long_rows ()
 -- Built-in Function: OLD_VAL = split_long_rows (NEW_VAL)
 -- Built-in Function: split_long_rows (NEW_VAL, "local")
     Query or set the internal variable that controls whether rows of a
     matrix may be split when displayed to a terminal window.  If the
     rows are split, Octave will display the matrix in a series of
     smaller pieces, each of which can fit within the limits of your
     terminal width and each set of rows is labeled so that you can
     easily see which columns are currently being displayed.  For
     example:

          octave:13> rand (2,10)
          ans =

           Columns 1 through 6:

            0.75883  0.93290  0.40064  0.43818  0.94958  0.16467
            0.75697  0.51942  0.40031  0.61784  0.92309  0.40201

           Columns 7 through 10:

            0.90174  0.11854  0.72313  0.73326
            0.44672  0.94303  0.56564  0.82150

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: format.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that controls whether rows of a
matrix may be



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
spparms


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2437
 -- Built-in Function: spparms ()
 -- Built-in Function: VALS = spparms ()
 -- Built-in Function: [KEYS, VALS] = spparms ()
 -- Built-in Function: VAL = spparms (KEY)
 -- Built-in Function: spparms (VALS)
 -- Built-in Function: spparms ("defaults")
 -- Built-in Function: spparms ("tight")
 -- Built-in Function: spparms (KEY, VAL)
     Query or set the parameters used by the sparse solvers and
     factorization functions.  The first four calls above get
     information about the current settings, while the others change the
     current settings.  The parameters are stored as pairs of keys and
     values, where the values are all floats and the keys are one of the
     following strings:

     'spumoni'
          Printing level of debugging information of the solvers
          (default 0)

     'ths_rel'
          Included for compatibility.  Not used.  (default 1)

     'ths_abs'
          Included for compatibility.  Not used.  (default 1)

     'exact_d'
          Included for compatibility.  Not used.  (default 0)

     'supernd'
          Included for compatibility.  Not used.  (default 3)

     'rreduce'
          Included for compatibility.  Not used.  (default 3)

     'wh_frac'
          Included for compatibility.  Not used.  (default 0.5)

     'autommd'
          Flag whether the LU/QR and the '\' and '/' operators will
          automatically use the sparsity preserving mmd functions
          (default 1)

     'autoamd'
          Flag whether the LU and the '\' and '/' operators will
          automatically use the sparsity preserving amd functions
          (default 1)

     'piv_tol'
          The pivot tolerance of the UMFPACK solvers (default 0.1)

     'sym_tol'
          The pivot tolerance of the UMFPACK symmetric solvers (default
          0.001)

     'bandden'
          The density of non-zero elements in a banded matrix before it
          is treated by the LAPACK banded solvers (default 0.5)

     'umfpack'
          Flag whether the UMFPACK or mmd solvers are used for the LU,
          '\' and '/' operations (default 1)

     The value of individual keys can be set with 'spparms (KEY, VAL)'.
     The default values can be restored with the special keyword
     "defaults".  The special keyword "tight" can be used to set the mmd
     solvers to attempt a sparser solution at the potential cost of
     longer running time.

     See also: chol, colamd, lu, qr, symamd.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the parameters used by the sparse solvers and factorization
functio



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
sprintf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 391
 -- Built-in Function: sprintf (TEMPLATE, ...)
     This is like 'printf', except that the output is returned as a
     string.  Unlike the C library function, which requires you to
     provide a suitably sized string as an argument, Octave's 'sprintf'
     function returns the string, automatically sized to hold all of the
     items converted.

     See also: printf, fprintf, sscanf.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 70
This is like 'printf', except that the output is returned as a string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
sqrt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 241
 -- Mapping Function: sqrt (X)
     Compute the square root of each element of X.  If X is negative, a
     complex result is returned.  To compute the matrix square root, see
     *note Linear Algebra::.

     See also: realsqrt, nthroot.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Compute the square root of each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
sqrtm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 363
 -- Built-in Function: S = sqrtm (A)
 -- Built-in Function: [S, ERROR_ESTIMATE] = sqrtm (A)
     Compute the matrix square root of the square matrix A.

     Ref: N.J. Higham.  'A New sqrtm for MATLAB'.  Numerical Analysis
     Report No.  336, Manchester Centre for Computational Mathematics,
     Manchester, England, January 1999.

     See also: expm, logm.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Compute the matrix square root of the square matrix A.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
squeeze


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 257
 -- Built-in Function: squeeze (X)
     Remove singleton dimensions from X and return the result.  Note
     that for compatibility with MATLAB, all objects have a minimum of
     two dimensions and row vectors are left unchanged.

     See also: reshape.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Remove singleton dimensions from X and return the result.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
sscanf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 547
 -- Built-in Function: [VAL, COUNT, ERRMSG, POS] = sscanf (STRING,
          TEMPLATE, SIZE)
 -- Built-in Function: [V1, V2, ..., COUNT, ERRMSG] = sscanf (STRING,
          TEMPLATE, "C")
     This is like 'fscanf', except that the characters are taken from
     the string STRING instead of from a stream.  Reaching the end of
     the string is treated as an end-of-file condition.  In addition to
     the values returned by 'fscanf', the index of the next character to
     be read is returned in POS.

     See also: fscanf, scanf, sprintf.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
This is like 'fscanf', except that the characters are taken from the
string STRI



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
stat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2623
 -- Built-in Function: [INFO, ERR, MSG] = stat (FILE)
 -- Built-in Function: [INFO, ERR, MSG] = stat (FID)
 -- Built-in Function: [INFO, ERR, MSG] = lstat (FILE)
 -- Built-in Function: [INFO, ERR, MSG] = lstat (FID)
     Return a structure INFO containing the following information about
     FILE or file identifier FID.

     'dev'
          ID of device containing a directory entry for this file.

     'ino'
          File number of the file.

     'mode'
          File mode, as an integer.  Use the functions 'S_ISREG',
          'S_ISDIR', 'S_ISCHR', 'S_ISBLK', 'S_ISFIFO', 'S_ISLNK', or 'S_ISSOCK'
          to extract information from this value.

     'modestr'
          File mode, as a string of ten letters or dashes as would be
          returned by 'ls -l'.

     'nlink'
          Number of links.

     'uid'
          User ID of file's owner.

     'gid'
          Group ID of file's group.

     'rdev'
          ID of device for block or character special files.

     'size'
          Size in bytes.

     'atime'
          Time of last access in the same form as time values returned
          from 'time'.  *Note Timing Utilities::.

     'mtime'
          Time of last modification in the same form as time values
          returned from 'time'.  *Note Timing Utilities::.

     'ctime'
          Time of last file status change in the same form as time
          values returned from 'time'.  *Note Timing Utilities::.

     'blksize'
          Size of blocks in the file.

     'blocks'
          Number of blocks allocated for file.

     If the call is successful ERR is 0 and MSG is an empty string.  If
     the file does not exist, or some other error occurs, INFO is an
     empty matrix, ERR is -1, and MSG contains the corresponding system
     error message.

     If FILE is a symbolic link, 'stat' will return information about
     the actual file that is referenced by the link.  Use 'lstat' if you
     want information about the symbolic link itself.

     For example:

          [info, err, msg] = stat ("/vmlinuz")
            => info =
               {
                 atime = 855399756
                 rdev = 0
                 ctime = 847219094
                 uid = 0
                 size = 389218
                 blksize = 4096
                 mtime = 847219094
                 gid = 6
                 nlink = 1
                 blocks = 768
                 mode = -rw-r--r--
                 modestr = -rw-r--r--
                 ino = 9316
                 dev = 2049
               }
            => err = 0
            => msg =

     See also: lstat, ls, dir.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a structure INFO containing the following information about FILE
or file 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
stderr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 270
 -- Built-in Function: stderr ()
     Return the numeric value corresponding to the standard error
     stream.  Even if paging is turned on, the standard error is not
     sent to the pager.  It is useful for error messages and prompts.

     See also: stdin, stdout.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
Return the numeric value corresponding to the standard error stream.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
stdin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 246
 -- Built-in Function: stdin ()
     Return the numeric value corresponding to the standard input
     stream.  When Octave is used interactively, this is filtered
     through the command line editing functions.

     See also: stdout, stderr.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 68
Return the numeric value corresponding to the standard input stream.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
stdout


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 227
 -- Built-in Function: stdout ()
     Return the numeric value corresponding to the standard output
     stream.  Data written to the standard output is normally filtered
     through the pager.

     See also: stdin, stderr.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Return the numeric value corresponding to the standard output stream.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
str2double


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1569
 -- Built-in Function: str2double (S)
     Convert a string to a real or complex number.

     The string must be in one of the following formats where a and b
     are real numbers and the complex unit is 'i' or 'j':

        * a + bi

        * a + b*i

        * a + i*b

        * bi + a

        * b*i + a

        * i*b + a

     If present, a and/or b are of the form [+-]d[,.]d[[eE][+-]d] where
     the brackets indicate optional arguments and 'd' indicates zero or
     more digits.  The special input values 'Inf', 'NaN', and 'NA' are
     also accepted.

     S may be a character string, character matrix, or cell array.  For
     character arrays the conversion is repeated for every row, and a
     double or complex array is returned.  Empty rows in S are deleted
     and not returned in the numeric array.  For cell arrays each
     character string element is processed and a double or complex array
     of the same dimensions as S is returned.

     For unconvertible scalar or character string input 'str2double'
     returns a NaN.  Similarly, for character array input 'str2double'
     returns a NaN for any row of S that could not be converted.  For a
     cell array, 'str2double' returns a NaN for any element of S for
     which conversion fails.  Note that numeric elements in a mixed
     string/numeric cell array are not strings and the conversion will
     fail for these elements and return NaN.

     'str2double' can replace 'str2num', and it avoids the security risk
     of using 'eval' on unknown data.

     See also: str2num.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Convert a string to a real or complex number.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
str2func


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 308
 -- Built-in Function: str2func (FCN_NAME)
 -- Built-in Function: str2func (FCN_NAME, "global")
     Return a function handle constructed from the string FCN_NAME.  If
     the optional "global" argument is passed, locally visible functions
     are ignored in the lookup.

     See also: func2str, inline.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Return a function handle constructed from the string FCN_NAME.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
strcmp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 707
 -- Built-in Function: strcmp (S1, S2)
     Return 1 if the character strings S1 and S2 are the same, and 0
     otherwise.

     If either S1 or S2 is a cell array of strings, then an array of the
     same size is returned, containing the values described above for
     every member of the cell array.  The other argument may also be a
     cell array of strings (of the same size or with only one element),
     char matrix or character string.

     *Caution:* For compatibility with MATLAB, Octave's strcmp function
     returns 1 if the character strings are equal, and 0 otherwise.
     This is just the opposite of the corresponding C library function.

     See also: strcmpi, strncmp, strncmpi.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Return 1 if the character strings S1 and S2 are the same, and 0
otherwise.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
strcmpi


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 806
 -- Built-in Function: strcmpi (S1, S2)
     Return 1 if the character strings S1 and S2 are the same,
     disregarding case of alphabetic characters, and 0 otherwise.

     If either S1 or S2 is a cell array of strings, then an array of the
     same size is returned, containing the values described above for
     every member of the cell array.  The other argument may also be a
     cell array of strings (of the same size or with only one element),
     char matrix or character string.

     *Caution:* For compatibility with MATLAB, Octave's strcmp function
     returns 1 if the character strings are equal, and 0 otherwise.
     This is just the opposite of the corresponding C library function.

     *Caution:* National alphabets are not supported.

     See also: strcmp, strncmp, strncmpi.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return 1 if the character strings S1 and S2 are the same, disregarding
case of a



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
strfind


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1197
 -- Built-in Function: IDX = strfind (STR, PATTERN)
 -- Built-in Function: IDX = strfind (CELLSTR, PATTERN)
 -- Built-in Function: IDX = strfind (..., "overlaps", VAL)
     Search for PATTERN in the string STR and return the starting index
     of every such occurrence in the vector IDX.

     If there is no such occurrence, or if PATTERN is longer than STR,
     then IDX is the empty array '[]'.  The optional argument "overlaps"
     determines whether the pattern can match at every position in STR
     (true), or only for unique occurrences of the complete pattern
     (false).  The default is true.

     If a cell array of strings CELLSTR is specified then IDX is a cell
     array of vectors, as specified above.

     Examples:

          strfind ("abababa", "aba")
               => [1, 3, 5]

          strfind ("abababa", "aba", "overlaps", false)
               => [1, 5]

          strfind ({"abababa", "bebebe", "ab"}, "aba")
               =>
                  {
                    [1,1] =

                       1   3   5

                    [1,2] = [](1x0)
                    [1,3] = [](1x0)
                  }

     See also: findstr, strmatch, regexp, regexpi, find.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Search for PATTERN in the string STR and return the starting index of
every such



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
strftime


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2985
 -- Built-in Function: strftime (FMT, TM_STRUCT)
     Format the time structure TM_STRUCT in a flexible way using the
     format string FMT that contains '%' substitutions similar to those
     in 'printf'.  Except where noted, substituted fields have a fixed
     size; numeric fields are padded if necessary.  Padding is with
     zeros by default; for fields that display a single number, padding
     can be changed or inhibited by following the '%' with one of the
     modifiers described below.  Unknown field specifiers are copied as
     normal characters.  All other characters are copied to the output
     without change.  For example:

          strftime ("%r (%Z) %A %e %B %Y", localtime (time ()))
                => "01:15:06 AM (CST) Monday 17 February 1997"

     Octave's 'strftime' function supports a superset of the ANSI C
     field specifiers.

     Literal character fields:

     '%%'
          % character.

     '%n'
          Newline character.

     '%t'
          Tab character.

     Numeric modifiers (a nonstandard extension):

     '- (dash)'
          Do not pad the field.

     '_ (underscore)'
          Pad the field with spaces.

     Time fields:

     '%H'
          Hour (00-23).

     '%I'
          Hour (01-12).

     '%k'
          Hour (0-23).

     '%l'
          Hour (1-12).

     '%M'
          Minute (00-59).

     '%p'
          Locale's AM or PM.

     '%r'
          Time, 12-hour (hh:mm:ss [AP]M).

     '%R'
          Time, 24-hour (hh:mm).

     '%s'
          Time in seconds since 00:00:00, Jan 1, 1970 (a nonstandard
          extension).

     '%S'
          Second (00-61).

     '%T'
          Time, 24-hour (hh:mm:ss).

     '%X'
          Locale's time representation (%H:%M:%S).

     '%Z'
          Time zone (EDT), or nothing if no time zone is determinable.

     Date fields:

     '%a'
          Locale's abbreviated weekday name (Sun-Sat).

     '%A'
          Locale's full weekday name, variable length (Sunday-Saturday).

     '%b'
          Locale's abbreviated month name (Jan-Dec).

     '%B'
          Locale's full month name, variable length (January-December).

     '%c'
          Locale's date and time (Sat Nov 04 12:02:33 EST 1989).

     '%C'
          Century (00-99).

     '%d'
          Day of month (01-31).

     '%e'
          Day of month ( 1-31).

     '%D'
          Date (mm/dd/yy).

     '%h'
          Same as %b.

     '%j'
          Day of year (001-366).

     '%m'
          Month (01-12).

     '%U'
          Week number of year with Sunday as first day of week (00-53).

     '%w'
          Day of week (0-6).

     '%W'
          Week number of year with Monday as first day of week (00-53).

     '%x'
          Locale's date representation (mm/dd/yy).

     '%y'
          Last two digits of year (00-99).

     '%Y'
          Year (1970-).

     See also: strptime, localtime, gmtime, mktime, time, now, date,
     clock, datenum, datestr, datevec, calendar, weekday.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Format the time structure TM_STRUCT in a flexible way using the format
string FM



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
string_fill_char


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 763
 -- Built-in Function: VAL = string_fill_char ()
 -- Built-in Function: OLD_VAL = string_fill_char (NEW_VAL)
 -- Built-in Function: string_fill_char (NEW_VAL, "local")
     Query or set the internal variable used to pad all rows of a
     character matrix to the same length; It must be a single character.
     The default value is " " (a single space).  For example:

          string_fill_char ("X");
          [ "these"; "are"; "strings" ]
                =>  "theseXX"
                    "areXXXX"
                    "strings"

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable used to pad all rows of a character
matrix to



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
strncmp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 866
 -- Built-in Function: strncmp (S1, S2, N)
     Return 1 if the first N characters of strings S1 and S2 are the
     same, and 0 otherwise.

          strncmp ("abce", "abcd", 3)
                => 1

     If either S1 or S2 is a cell array of strings, then an array of the
     same size is returned, containing the values described above for
     every member of the cell array.  The other argument may also be a
     cell array of strings (of the same size or with only one element),
     char matrix or character string.

          strncmp ("abce", {"abcd", "bca", "abc"}, 3)
               => [1, 0, 1]

     *Caution:* For compatibility with MATLAB, Octave's strncmp function
     returns 1 if the character strings are equal, and 0 otherwise.
     This is just the opposite of the corresponding C library function.

     See also: strncmpi, strcmp, strcmpi.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return 1 if the first N characters of strings S1 and S2 are the same,
and 0 othe



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
strncmpi


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 820
 -- Built-in Function: strncmpi (S1, S2, N)
     Return 1 if the first N character of S1 and S2 are the same,
     disregarding case of alphabetic characters, and 0 otherwise.

     If either S1 or S2 is a cell array of strings, then an array of the
     same size is returned, containing the values described above for
     every member of the cell array.  The other argument may also be a
     cell array of strings (of the same size or with only one element),
     char matrix or character string.

     *Caution:* For compatibility with MATLAB, Octave's strncmpi
     function returns 1 if the character strings are equal, and 0
     otherwise.  This is just the opposite of the corresponding C
     library function.

     *Caution:* National alphabets are not supported.

     See also: strncmp, strcmp, strcmpi.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return 1 if the first N character of S1 and S2 are the same,
disregarding case o



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
strptime


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 526
 -- Built-in Function: [TM_STRUCT, NCHARS] = strptime (STR, FMT)
     Convert the string STR to the time structure TM_STRUCT under the
     control of the format string FMT.

     If FMT fails to match, NCHARS is 0; otherwise, it is set to the
     position of last matched character plus 1.  Always check for this
     unless you're absolutely sure the date string will be parsed
     correctly.

     See also: strftime, localtime, gmtime, mktime, time, now, date,
     clock, datenum, datestr, datevec, calendar, weekday.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Convert the string STR to the time structure TM_STRUCT under the control
of the 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
strrep


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 796
 -- Built-in Function: NEWSTR = strrep (STR, PTN, REP)
 -- Built-in Function: NEWSTR = strrep (CELLSTR, PTN, REP)
 -- Built-in Function: NEWSTR = strrep (..., "overlaps", VAL)
     Replace all occurrences of the pattern PTN in the string STR with
     the string REP and return the result.

     The optional argument "overlaps" determines whether the pattern can
     match at every position in STR (true), or only for unique
     occurrences of the complete pattern (false).  The default is true.

     S may also be a cell array of strings, in which case the
     replacement is done for each element and a cell array is returned.

     Example:

          strrep ("This is a test string", "is", "&%$")
              =>  "Th&%$ &%$ a test string"

     See also: regexprep, strfind, findstr.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Replace all occurrences of the pattern PTN in the string STR with the
string REP



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
struct


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1949
 -- Built-in Function: S = struct ()
 -- Built-in Function: S = struct (FIELD1, VALUE1, FIELD2, VALUE2, ...)
 -- Built-in Function: S = struct (OBJ)

     Create a scalar or array structure and initialize its values.  The
     FIELD1, FIELD2, ... variables are strings specifying the names of
     the fields and the VALUE1, VALUE2, ... variables can be of any
     type.

     If the values are cell arrays, create a structure array and
     initialize its values.  The dimensions of each cell array of values
     must match.  Singleton cells and non-cell values are repeated so
     that they fill the entire array.  If the cells are empty, create an
     empty structure array with the specified field names.

     If the argument is an object, return the underlying struct.

     Observe that the syntax is optimized for struct *arrays*.  Consider
     the following examples:

          struct ("foo", 1)
            => scalar structure containing the fields:
              foo =  1

          struct ("foo", {})
            => 0x0 struct array containing the fields:
              foo

          struct ("foo", { {} })
            => scalar structure containing the fields:
              foo = {}(0x0)

          struct ("foo", {1, 2, 3})
            => 1x3 struct array containing the fields:
              foo


     The first case is an ordinary scalar struct--one field, one value.
     The second produces an empty struct array with one field and no
     values, since s being passed an empty cell array of struct array
     values.  When the value is a cell array containing a single entry,
     this becomes a scalar struct with that single entry as the value of
     the field.  That single entry happens to be an empty cell array.

     Finally, if the value is a non-scalar cell array, then 'struct'
     produces a struct *array*.

     See also: cell2struct, fieldnames, orderfields, getfield, setfield,
     rmfield, structfun.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Create a scalar or array structure and initialize its values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
struct2cell


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 828
 -- Built-in Function: C = struct2cell (S)
     Create a new cell array from the objects stored in the struct
     object.  If F is the number of fields in the structure, the
     resulting cell array will have a dimension vector corresponding to
     '[F size(S)]'.  For example:

          s = struct ("name", {"Peter", "Hannah", "Robert"},
                     "age", {23, 16, 3});
          c = struct2cell (s)
             => c = {2x1x3 Cell Array}
          c(1,1,:)(:)
             =>
                {
                  [1,1] = Peter
                  [2,1] = Hannah
                  [3,1] = Robert
                }
          c(2,1,:)(:)
             =>
                {
                  [1,1] = 23
                  [2,1] = 16
                  [3,1] = 3
                }

     See also: cell2struct, fieldnames.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Create a new cell array from the objects stored in the struct object.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 22
struct_levels_to_print


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 563
 -- Built-in Function: VAL = struct_levels_to_print ()
 -- Built-in Function: OLD_VAL = struct_levels_to_print (NEW_VAL)
 -- Built-in Function: struct_levels_to_print (NEW_VAL, "local")
     Query or set the internal variable that specifies the number of
     structure levels to display.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: print_struct_array_contents.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that specifies the number of
structure levels



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
strvcat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1166
 -- Built-in Function: strvcat (X)
 -- Built-in Function: strvcat (X, ...)
 -- Built-in Function: strvcat (S1, S2, ...)
 -- Built-in Function: strvcat (CELL_ARRAY)
     Create a character array from one or more numeric matrices,
     character matrices, or cell arrays.  Arguments are concatenated
     vertically.  The returned values are padded with blanks as needed
     to make each row of the string array have the same length.  Unlike
     'char', empty strings are removed and will not appear in the
     output.

     For numerical input, each element is converted to the corresponding
     ASCII character.  A range error results if an input is outside the
     ASCII range (0-255).

     For cell arrays, each element is concatenated separately.  Cell
     arrays converted through 'strvcat' can mostly be converted back
     with 'cellstr'.  For example:

          strvcat ([97, 98, 99], "", {"98", "99", 100}, "str1", ["ha", "lf"])
                => ["abc    "
                    "98     "
                    "99     "
                    "d      "
                    "str1   "
                    "half   "]

     See also: char, strcat, cstrcat.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Create a character array from one or more numeric matrices, character
matrices, 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
sub2ind


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 472
 -- Function File: IND = sub2ind (DIMS, I, J)
 -- Function File: IND = sub2ind (DIMS, S1, S2, ..., SN)
     Convert subscripts to a linear index.

     The following example shows how to convert the two-dimensional
     index '(2,3)' of a 3-by-3 matrix to a linear index.  The matrix is
     linearly indexed moving from one column to next, filling up all
     rows in each column.

          linear_index = sub2ind ([3, 3], 2, 3)
          => 8

     See also: ind2sub.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Convert subscripts to a linear index.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
subsasgn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 885
 -- Built-in Function: subsasgn (VAL, IDX, RHS)
     Perform the subscripted assignment operation according to the
     subscript specified by IDX.

     The subscript IDX is expected to be a structure array with fields
     'type' and 'subs'.  Valid values for 'type' are '"()"', '"{}"', and
     '"."'.  The 'subs' field may be either '":"' or a cell array of
     index values.

     The following example shows how to set the two first columns of a
     3-by-3 matrix to zero.

          val = magic (3);
          idx.type = "()";
          idx.subs = {":", 1:2};
          subsasgn (val, idx, 0)
               =>  [ 0   0   6
                     0   0   7
                     0   0   2 ]

     Note that this is the same as writing 'val(:,1:2) = 0'.

     If IDX is an empty structure array with fields 'type' and 'subs',
     return RHS.

     See also: subsref, substruct.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Perform the subscripted assignment operation according to the subscript
specifie



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
subsref


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 958
 -- Built-in Function: subsref (VAL, IDX)
     Perform the subscripted element selection operation according to
     the subscript specified by IDX.

     The subscript IDX is expected to be a structure array with fields
     'type' and 'subs'.  Valid values for 'type' are '"()"', '"{}"', and
     '"."'.  The 'subs' field may be either '":"' or a cell array of
     index values.

     The following example shows how to extract the first two columns of
     a matrix

          val = magic (3)
              => val = [ 8   1   6
                         3   5   7
                         4   9   2 ]
          idx.type = "()";
          idx.subs = {":", 1:2};
          subsref (val, idx)
               => [ 8   1
                    3   5
                    4   9 ]

     Note that this is the same as writing 'val(:,1:2)'.

     If IDX is an empty structure array with fields 'type' and 'subs',
     return VAL.

     See also: subsasgn, substruct.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Perform the subscripted element selection operation according to the
subscript s



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
sum


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1009
 -- Built-in Function: sum (X)
 -- Built-in Function: sum (X, DIM)
 -- Built-in Function: sum (..., "native")
 -- Built-in Function: sum (..., "double")
 -- Built-in Function: sum (..., "extra")
     Sum of elements along dimension DIM.  If DIM is omitted, it
     defaults to the first non-singleton dimension.

     If the optional argument "native" is given, then the sum is
     performed in the same type as the original argument, rather than in
     the default double type.  For example:

          sum ([true, true])
             => 2
          sum ([true, true], "native")
             => true

     On the contrary, if "double" is given, the sum is performed in
     double precision even for single precision inputs.

     For double precision inputs, "extra" indicates that a more accurate
     algorithm than straightforward summation is to be used.  For single
     precision inputs, "extra" is the same as "double".  Otherwise,
     "extra" has no effect.

     See also: cumsum, sumsq, prod.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Sum of elements along dimension DIM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
sumsq


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 393
 -- Built-in Function: sumsq (X)
 -- Built-in Function: sumsq (X, DIM)
     Sum of squares of elements along dimension DIM.  If DIM is omitted,
     it defaults to the first non-singleton dimension.

     This function is conceptually equivalent to computing

          sum (x .* conj (x), dim)

     but it uses less memory and avoids calling 'conj' if X is real.

     See also: sum, prod.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Sum of squares of elements along dimension DIM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
superiorto


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 345
 -- Built-in Function: superiorto (CLASS_NAME, ...)
     When called from a class constructor, mark the object currently
     constructed as having a higher precedence than CLASS_NAME.  More
     that one such class can be specified in a single call.  This
     function may only be called from a class constructor.

     See also: inferiorto.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
When called from a class constructor, mark the object currently
constructed as h



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 29
suppress_verbose_help_message


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 643
 -- Built-in Function: VAL = suppress_verbose_help_message ()
 -- Built-in Function: OLD_VAL = suppress_verbose_help_message (NEW_VAL)
 -- Built-in Function: suppress_verbose_help_message (NEW_VAL, "local")
     Query or set the internal variable that controls whether Octave
     will add additional help information to the end of the output from
     the 'help' command and usage messages for built-in commands.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that controls whether Octave will add
additio



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
svd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1169
 -- Built-in Function: S = svd (A)
 -- Built-in Function: [U, S, V] = svd (A)
 -- Built-in Function: [U, S, V] = svd (A, ECON)
     Compute the singular value decomposition of A

          A = U*S*V'

     The function 'svd' normally returns only the vector of singular
     values.  When called with three return values, it computes U, S,
     and V.  For example,

          svd (hilb (3))

     returns

          ans =

            1.4083189
            0.1223271
            0.0026873

     and

          [u, s, v] = svd (hilb (3))

     returns

          u =

            -0.82704   0.54745   0.12766
            -0.45986  -0.52829  -0.71375
            -0.32330  -0.64901   0.68867

          s =

            1.40832  0.00000  0.00000
            0.00000  0.12233  0.00000
            0.00000  0.00000  0.00269

          v =

            -0.82704   0.54745   0.12766
            -0.45986  -0.52829  -0.71375
            -0.32330  -0.64901   0.68867

     If given a second argument, 'svd' returns an economy-sized
     decomposition, eliminating the unnecessary rows or columns of U or
     V.

     See also: svd_driver, svds, eig, lu, chol, hess, qr, qz.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Compute the singular value decomposition of A



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
svd_driver


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 546
 -- Built-in Function: VAL = svd_driver ()
 -- Built-in Function: OLD_VAL = svd_driver (NEW_VAL)
 -- Built-in Function: svd_driver (NEW_VAL, "local")
     Query or set the underlying LAPACK driver used by 'svd'.  Currently
     recognized values are "gesvd" and "gesdd".  The default is "gesvd".

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: svd.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 56
Query or set the underlying LAPACK driver used by 'svd'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
syl


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 280
 -- Built-in Function: X = syl (A, B, C)
     Solve the Sylvester equation

          A X + X B + C = 0

     using standard LAPACK subroutines.  For example:

          syl ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10; 11, 12])
             => [ -0.50000, -0.66667; -0.66667, -0.50000 ]




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Solve the Sylvester equation



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
symlink


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 346
 -- Built-in Function: symlink OLD NEW
 -- Built-in Function: [ERR, MSG] = symlink (OLD, NEW)
     Create a symbolic link NEW which contains the string OLD.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise, ERR
     is nonzero and MSG contains a system-dependent error message.

     See also: link, unlink, readlink, lstat.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Create a symbolic link NEW which contains the string OLD.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
system


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1690
 -- Built-in Function: system ("STRING")
 -- Built-in Function: system ("STRING", RETURN_OUTPUT)
 -- Built-in Function: system ("STRING", RETURN_OUTPUT, TYPE)
 -- Built-in Function: [STATUS, OUTPUT] = system (...)
     Execute a shell command specified by STRING.  If the optional
     argument TYPE is "async", the process is started in the background
     and the process ID of the child process is returned immediately.
     Otherwise, the child process is started and Octave waits until it
     exits.  If the TYPE argument is omitted, it defaults to the value
     "sync".

     If SYSTEM is called with one or more output arguments, or if the
     optional argument RETURN_OUTPUT is true and the subprocess is
     started synchronously, then the output from the command is returned
     as a variable.  Otherwise, if the subprocess is executed
     synchronously, its output is sent to the standard output.  To send
     the output of a command executed with 'system' through the pager,
     use a command like

          [output, text] = system ("cmd");
          disp (text);

     or

          printf ("%s\n", nthargout (2, "system", "cmd"));

     The 'system' function can return two values.  The first is the exit
     status of the command and the second is any output from the command
     that was written to the standard output stream.  For example,

          [status, output] = system ("echo foo; exit 2");

     will set the variable 'output' to the string 'foo', and the
     variable 'status' to the integer '2'.

     For commands run asynchronously, STATUS is the process id of the
     command shell that is started to run the command.

     See also: unix, dos.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Execute a shell command specified by STRING.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
tan


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 124
 -- Mapping Function: tan (Z)
     Compute the tangent for each element of X in radians.

     See also: atan, tand, tanh.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Compute the tangent for each element of X in radians.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
tanh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 122
 -- Mapping Function: tanh (X)
     Compute hyperbolic tangent for each element of X.

     See also: atanh, sinh, cosh.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Compute hyperbolic tangent for each element of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
terminal_size


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 201
 -- Built-in Function: terminal_size ()
     Return a two-element row vector containing the current size of the
     terminal window in characters (rows and columns).

     See also: list_in_columns.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a two-element row vector containing the current size of the
terminal wind



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
texi_macros_file


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 984
 -- Built-in Function: VAL = texi_macros_file ()
 -- Built-in Function: OLD_VAL = texi_macros_file (NEW_VAL)
 -- Built-in Function: texi_macros_file (NEW_VAL, "local")
     Query or set the internal variable that specifies the name of the
     file containing Texinfo macros that are prepended to documentation
     strings before they are passed to makeinfo.  The default value is
     'OCTAVE-HOME/share/octave/VERSION/etc/macros.texi', in which
     OCTAVE-HOME is the root directory of the Octave installation, and
     VERSION is the Octave version number.  The default value may be
     overridden by the environment variable 'OCTAVE_TEXI_MACROS_FILE',
     or the command line argument '--texi-macros-file FNAME'.

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: makeinfo_program.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Query or set the internal variable that specifies the name of the file
containin



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
tic


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1196
 -- Built-in Function: tic ()
 -- Built-in Function: ID = tic ()
 -- Built-in Function: toc ()
 -- Built-in Function: toc (ID)
 -- Built-in Function: VAL = toc (...)
     Set or check a wall-clock timer.  Calling 'tic' without an output
     argument sets the internal timer state.  Subsequent calls to 'toc'
     return the number of seconds since the timer was set.  For example,

          tic ();
          # many computations later...
          elapsed_time = toc ();

     will set the variable 'elapsed_time' to the number of seconds since
     the most recent call to the function 'tic'.

     If called with one output argument, 'tic' returns a scalar of type
     'uint64' that may be later passed to 'toc'.

          id = tic; sleep (5); toc (id)
                => 5.0010

     Calling 'tic' and 'toc' this way allows nested timing calls.

     If you are more interested in the CPU time that your process used,
     you should use the 'cputime' function instead.  The 'tic' and 'toc'
     functions report the actual wall clock time that elapsed between
     the calls.  This may include time spent processing other jobs or
     doing nothing at all.

     See also: toc, cputime.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Set or check a wall-clock timer.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
tilde_expand


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 687
 -- Built-in Function: tilde_expand (STRING)
     Perform tilde expansion on STRING.  If STRING begins with a tilde
     character, ('~'), all of the characters preceding the first slash
     (or all characters, if there is no slash) are treated as a possible
     user name, and the tilde and the following characters up to the
     slash are replaced by the home directory of the named user.  If the
     tilde is followed immediately by a slash, the tilde is replaced by
     the home directory of the user running Octave.  For example:

          tilde_expand ("~joeuser/bin")
               => "/home/joeuser/bin"
          tilde_expand ("~/bin")
               => "/home/jwe/bin"




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Perform tilde expansion on STRING.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
time


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 444
 -- Built-in Function: SECONDS = time ()
     Return the current time as the number of seconds since the epoch.
     The epoch is referenced to 00:00:00 CUT (Coordinated Universal
     Time) 1 Jan 1970.  For example, on Monday February 17, 1997 at
     07:15:06 CUT, the value returned by 'time' was 856163706.

     See also: strftime, strptime, localtime, gmtime, mktime, now, date,
     clock, datenum, datestr, datevec, calendar, weekday.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Return the current time as the number of seconds since the epoch.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
times


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 414
 -- Built-in Function: times (X, Y)
 -- Built-in Function: times (X1, X2, ...)
     Return the element-by-element multiplication product of inputs.
     This function and x .* y are equivalent.  If more arguments are
     given, the multiplication is applied cumulatively from left to
     right:

          (...((x1 .* x2) .* x3) .* ...)

     At least one argument is required.

     See also: mtimes, rdivide.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Return the element-by-element multiplication product of inputs.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
tmpfile


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 476
 -- Built-in Function: [FID, MSG] = tmpfile ()
     Return the file ID corresponding to a new temporary file with a
     unique name.  The file is opened in binary read/write ("w+b") mode.
     The file will be deleted automatically when it is closed or when
     Octave exits.

     If successful, FID is a valid file ID and MSG is an empty string.
     Otherwise, FID is -1 and MSG contains a system-dependent error
     message.

     See also: tmpnam, mkstemp, P_tmpdir.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Return the file ID corresponding to a new temporary file with a unique
name.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
tmpnam


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 635
 -- Built-in Function: tmpnam ()
 -- Built-in Function: tmpnam (DIR)
 -- Built-in Function: tmpnam (DIR, PREFIX)
     Return a unique temporary file name as a string.

     If PREFIX is omitted, a value of "oct-" is used.  If DIR is also
     omitted, the default directory for temporary files is used.  If DIR
     is provided, it must exist, otherwise the default directory for
     temporary files is used.  Since the named file is not opened, by
     'tmpnam', it is possible (though relatively unlikely) that it will
     not be available by the time your program attempts to open it.

     See also: tmpfile, mkstemp, P_tmpdir.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Return a unique temporary file name as a string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
toascii


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 193
 -- Mapping Function: toascii (S)
     Return ASCII representation of S in a matrix.  For example:

          toascii ("ASCII")
               => [ 65, 83, 67, 73, 73 ]


     See also: char.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Return ASCII representation of S in a matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
toc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 132
 -- Built-in Function: toc ()
 -- Built-in Function: toc (ID)
 -- Built-in Function: VAL = toc (...)

     See also: tic, cputime.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
See also: tic, cputime.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
tolower


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 362
 -- Mapping Function: tolower (S)
 -- Mapping Function: lower (S)
     Return a copy of the string or cell string S, with each uppercase
     character replaced by the corresponding lowercase one;
     non-alphabetic characters are left unchanged.  For example:

          tolower ("MiXeD cAsE 123")
                => "mixed case 123"

     See also: toupper.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a copy of the string or cell string S, with each uppercase
character repl



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
toupper


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 362
 -- Mapping Function: toupper (S)
 -- Mapping Function: upper (S)
     Return a copy of the string or cell string S, with each lowercase
     character replaced by the corresponding uppercase one;
     non-alphabetic characters are left unchanged.  For example:

          toupper ("MiXeD cAsE 123")
                => "MIXED CASE 123"

     See also: tolower.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a copy of the string or cell string S, with each lowercase
character repl



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
transpose


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 138
 -- Built-in Function: transpose (X)
     Return the transpose of X.  This function and x.'  are equivalent.

     See also: ctranspose.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 26
Return the transpose of X.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
tril


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1370
 -- Function File: tril (A)
 -- Function File: tril (A, K)
 -- Function File: tril (A, K, PACK)
 -- Function File: triu (A)
 -- Function File: triu (A, K)
 -- Function File: triu (A, K, PACK)
     Return a new matrix formed by extracting the lower ('tril') or
     upper ('triu') triangular part of the matrix A, and setting all
     other elements to zero.  The second argument is optional, and
     specifies how many diagonals above or below the main diagonal
     should also be set to zero.

     The default value of K is zero, so that 'triu' and 'tril' normally
     include the main diagonal as part of the result.

     If the value of K is nonzero integer, the selection of elements
     starts at an offset of K diagonals above or below the main
     diagonal; above for positive K and below for negative K.

     The absolute value of K must not be greater than the number of
     sub-diagonals or super-diagonals.

     For example:

          tril (ones (3), -1)
               =>  0  0  0
                   1  0  0
                   1  1  0

     and

          tril (ones (3), 1)
               =>  1  1  0
                   1  1  1
                   1  1  1

     If the option "pack" is given as third argument, the extracted
     elements are not inserted into a matrix, but rather stacked
     column-wise one above other.

     See also: diag.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a new matrix formed by extracting the lower ('tril') or upper
('triu') tr



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
triu


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 164
 -- Function File: triu (A)
 -- Function File: triu (A, K)
 -- Function File: triu (A, K, PACK)
     See the documentation for the 'tril' function (*note tril::).




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
See the documentation for the 'tril' function (*note tril::).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
true


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 454
 -- Built-in Function: true (X)
 -- Built-in Function: true (N, M)
 -- Built-in Function: true (N, M, K, ...)
     Return a matrix or N-dimensional array whose elements are all
     logical 1.  If invoked with a single scalar integer argument,
     return a square matrix of the specified size.  If invoked with two
     or more scalar integer arguments, or a vector of integer values,
     return an array with given dimensions.

     See also: false.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Return a matrix or N-dimensional array whose elements are all logical 1.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
typecast


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1431
 -- Built-in Function: typecast (X, CLASS)
     Return a new array Y resulting from interpreting the data of X in
     memory as data of the numeric class CLASS.  Both the class of X and
     CLASS must be one of the built-in numeric classes:

          "logical"
          "char"
          "int8"
          "int16"
          "int32"
          "int64"
          "uint8"
          "uint16"
          "uint32"
          "uint64"
          "double"
          "single"
          "double complex"
          "single complex"

     the last two are reserved for CLASS; they indicate that a
     complex-valued result is requested.  Complex arrays are stored in
     memory as consecutive pairs of real numbers.  The sizes of integer
     types are given by their bit counts.  Both logical and char are
     typically one byte wide; however, this is not guaranteed by C++.
     If your system is IEEE conformant, single and double should be 4
     bytes and 8 bytes wide, respectively.  "logical" is not allowed for
     CLASS.  If the input is a row vector, the return value is a row
     vector, otherwise it is a column vector.  If the bit length of X is
     not divisible by that of CLASS, an error occurs.

     An example of the use of typecast on a little-endian machine is

          X = uint16 ([1, 65535]);
          typecast (X, "uint8")
          => [   1,   0, 255, 255]

     See also: cast, bitunpack, bitpack, swapbytes.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a new array Y resulting from interpreting the data of X in memory
as data



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
typeinfo


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 275
 -- Built-in Function: typeinfo ()
 -- Built-in Function: typeinfo (EXPR)

     Return the type of the expression EXPR, as a string.  If EXPR is
     omitted, return a cell array of strings containing all the
     currently installed data types.

     See also: class, isa.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Return the type of the expression EXPR, as a string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
uint16


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 149
 -- Built-in Function: uint16 (X)
     Convert X to unsigned 16-bit integer type.

     See also: int8, uint8, int16, int32, uint32, int64, uint64.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Convert X to unsigned 16-bit integer type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
uint32


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 149
 -- Built-in Function: uint32 (X)
     Convert X to unsigned 32-bit integer type.

     See also: int8, uint8, int16, uint16, int32, int64, uint64.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Convert X to unsigned 32-bit integer type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
uint64


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 149
 -- Built-in Function: uint64 (X)
     Convert X to unsigned 64-bit integer type.

     See also: int8, uint8, int16, uint16, int32, uint32, int64.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Convert X to unsigned 64-bit integer type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
uint8


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 148
 -- Built-in Function: uint8 (X)
     Convert X to unsigned 8-bit integer type.

     See also: int8, int16, uint16, int32, uint32, int64, uint64.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Convert X to unsigned 8-bit integer type.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
umask


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 315
 -- Built-in Function: umask (MASK)
     Set the permission mask for file creation.  The parameter MASK is
     an integer, interpreted as an octal number.  If successful, returns
     the previous value of the mask (as an integer to be interpreted as
     an octal number); otherwise an error message is printed.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Set the permission mask for file creation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
uminus


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 108
 -- Built-in Function: uminus (X)
     This function and - x are equivalent.

     See also: uplus, minus.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
This function and - x are equivalent.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
uname


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 537
 -- Built-in Function: [UTS, ERR, MSG] = uname ()
     Return system information in the structure.  For example:

          uname ()
             => {
                   sysname = x86_64
                   nodename = segfault
                   release = 2.6.15-1-amd64-k8-smp
                   version = Linux
                   machine = #2 SMP Thu Feb 23 04:57:49 UTC 2006
                }

     If successful, ERR is 0 and MSG is an empty string.  Otherwise, ERR
     is nonzero and MSG contains a system-dependent error message.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Return system information in the structure.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
undo_string_escapes


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 767
 -- Built-in Function: undo_string_escapes (S)
     Convert special characters in strings back to their escaped forms.
     For example, the expression

          bell = "\a";

     assigns the value of the alert character (control-g, ASCII code 7)
     to the string variable 'bell'.  If this string is printed, the
     system will ring the terminal bell (if it is possible).  This is
     normally the desired outcome.  However, sometimes it is useful to
     be able to print the original representation of the string, with
     the special characters replaced by their escape sequences.  For
     example,

          octave:13> undo_string_escapes (bell)
          ans = \a

     replaces the unprintable alert character with its printable
     representation.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Convert special characters in strings back to their escaped forms.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
unlink


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 225
 -- Built-in Function: [ERR, MSG] = unlink (FILE)
     Delete the file named FILE.

     If successful, ERR is 0 and MSG is an empty string.  Otherwise, ERR
     is nonzero and MSG contains a system-dependent error message.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Delete the file named FILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
uplus


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 114
 -- Built-in Function: uplus (X)
     This function and + x are equivalent.

     See also: uminus, plus, minus.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
This function and + x are equivalent.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
upper


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 362
 -- Mapping Function: toupper (S)
 -- Mapping Function: upper (S)
     Return a copy of the string or cell string S, with each lowercase
     character replaced by the corresponding uppercase one;
     non-alphabetic characters are left unchanged.  For example:

          toupper ("MiXeD cAsE 123")
                => "MIXED CASE 123"

     See also: tolower.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a copy of the string or cell string S, with each lowercase
character repl



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
urlread


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1230
 -- Loadable Function: S = urlread (URL)
 -- Loadable Function: [S, SUCCESS] = urlread (URL)
 -- Loadable Function: [S, SUCCESS, MESSAGE] = urlread (URL)
 -- Loadable Function: [...] = urlread (URL, METHOD, PARAM)
     Download a remote file specified by its URL and return its content
     in string S.  For example:

          s = urlread ("ftp://ftp.octave.org/pub/octave/README");

     The variable SUCCESS is 1 if the download was successful, otherwise
     it is 0 in which case MESSAGE contains an error message.  If no
     output argument is specified and an error occurs, then the error is
     signaled through Octave's error handling mechanism.

     This function uses libcurl.  Curl supports, among others, the HTTP,
     FTP and FILE protocols.  Username and password may be specified in
     the URL.  For example:

          s = urlread ("http://user:password@example.com/file.txt");

     GET and POST requests can be specified by METHOD and PARAM.  The
     parameter METHOD is either 'get' or 'post' and PARAM is a cell
     array of parameter and value pairs.  For example:

          s = urlread ("http://www.google.com/search", "get",
                      {"query", "octave"});

     See also: urlwrite.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 79
Download a remote file specified by its URL and return its content in
string S.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
urlwrite


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1378
 -- Loadable Function: urlwrite (URL, LOCALFILE)
 -- Loadable Function: F = urlwrite (URL, LOCALFILE)
 -- Loadable Function: [F, SUCCESS] = urlwrite (URL, LOCALFILE)
 -- Loadable Function: [F, SUCCESS, MESSAGE] = urlwrite (URL, LOCALFILE)
     Download a remote file specified by its URL and save it as
     LOCALFILE.  For example:

          urlwrite ("ftp://ftp.octave.org/pub/octave/README",
                    "README.txt");

     The full path of the downloaded file is returned in F.  The
     variable SUCCESS is 1 if the download was successful, otherwise it
     is 0 in which case MESSAGE contains an error message.  If no output
     argument is specified and an error occurs, then the error is
     signaled through Octave's error handling mechanism.

     This function uses libcurl.  Curl supports, among others, the HTTP,
     FTP and FILE protocols.  Username and password may be specified in
     the URL, for example:

          urlwrite ("http://username:password@example.com/file.txt",
                    "file.txt");

     GET and POST requests can be specified by METHOD and PARAM.  The
     parameter METHOD is either 'get' or 'post' and PARAM is a cell
     array of parameter and value pairs.  For example:

          urlwrite ("http://www.google.com/search", "search.html",
                    "get", {"query", "octave"});

     See also: urlread.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Download a remote file specified by its URL and save it as LOCALFILE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
usage


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 851
 -- Built-in Function: usage (MSG)
     Print the message MSG, prefixed by the string 'usage: ', and set
     Octave's internal error state such that control will return to the
     top level without evaluating any more commands.  This is useful for
     aborting from functions.

     After 'usage' is evaluated, Octave will print a traceback of all
     the function calls leading to the usage message.

     You should use this function for reporting problems errors that
     result from an improper call to a function, such as calling a
     function with an incorrect number of arguments, or with arguments
     of the wrong type.  For example, most functions distributed with
     Octave begin with code like this

          if (nargin != 2)
            usage ("foo (a, b)");
          endif

     to check for the proper number of arguments.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Print the message MSG, prefixed by the string 'usage: ', and set
Octave's intern



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
usleep


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 335
 -- Built-in Function: usleep (MICROSECONDS)
     Suspend the execution of the program for the given number of
     microseconds.  On systems where it is not possible to sleep for
     periods of time less than one second, 'usleep' will pause the
     execution for 'round (MICROSECONDS / 1e6)' seconds.

     See also: sleep, pause.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 74
Suspend the execution of the program for the given number of
microseconds.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
vec


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 416
 -- Built-in Function: V = vec (X)
 -- Built-in Function: V = vec (X, DIM)
     Return the vector obtained by stacking the columns of the matrix X
     one above the other.  Without DIM this is equivalent to 'X(:)'.  If
     DIM is supplied, the dimensions of V are set to DIM with all
     elements along the last dimension.  This is equivalent to 'shiftdim
     (X(:), 1-DIM)'.

     See also: vech, resize, cat.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the vector obtained by stacking the columns of the matrix X one
above the



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
vectorize


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 514
 -- Built-in Function: vectorize (FUN)
     Create a vectorized version of the inline function FUN by replacing
     all occurrences of '*', '/', etc., with '.*', './', etc.

     This may be useful, for example, when using inline functions with
     numerical integration or optimization where a vector-valued
     function is expected.

          fcn = vectorize (inline ("x^2 - 1"))
             => fcn = f(x) = x.^2 - 1
          quadv (fcn, 0, 3)
             => 6

     See also: inline, formula, argnames.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Create a vectorized version of the inline function FUN by replacing all
occurren



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
vertcat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 359
 -- Built-in Function: vertcat (ARRAY1, ARRAY2, ..., ARRAYN)
     Return the vertical concatenation of N-D array objects, ARRAY1,
     ARRAY2, ..., ARRAYN along dimension 1.

     Arrays may also be concatenated vertically using the syntax for
     creating new matrices.  For example:

          VCAT = [ ARRAY1; ARRAY2; ... ]

     See also: cat, horzcat.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return the vertical concatenation of N-D array objects, ARRAY1, ARRAY2,
..., ARR



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
waitfor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1936
 -- Built-in Function: waitfor (H)
 -- Built-in Function: waitfor (H, PROP)
 -- Built-in Function: waitfor (H, PROP, VALUE)
 -- Built-in Function: waitfor (..., "timeout", TIMEOUT)
     Suspend the execution of the current program until a condition is
     satisfied on the graphics handle H.

     While the program is suspended graphics events are still being
     processed normally, allowing callbacks to modify the state of
     graphics objects.  This function is reentrant and can be called
     from a callback, while another 'waitfor' call is pending at the
     top-level.

     In the first form, program execution is suspended until the
     graphics object H is destroyed.  If the graphics handle is invalid,
     the function returns immediately.

     In the second form, execution is suspended until the graphics
     object is destroyed or the property named PROP is modified.  If the
     graphics handle is invalid or the property does not exist, the
     function returns immediately.

     In the third form, execution is suspended until the graphics object
     is destroyed or the property named PROP is set to VALUE.  The
     function 'isequal' is used to compare property values.  If the
     graphics handle is invalid, the property does not exist or the
     property is already set to VALUE, the function returns immediately.

     An optional timeout can be specified using the property 'timeout'.
     This timeout value is the number of seconds to wait for the
     condition to be true.  TIMEOUT must be at least 1.  If a smaller
     value is specified, a warning is issued and a value of 1 is used
     instead.  If the timeout value is not an integer, it is truncated
     towards 0.

     To define a condition on a property named 'timeout', use the string
     '\timeout' instead.

     In all cases, typing CTRL-C stops program execution immediately.

     See also: waitforbuttonpress, isequal.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Suspend the execution of the current program until a condition is
satisfied on t



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
waitpid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1491
 -- Built-in Function: [PID, STATUS, MSG] = waitpid (PID, OPTIONS)
     Wait for process PID to terminate.  The PID argument can be:

     -1
          Wait for any child process.

     0
          Wait for any child process whose process group ID is equal to
          that of the Octave interpreter process.

     > 0
          Wait for termination of the child process with ID PID.

     The OPTIONS argument can be a bitwise OR of zero or more of the
     following constants:

     '0'
          Wait until signal is received or a child process exits (this
          is the default if the OPTIONS argument is missing).

     'WNOHANG'
          Do not hang if status is not immediately available.

     'WUNTRACED'
          Report the status of any child processes that are stopped, and
          whose status has not yet been reported since they stopped.

     'WCONTINUE'
          Return if a stopped child has been resumed by delivery of
          'SIGCONT'.  This value may not be meaningful on all systems.

     If the returned value of PID is greater than 0, it is the process
     ID of the child process that exited.  If an error occurs, PID will
     be less than zero and MSG will contain a system-dependent error
     message.  The value of STATUS contains additional system-dependent
     information about the subprocess that exited.

     See also: WCONTINUE, WCOREDUMP, WEXITSTATUS, WIFCONTINUED,
     WIFSIGNALED, WIFSTOPPED, WNOHANG, WSTOPSIG, WTERMSIG, WUNTRACED.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Wait for process PID to terminate.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
warning


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2504
 -- Built-in Function: warning (TEMPLATE, ...)
 -- Built-in Function: warning (ID, TEMPLATE, ...)
 -- Built-in Function: warning ("on", ID)
 -- Built-in Function: warning ("off", ID)
 -- Built-in Function: warning ("query", ID)
 -- Built-in Function: warning ("error", ID)
 -- Built-in Function: warning (STATE, ID, "local")
     Format the optional arguments under the control of the template
     string TEMPLATE using the same rules as the 'printf' family of
     functions (*note Formatted Output::) and print the resulting
     message on the 'stderr' stream.  The message is prefixed by the
     character string 'warning: '.  You should use this function when
     you want to notify the user of an unusual condition, but only when
     it makes sense for your program to go on.

     The optional message identifier allows users to enable or disable
     warnings tagged by ID.  A message identifier is of the form
     "NAMESPACE:WARNING-NAME". Octave's own warnings use the "Octave"
     namespace (*note XREFwarning_ids::).  The special identifier "all"
     may be used to set the state of all warnings.

     If the first argument is "on" or "off", set the state of a
     particular warning using the identifier ID.  If the first argument
     is "query", query the state of this warning instead.  If the
     identifier is omitted, a value of "all" is assumed.  If you set the
     state of a warning to "error", the warning named by ID is handled
     as if it were an error instead.  So, for example, the following
     handles all warnings as errors:

          warning ("error");

     If the state is "on", "off", or "error" and the third argument is
     "local", then the warning state will be set temporarily, until the
     end of the current function.  Changes to warning states that are
     set locally affect the current function and all functions called
     from the current scope.  The previous warning state is restored on
     return from the current function.  The "local" option is ignored if
     used in the top-level workspace.

     Implementation Note: For compatibility with MATLAB, escape
     sequences (e.g., "\n" => newline) are processed in TEMPLATE
     regardless of whether TEMPLATE has been defined within single
     quotes as long as there are two or more input arguments.  Use a
     second backslash to stop interpolation of the escape sequence
     (e.g., "\\n") or use the 'regexptranslate' function.

     See also: warning_ids, lastwarn, error.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Format the optional arguments under the control of the template string
TEMPLATE 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
warranty


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 102
 -- Built-in Function: warranty ()
     Describe the conditions for copying and distributing Octave.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Describe the conditions for copying and distributing Octave.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3
who


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1154
 -- Command: who
 -- Command: who pattern ...
 -- Command: who option pattern ...
 -- Command: C = who ("pattern", ...)
     List currently defined variables matching the given patterns.
     Valid pattern syntax is the same as described for the 'clear'
     command.  If no patterns are supplied, all variables are listed.
     By default, only variables visible in the local scope are
     displayed.

     The following are valid options but may not be combined.

     'global'
          List variables in the global scope rather than the current
          scope.

     '-regexp'
          The patterns are considered to be regular expressions when
          matching the variables to display.  The same pattern syntax
          accepted by the 'regexp' function is used.

     '-file'
          The next argument is treated as a filename.  All variables
          found within the specified file are listed.  No patterns are
          accepted when reading variables from a file.

     If called as a function, return a cell array of defined variable
     names matching the given patterns.

     See also: whos, isglobal, isvarname, exist, regexp.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
List currently defined variables matching the given patterns.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
whos


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1719
 -- Command: whos
 -- Command: whos pattern ...
 -- Command: whos option pattern ...
 -- Command: S = whos ("pattern", ...)
     Provide detailed information on currently defined variables
     matching the given patterns.  Options and pattern syntax are the
     same as for the 'who' command.  Extended information about each
     variable is summarized in a table with the following default
     entries.

     Attr
          Attributes of the listed variable.  Possible attributes are:

          blank
               Variable in local scope

          'a'
               Automatic variable.  An automatic variable is one created
               by the interpreter, for example 'argn'.

          'c'
               Variable of complex type.

          'f'
               Formal parameter (function argument).

          'g'
               Variable with global scope.

          'p'
               Persistent variable.

     Name
          The name of the variable.

     Size
          The logical size of the variable.  A scalar is 1x1, a vector
          is 1xN or Nx1, a 2-D matrix is MxN.

     Bytes
          The amount of memory currently used to store the variable.

     Class
          The class of the variable.  Examples include double, single,
          char, uint16, cell, and struct.

     The table can be customized to display more or less information
     through the function 'whos_line_format'.

     If 'whos' is called as a function, return a struct array of defined
     variable names matching the given patterns.  Fields in the
     structure describing each variable are: name, size, bytes, class,
     global, sparse, complex, nesting, persistent.

     See also: who, whos_line_format.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Provide detailed information on currently defined variables matching the
given p



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
whos_line_format


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1967
 -- Built-in Function: VAL = whos_line_format ()
 -- Built-in Function: OLD_VAL = whos_line_format (NEW_VAL)
 -- Built-in Function: whos_line_format (NEW_VAL, "local")
     Query or set the format string used by the command 'whos'.

     A full format string is:

          %[modifier]<command>[:width[:left-min[:balance]]];

     The following command sequences are available:

     '%a'
          Prints attributes of variables (g=global, p=persistent,
          f=formal parameter, a=automatic variable).

     '%b'
          Prints number of bytes occupied by variables.

     '%c'
          Prints class names of variables.

     '%e'
          Prints elements held by variables.

     '%n'
          Prints variable names.

     '%s'
          Prints dimensions of variables.

     '%t'
          Prints type names of variables.

     Every command may also have an alignment modifier:

     'l'
          Left alignment.

     'r'
          Right alignment (default).

     'c'
          Column-aligned (only applicable to command %s).

     The 'width' parameter is a positive integer specifying the minimum
     number of columns used for printing.  No maximum is needed as the
     field will auto-expand as required.

     The parameters 'left-min' and 'balance' are only available when the
     column-aligned modifier is used with the command '%s'.  'balance'
     specifies the column number within the field width which will be
     aligned between entries.  Numbering starts from 0 which indicates
     the leftmost column.  'left-min' specifies the minimum field width
     to the left of the specified balance column.

     The default format is " %a:4; %ln:6; %cs:16:6:1; %rb:12;
     %lc:-1;\n".

     When called from inside a function with the "local" option, the
     variable is changed locally for the function and any subroutines it
     calls.  The original variable value is restored when exiting the
     function.

     See also: whos.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Query or set the format string used by the command 'whos'.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
yes_or_no


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 473
 -- Built-in Function: ANS = yes_or_no ("PROMPT")
     Ask the user a yes-or-no question.

     Return logical true if the answer is yes or false if the answer is
     no.  Takes one argument, PROMPT, which is the string to display
     when asking the question.  PROMPT should end in a space;
     'yes-or-no' adds the string '(yes or no) ' to it.  The user must
     confirm the answer with <RET> and can edit it until it has been
     confirmed.

     See also: input.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Ask the user a yes-or-no question.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
zeros


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 671
 -- Built-in Function: zeros (N)
 -- Built-in Function: zeros (M, N)
 -- Built-in Function: zeros (M, N, K, ...)
 -- Built-in Function: zeros ([M N ...])
 -- Built-in Function: zeros (..., CLASS)
     Return a matrix or N-dimensional array whose elements are all 0.
     If invoked with a single scalar integer argument, return a square
     NxN matrix.  If invoked with two or more scalar integer arguments,
     or a vector of integer values, return an array with the given
     dimensions.

     The optional argument CLASS specifies the class of the return array
     and defaults to double.  For example:

          val = zeros (m,n, "uint8")

     See also: ones.




# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Return a matrix or N-dimensional array whose elements are all 0.





